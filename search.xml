<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis 安装</title>
    <url>/2020/03/26/redis/redis-install/</url>
    <content><![CDATA[<h2 id="install-redis-on-centos7"><a href="#install-redis-on-centos7" class="headerlink" title="install redis on centos7"></a>install redis on centos7</h2><ol>
<li><p>下载安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis官网：http://download.redis.io/</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line">tar -xzvf redis-5.0.7.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.7</span><br><span class="line">make</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /src</span><br><span class="line">./redis-server  # 默认配置启动</span><br><span class="line">./redis-server &amp;  # 后台启动</span><br><span class="line"># ./redis-server ../redis.conf  # redis.conf 为默认配置文件，可以修改</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./redis-cli</span><br><span class="line">commond</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/python/python-network-note/</url>
    <content><![CDATA[<ul>
<li>python垃圾回收算法:<a href="https://www.jianshu.com/p/1e375fb40506" target="_blank" rel="noopener">https://www.jianshu.com/p/1e375fb40506</a></li>
<li>python与ruby垃圾回收：<a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby</a></li>
<li>python迭代器生成器：<a href="https://www.jianshu.com/p/dcc4c1af63c7" target="_blank" rel="noopener">https://www.jianshu.com/p/dcc4c1af63c7</a></li>
<li>python内存管理机制：<a href="https://www.jianshu.com/p/fb1d4dc8e367" target="_blank" rel="noopener">https://www.jianshu.com/p/fb1d4dc8e367</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/python/datastruct/</url>
    <content><![CDATA[<h2 id="八大数据结构"><a href="#八大数据结构" class="headerlink" title="八大数据结构"></a>八大数据结构</h2><h3 id="数组、链表、队列、栈、树、图、堆、散列表"><a href="#数组、链表、队列、栈、树、图、堆、散列表" class="headerlink" title="数组、链表、队列、栈、树、图、堆、散列表"></a>数组、链表、队列、栈、树、图、堆、散列表</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始</li>
<li>索引查询快；遍历速度快</li>
<li>扩容不方便，在内存中需要连续的存储空间；组只能存储一种类型的数据添加，删除的操作慢，因为要移动其他的元素。</li>
<li>使用场景：频繁查询，对存储空间要求不大，很少增加和删除的情况</li>
</ol><a id="more"></a>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ol>
<li>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈；</li>
<li>类似集装箱，先装入的后取出；所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列</li>
</ol>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ol>
<li>队列是一种特殊的线性表；不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队</li>
<li>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ol>
<li>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等</li>
<li>优点：添加和删除元素熟读快；不需要连续的地址空间</li>
<li>缺点：需要额外的空间存储指针，不适合数据量大的场景；查找时比较麻烦</li>
<li>适用场景：数据量较小，需要频繁增加，删除操作的场景</li>
</ol>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><ol>
<li>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合</li>
<li>特点<ol>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ol>
</li>
<li>二叉树<ol>
<li>每个结点最多有两颗子树，结点的度最大为2。</li>
<li>左子树和右子树是有顺序的，次序不能颠倒。</li>
<li>即使某结点只有一个子树，也要区分左右子树。</li>
<li>增删数据，查询数据都比较快，适合处理大批量数据</li>
</ol>
</li>
</ol>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><ol>
<li>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</li>
<li><strong>记录的存储位置=f(key)</strong></li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ol>
<li>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：<ol>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ol>
</li>
<li>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆</li>
</ol>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ol>
<li>图由节点的又穷集合和边的集合组成</li>
<li>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>身份认证</title>
    <url>/2020/03/26/network/%E5%9B%BE%E8%A7%A3HTTP_8/%E5%9B%BE%E8%A7%A3HTTP_8/</url>
    <content><![CDATA[<h2 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h2><ul>
<li>计算机不能判断使用者的具体身份，需要认证使用</li>
</ul><h3 id="http认证方式"><a href="#http认证方式" class="headerlink" title="http认证方式"></a>http认证方式</h3><h4 id="BASIC认证（基本认证）"><a href="#BASIC认证（基本认证）" class="headerlink" title="BASIC认证（基本认证）"></a>BASIC认证（基本认证）</h4><ul>
<li>认证过程<br><img src="/2020/03/26/network/图解HTTP_8/图解HTTP_8/8.1.png" alt="basic"></li>
<li>非加密处理</li>
</ul><ol start="2">
<li>DIGEST 认证（摘要认证）</li>
</ol><ul>
<li>认证过程<br><img src="/2020/03/26/network/图解HTTP_8/图解HTTP_8/8.2.png" alt="digest"></li>
<li>质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式</li>
</ul><a id="more"></a>



<ol start="3">
<li>SSL 客户端认证</li>
</ol>
<ul>
<li>借由HTTPS 的客户端证书完成认证的方式</li>
<li>认证过程<ol>
<li>接收到需要认证资源的请求，服务器会发送Certificate Request 报文，要求客户端提供客户端证书</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate 报文方式发送给服务器</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS 加密通信</li>
</ol>
</li>
<li>认证采用双因素认证<ul>
<li>采用证书认证和表单认证相结合</li>
<li>第一个认证因素的SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为</li>
</ul>
</li>
</ul>
<ol start="4">
<li>FormBase 认证（基于表单认证）</li>
</ol>
<ul>
<li>认证过程<br><img src="/2020/03/26/network/图解HTTP_8/图解HTTP_8/8.3.png" alt="session"><ol>
<li>客户端把用户ID 和密码等登录信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器</li>
<li>服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端</li>
<li>客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Networks</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/network/%E5%9B%BE%E8%A7%A3HTTP_1/%E5%9B%BE%E8%A7%A3HTTP_1/</url>
    <content><![CDATA[<h2 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h2><h3 id="HTTP-协议用于客户端和服务器端之间的通信"><a href="#HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP 协议用于客户端和服务器端之间的通信"></a>HTTP 协议用于客户端和服务器端之间的通信</h3><ol>
<li>应用HTTP 协议时，必定是一端担任客户端角色，另一端担<br>任服务器端角色</li>
</ol><h3 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h3><ol>
<li>请求必定由客户端发出，而服务器端回复响应</li>
<li>请求报文<ol>
<li>是由请求方法、请求URI、协议版本、可选的请求首部字段<br>和内容实体构成</li>
</ol>
</li>
<li>响应报头<ol>
<li>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代<br>码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主<br>体构成</li>
</ol>
</li>
</ol><a id="more"></a>

<h3 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h3><ol>
<li>HTTP 是一种不保存状态，即无状态（stateless）协议；协议对于发送过的请求或响应都不做持久化处理</li>
</ol>
<h3 id="请求URI-定位资源"><a href="#请求URI-定位资源" class="headerlink" title="请求URI 定位资源"></a>请求URI 定位资源</h3><ol>
<li>客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的<br>请求URI 包含在内</li>
</ol>
<h3 id="告知服务器意图的HTTP-方法"><a href="#告知服务器意图的HTTP-方法" class="headerlink" title="告知服务器意图的HTTP 方法"></a>告知服务器意图的HTTP 方法</h3><ol>
<li>GET ：获取资源<ol>
<li>GET 方法用来请求访问已被URI 识别的资源</li>
<li>如果请求的资源是文本，那就保<br>持原样返回；如果是像CGI（Common Gateway Interface，通用网关接<br>口）那样的程序，则返回经过执行后的输出结果</li>
</ol>
</li>
<li>POST：传输实体主体<ol>
<li>POST 方法用来传输实体的主体</li>
<li>GET 方法也可以传输实体的主体，但一般不用GET 方法进行传输，而是用POST 方法</li>
<li>POST 的功能与GET 很相似，但POST 的主要目的并不是获取响应的主体内容</li>
</ol>
</li>
<li>PUT：传输文件<ol>
<li>PUT 方法用来传输文件。就像FTP 协议的文件上传一样，要求在请<br>求报文的主体中包含文件内容，然后保存到请求URI 指定的位置</li>
</ol>
</li>
<li>HEAD：获得报文首部<ol>
<li>HEAD 方法和GET 方法一样，只是不返回报文主体部分。用于确认<br>URI 的有效性及资源更新的日期时间等</li>
</ol>
</li>
<li>DELETE：删除文件<ol>
<li>DELETE 方法用来删除文件，是与PUT 相反的方法。DELETE 方法按<br>请求URI 删除指定的资源</li>
</ol>
</li>
<li>OPTIONS：询问支持的方法<ol>
<li>OPTIONS 方法用来查询针对请求URI 指定的资源支持的方法</li>
</ol>
</li>
<li>TRACE：追踪路径<ol>
<li>TRACE 方法是让Web 服务器端将之前的请求通信环回给客户端的方<br>法</li>
</ol>
</li>
<li>CONNECT：要求用隧道协议连接代理<ol>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协<br>议进行TCP 通信</li>
<li>主要使用SSL（Secure Sockets Layer，安全套接<br>层）和TLS（Transport Layer Security，传输层安全）协议把通信内容<br>加密后经网络隧道传输</li>
</ol>
</li>
</ol>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><ol>
<li>HTTP 协议的初始版本中，每进行一次HTTP 通信就要断开一次TCP<br>连接</li>
<li>HTTP/1.1 和一部分的HTTP/1.0 想出了<br>持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或<br>HTTP connection reuse）的方法。持久连接的特点是，只要任意一端<br>没有明确提出断开连接，则保持TCP 连接状态<ol>
<li>持久连接旨在建立1 次TCP 连接后进行多次请求和响应的交<br>互</li>
<li>减少了TCP 连接的重复建立和断开所造成的额<br>外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使<br>HTTP 请求和响应能够更早地结束，这样Web 页面的显示速度也就相<br>应提高</li>
</ol>
</li>
</ol>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><ol>
<li>同时并行发送多个请求。不等待响应，直接发送下一个请求</li>
<li>管线化技术则比持久连接还要快。请求数越多，时间差就越明显</li>
</ol>
<h3 id="使用Cookie-的状态管理"><a href="#使用Cookie-的状态管理" class="headerlink" title="使用Cookie 的状态管理"></a>使用Cookie 的状态管理</h3><ul>
<li>Cookie 技术通过在请求和响应报文中写入Cookie 信<br>息来控制客户端的状态<ol>
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie 的<br>首部字段信息，通知客户端保存Cookie</li>
<li>客户端再往该服务器<br>发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出<br>去</li>
<li>服务器端发现客户端发送过来的Cookie 后，会去检查究竟是从哪一<br>个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前<br>的状态信息</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/network/network_netwrotk_note/</url>
    <content><![CDATA[<ul>
<li>STP：<a href="https://blog.csdn.net/qq_34104227/article/details/81982689" target="_blank" rel="noopener">https://blog.csdn.net/qq_34104227/article/details/81982689</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/mysql/database-network-note/</url>
    <content><![CDATA[<ul>
<li>mysql碎片优化：<a href="https://mp.weixin.qq.com/s/VfxVKnfglzsBLD4-Z69zWQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VfxVKnfglzsBLD4-Z69zWQ</a></li>
<li>mysql semi-sync半同步复制：<a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1433074</a></li>
<li>mysql高可用MHA搭建：<a href="https://www.cnblogs.com/gomysql/p/3675429.html" target="_blank" rel="noopener">https://www.cnblogs.com/gomysql/p/3675429.html</a></li>
<li>mysql高可用MHA搭建：<a href="https://www.cnblogs.com/struggle-1216/p/11939168.html" target="_blank" rel="noopener">https://www.cnblogs.com/struggle-1216/p/11939168.html</a></li>
<li>mycat搭建：<a href="https://www.jianshu.com/p/f02a48226222" target="_blank" rel="noopener">https://www.jianshu.com/p/f02a48226222</a></li>
<li>maxscale搭建：<a href="https://www.jianshu.com/p/70d94a8f6491" target="_blank" rel="noopener">https://www.jianshu.com/p/70d94a8f6491</a></li>
<li>深度探索MySQL主从复制原理：<a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50597960</a></li>
<li>mysql8复制-半同步复制：<a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1433074</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2020/03/26/linux/linux-network-note/</url>
    <content><![CDATA[<ul>
<li>进程线程协程：<a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">https://blog.csdn.net/daaikuaichuan/article/details/82951084</a></li>
<li>apache MPM工作模式：<a href="https://www.cnblogs.com/luoyan01/p/9948092.html" target="_blank" rel="noopener">https://www.cnblogs.com/luoyan01/p/9948092.html</a></li>
<li>写时复制：<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></li>
<li>linux调度：<a href="https://blog.csdn.net/qq_37375427/article/details/83046906" target="_blank" rel="noopener">https://blog.csdn.net/qq_37375427/article/details/83046906</a></li>
<li>centos7 开机详解：<a href="https://blog.csdn.net/weixin_34007906/article/details/93529347?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34007906/article/details/93529347?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li>
<li>linux防火墙之iptables：<a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">http://www.zsythink.net/archives/tag/iptables/page/2/</a></li>
<li>linux各种括号：<a href="https://blog.csdn.net/taiyang1987912/article/details/39551385" target="_blank" rel="noopener">https://blog.csdn.net/taiyang1987912/article/details/39551385</a></li>
<li>linux负载均衡lvs：<a href="https://www.cnblogs.com/yanjieli/p/10582324.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanjieli/p/10582324.html</a></li>
<li>linux VRRP：<a href="https://www.jianshu.com/p/81115a4293c7" target="_blank" rel="noopener">https://www.jianshu.com/p/81115a4293c7</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySQL Join 知识点</title>
    <url>/2020/03/25/mysql/mysql_join/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#join语句">join语句</a></li>
<li><a href="#join连接算法">join连接算法</a><ul>
<li><a href="#nlj">NLJ</a></li>
<li><a href="#simple-nested-loop-join">Simple Nested-Loop Join</a></li>
<li><a href="#bnl">BNL</a></li>
</ul>
</li>
<li><a href="#join小结">join小结</a></li>
<li><a href="#join优化">join优化</a><ul>
<li><a href="#multi-range-read-mrr算法">Multi-Range Read （MRR算法）</a></li>
<li><a href="#batched-key-accessbka算法">Batched Key Access（BKA算法）</a></li>
<li><a href="#对于bnl的优化">对于BNL的优化</a></li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="join语句"><a href="#join语句" class="headerlink" title="join语句"></a>join语句</h1><ul>
<li><p>使用join语句可以将不同的表按照设置的条件进行连接操作，通过一次查询操作可以得到更多的信息</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE_NAME t1 <span class="keyword">JOIN</span>(<span class="keyword">straight_join</span>) TABLE_NAME t2 <span class="keyword">ON</span> CONDITION;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>straight_join 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>
<p><img src="http://study.jeffqi.cn/mysql/sql_join.jpg" alt="sql_join"></p>
</li>
</ul>
</li>
</ul>
<h1 id="join连接算法"><a href="#join连接算法" class="headerlink" title="join连接算法"></a>join连接算法</h1><ul>
<li>Index Nested-Loop Join（NLJ）</li>
<li>Simple Nested-Loop Join（基本不会使用了，性能太差）</li>
<li>Block Nested-Loop Join（BNL）</li>
</ul>
<h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><ul>
<li><strong>运行过程</strong>：是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，<strong>并且可以用上被驱动表的索引</strong><br>  <img src="http://study.jeffqi.cn/mysql/NLJ.jpg" alt="NLJ"></li>
</ul>
<h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h2><ul>
<li>直接将驱动表和被驱动表一一连接在判断条件</li>
</ul>
<h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><ul>
<li><p><strong>运行流程</strong>：先将驱动表数据读入到join_buffer中，扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。<br>  <img src="http://study.jeffqi.cn/mysql/BNL.jpg" alt="BNL"></p>
</li>
<li><p><strong>join_buffer由join_buffer_size决定，如果数据太大，就需要分多次操作装入，复用join_buffer</strong></p>
</li>
</ul>
<h1 id="join小结"><a href="#join小结" class="headerlink" title="join小结"></a>join小结</h1><ul>
<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>
</ul>
<h1 id="join优化"><a href="#join优化" class="headerlink" title="join优化"></a>join优化</h1><h2 id="Multi-Range-Read-（MRR算法）"><a href="#Multi-Range-Read-（MRR算法）" class="headerlink" title="Multi-Range Read （MRR算法）"></a>Multi-Range Read （MRR算法）</h2><ul>
<li><p>MRR 的全称是 Multi-Range Read Optimization，是优化器<strong>将随机IO转化为顺序IO</strong>以降低查询过程中 IO 开销的一种手段，提高素具库的性能。</p>
</li>
<li><p>大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>
</li>
<li><p>random io and seq io</p>
<p>  <img src="http://study.jeffqi.cn/mysql/seq_and_random_io.jpg" alt="seq_and_random_io"></p>
</li>
<li><p><strong>运行流程</strong>：根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;将 read_rnd_buffer 中的 id 进行递增排序；排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</p>
<p>  <img src="http://study.jeffqi.cn/mysql/mrr_process.jpg" alt="mrr_process"></p>
</li>
<li><p><strong>未使用MRR时读取数据</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/no-mrr-access-pattern.png" alt="no_mrr_access"></p>
</li>
<li><p><strong>使用MRR时读取数据</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/mrr-access-pattern.png" alt="mrr_access"></p>
</li>
</ul>
<h2 id="Batched-Key-Access（BKA算法）"><a href="#Batched-Key-Access（BKA算法）" class="headerlink" title="Batched Key Access（BKA算法）"></a>Batched Key Access（BKA算法）</h2><ul>
<li><p>BKA算法是对join的优化，利用到了join_buffer，进而利用MRR的特性对于被驱动表上的索引的利用</p>
</li>
<li><p><strong>工作流程</strong></p>
<ol>
<li><p>BKA使用join buffer保存由join的第一个操作产生的符合条件的数据，<strong>这个数据是顺序读到join_buffer中的</strong></p>
</li>
<li><p>然后BKA算法构建key来访问被连接的表，并批量使用MRR接口提交keys到数据库存储引擎去查找查找。（通过对join_buffer中的驱动表的数据，按照被驱动表尚可利用的索引进行排序，调用MRR接口进行顺序读，提高join性能）</p>
</li>
<li><p>提交keys之后，MRR使用最佳的方式来获取行并反馈给BKA</p>
</li>
</ol>
</li>
<li><p><strong>BKA使用join buffer size来确定buffer的大小，buffer越大，访问被join的表/内部表就越顺序。</strong></p>
</li>
<li><p>未使用BKA算法</p>
<p>  <img src="http://study.jeffqi.cn/mysql/key-sorting-regular-nl-join.png" alt="key_sort_regular_nlj"></p>
</li>
<li><p>使用BKA算法</p>
<p>  <img src="http://study.jeffqi.cn/mysql/key-sorting-join.png" alt="key_sort_join"></p>
</li>
<li><p>mysql中BKA的启动</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BKA流程</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/BKA_process.png" alt="bka_process"></p>
</li>
</ul>
<h2 id="对于BNL的优化"><a href="#对于BNL的优化" class="headerlink" title="对于BNL的优化"></a>对于BNL的优化</h2><ul>
<li><p><strong>BNL导致的性能问题</strong></p>
<ol>
<li>如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。</li>
<li>如果这个冷表的数据量过大，因为mysql的LRU算法，会导致热点数据被淘汰，导致内存命中率下降。只能通过后面的查询进行恢复内存命中率，这是一个持续的影响（详解需要了解mysql的LRU算法）</li>
<li>数据表过大，会给系统io造成较大的压力。这个是暂时的join完成后就结束了</li>
<li><strong>为了减少这个影响，可以调大join_buffer_size的大小减少扫描的次数</strong></li>
</ol>
</li>
<li><p>BNL优化</p>
<ol>
<li>在被驱动表上创建索引，使其能够使用到MRR优化</li>
<li>如果是部分数据，可以对其创建内存零时表，然后创建索引列，使用MRR优化</li>
</ol>
</li>
<li><p>Hash-join优化</p>
<ol>
<li>join_buffer维护的一个无需数组，这时性能低的原因之一；如果维护一个hash表，那么扫描对比的次数就会大大减少</li>
<li>目前mysql没有实现hash-join，可以通过将数据交给后端处理<ol>
<li>select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构，比如 C++ 里的 set、PHP 的数组这样的数据结构。</li>
<li>select * from t2 where b&gt;=1 and b&lt;=2000; 获取表 t2 中满足条件的 2000 行数据。</li>
<li>把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/chenpingzhao/p/6720531.html" target="_blank" rel="noopener">ICP、MRR、BKA特性</a></li>
<li><a href="https://time.geekbang.org/column/article/80147" target="_blank" rel="noopener">极客时间JOIN优化</a></li>
<li><a href="https://time.geekbang.org/column/article/79700" target="_blank" rel="noopener">极客时间JOIN语句</a></li>
<li><a href="https://mariadb.com/kb/en/multi-range-read-optimization/#case-3-key-sorting-for-batched-key-access" target="_blank" rel="noopener">mariadb MRR</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>CPU性能排查实验案例</title>
    <url>/2020/03/24/linux/cpu%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>mysql主从复制</title>
    <url>/2020/03/23/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<ul>
<li><a href="#啥是主从复制">啥是主从复制？</a></li>
<li><a href="#主从复制有什么用">主从复制有什么用？</a></li>
<li><a href="#主从模式">主从模式</a><ul>
<li><a href="#一主一从一主多从">一主一从、一主多从</a></li>
<li><a href="#多主一从">多主一从</a></li>
<li><a href="#双主模式">双主模式</a></li>
<li><a href="#级联复制">级联复制</a></li>
</ul>
</li>
<li><a href="#mysql主从复制原理">mysql主从复制原理</a><ul>
<li><a href="#复制流程">复制流程</a></li>
</ul>
</li>
<li><a href="#mysql复制模式">mysql复制模式</a></li>
<li><a href="#性能提升">性能提升</a><ul>
<li><a href="#支持发送二进制日志事件和接收ack的异步化">支持发送二进制日志事件和接收ACK的异步化</a></li>
<li><a href="#控制主库接收确认反馈从库的数量">控制主库接收确认反馈从库的数量</a></li>
</ul>
</li>
<li><a href="#日志格式">日志格式</a><ul>
<li><a href="#binlog记录格式">binlog记录格式</a></li>
</ul>
</li>
<li><a href="#基于gtid复制实现的工作原理">基于GTID复制实现的工作原理</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->

</li>
</ul><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<h1 id="啥是主从复制？"><a href="#啥是主从复制？" class="headerlink" title="啥是主从复制？"></a>啥是主从复制？</h1><ul>
<li>主从复制就就是将主服务器上的数据，复制到一个或多个从服务器上；mysql默认采用异步复制，从节点可以复制主节点上的指定的数据库；</li>
</ul>
<h1 id="主从复制有什么用？"><a href="#主从复制有什么用？" class="headerlink" title="主从复制有什么用？"></a>主从复制有什么用？</h1><ul>
<li><p><strong>提供读写分离的能力</strong>：从服务器可以分代主库的读请求的压力，让主库更专注于数据的更新和写操作，有更好的写性能；</p>
</li>
<li><p><strong>数据备份</strong>：从库上拥有主库的完整的二进制日志，应用后可拥有和主库几乎相等的数据；在主库某些不可抗力的影响后，依旧能够保证真个数据库数据的完整性；方便切换</p>
</li>
<li><p><strong>高可用</strong>：主从复制是高可用的基础；可以使用多个节点来避免单点故障</p>
</li>
<li><p><strong>架构扩展</strong>：可以随着业务的增加，可以通过增加节点来提高适应能力。分担压力，将压力负载到多态服务器上</p>
</li>
</ul>
<h1 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h1><h2 id="一主一从、一主多从"><a href="#一主一从、一主多从" class="headerlink" title="一主一从、一主多从"></a>一主一从、一主多从</h2><ul>
<li>一主一到多从模式可以提升整个数据库的读能力，分代主库的压力</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/1_m_1_s.jpg" alt="1-m-1-s"><br><img src="http://study.jeffqi.cn/mysql/1_m_mulits_s.jpg" alt="1-m-mulits-s"></p>
<h2 id="多主一从"><a href="#多主一从" class="headerlink" title="多主一从"></a>多主一从</h2><ul>
<li>将多个主库的数据存储到一台存储性能好的服务器中</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/mulits_m_1_s.jpg" alt="mulits-m-1-s"></p>
<h2 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h2><ul>
<li>两台服务器互为主从，任意一个master修改后都会将数据日志复制到对方去；避免循环复制，从服务器在应用日志后，写日志时将日志的server-id改为应用日志的server-id，这样发送回去的时候主服务器就能够识别</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/double_m.jpg" alt="double-m"></p>
<h2 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h2><ul>
<li>部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/m-s-s.jpg" alt="m-s-s"></p>
<h1 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h1><ul>
<li><p>mysql主从复制中有三个线程<strong>dump thread（master）、io thread（slave）、sql thread（slave）</strong></p>
</li>
<li><p><strong>dump thread</strong>：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，在发动给从节点之后，锁会被释放。</p>
</li>
<li><p><strong>io thread</strong>：从节点上用来想主服务器请求日志，接收从主服务器发送的binlog，并更新到本地的relay-log中。</p>
</li>
<li><p><strong>sql thread</strong>：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p>
</li>
<li><p>当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。</p>
</li>
</ul>
<h2 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h2><ul>
<li><p>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
</li>
<li><p>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</p>
</li>
<li><p>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</p>
</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/mysql_replication_processes.png" alt="mysql-replication_processes"></p>
<h1 id="mysql复制模式"><a href="#mysql复制模式" class="headerlink" title="mysql复制模式"></a>mysql复制模式</h1><ul>
<li><p>异步复制<br><img src="http://study.jeffqi.cn/mysql/mysql_async_repl.jpg" alt="mysql_async_repl"></p>
</li>
<li><p>同步复制<br><img src="http://study.jeffqi.cn/mysql/mysql_%28semi%29_sync.jpg" alt="mysql_(semi)\_repl"></p>
</li>
<li><p>半同步复制</p>
</li>
<li><h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>  主节点不会主动推送二进制日志到从服务器，需要从服务器发起请求；主服务器的事务完成提交后立即返回结果给客户端，需要等待从服务器的确认。</p>
<ul>
<li><p><strong>优点</strong>：数据库吞吐量大，性能好</p>
</li>
<li><p><strong>缺点</strong>：因为不需要其他数据库的确认，可能在master宕机后，造成数据的丢失；从服务器也不能及时的更新数据</p>
</li>
</ul>
</li>
<li><h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>  当主库提交事务时，<strong>所有从库</strong>也将在主库返回执行事务的会话之前<strong>提交事务</strong>。这样能够保证数据的一致性和完整性</p>
<ul>
<li><p><strong>有点</strong>：数据库数据有备份，完整性好</p>
</li>
<li><p><strong>缺点</strong>：需要等待从库确认，主动推送日志，会有性能消耗；事务的过程边长</p>
</li>
</ul>
</li>
<li><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>  介于异步和完全同步复制之间。主库仅等待<strong>至少一个从库接收并记录事件</strong>。它不会等待所有从库确认收到，并且<strong>从库只需要确认接收</strong>，而不是事件已在从库完全执行和提交。</p>
<ul>
<li><p><strong>优点</strong>：至少有一个从库确认了二进制日志，保证了数据的完整性；同时不需要等待所有从库的确认，响应速度更快</p>
</li>
<li><p><strong>缺点</strong>：因为需要等待至少一个从库，所以有性能消耗；同时如果读写分离的读操作落在不是确认了日志的服务器上，会出现延迟更新的问题</p>
</li>
</ul>
</li>
</ul>
<h1 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h1><h2 id="支持发送二进制日志事件和接收ACK的异步化"><a href="#支持发送二进制日志事件和接收ACK的异步化" class="headerlink" title="支持发送二进制日志事件和接收ACK的异步化"></a>支持发送二进制日志事件和接收ACK的异步化</h2><ul>
<li>旧版本的半同步复制受限于Binlog Dump线程，原因是该线程承担了两份不同且又十分频繁的任务：传送二进制日志事件给从库 ；接收从库的ACK反馈信息。这两个任务是串行的，Binlog Dump线程必须等待从库返回之后才会传送下一个事件。Binlog Dump线程已然成为整个半同步复制性能的瓶颈。</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/old_repl_ack.png" alt="old_repl_ack"></p>
<ul>
<li>在5.7.4版本的半同步复制框架中，独立出一个Ack Receiver线程 ，专门用于接收从库返回的ACK请求，这将之前Binlog Dump线程的发送和接收工作分为了两个线程来处理。这样主库上有两个线程独立工作，可以同时发送二进制日志事件到从库，和接收从库的ACK信息</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/new_repl_ack.png" alt="new_repl_ack"></p>
<ul>
<li><p>Ack Receiver线程在主库启用半同步复制时创建，并在主库禁用半同步复制时销毁。它是自动创建和销毁的，因此不受用户控制</p>
</li>
<li><p>在MySQL 5.7.17之前，这个Ack Receiver线程采用了<strong>select机制来监听</strong>从库返回的结果，然而select机制监控的文件句柄只能是0-1024，当超过1024时，用户在MySQL的错误日志中或许会收到类似如下的报错，更有甚者会导致MySQL发生宕机。</p>
</li>
<li><p>MySQL 5.7.17版本开始，官方修复了这个bug，开始使用<strong>poll机制来替换原来的select机制</strong>，从而可以避免上面的问题。其实poll调用本质上和select没有区别，只是在I/O句柄数理论上没有上限</p>
</li>
</ul>
<h2 id="控制主库接收确认反馈从库的数量"><a href="#控制主库接收确认反馈从库的数量" class="headerlink" title="控制主库接收确认反馈从库的数量"></a>控制主库接收确认反馈从库的数量</h2><ul>
<li><p>MySQL 5.7新增了rpl_semi_sync_master_wait_for_slave_count系统变量，可以用来控制主库接收多少个从库写事务成功反馈，给高可用架构切换提供了灵活性。当该变量值为2时，主库需等待两个从库的ACK。</p>
</li>
<li><p>当然啦，数字越大越安全咯；因为更接近全同步复制了（手动滑稽）</p>
</li>
</ul>
<h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><ul>
<li>statment</li>
<li>row</li>
<li>mix</li>
</ul>
<h2 id="binlog记录格式"><a href="#binlog记录格式" class="headerlink" title="binlog记录格式"></a>binlog记录格式</h2><ul>
<li><h3 id="statment格式"><a href="#statment格式" class="headerlink" title="statment格式"></a>statment格式</h3><p>  该模式记录每一条sql语句，对于所有的增删改语句进行记录。日志文件较小，节约了io。但是在一些极端情况下会照成数据的不一致；</p>
</li>
<li><h3 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h3><p>   Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样；恢复数据是比较方便，不会出现不一致的问题；缺点是日志文件过大也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更；也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更</p>
</li>
<li><h3 id="mix格式"><a href="#mix格式" class="headerlink" title="mix格式"></a>mix格式</h3><p>  是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式</p>
</li>
</ul>
<h1 id="基于GTID复制实现的工作原理"><a href="#基于GTID复制实现的工作原理" class="headerlink" title="基于GTID复制实现的工作原理"></a>基于GTID复制实现的工作原理</h1><ul>
<li><p>在传统的复制里面，当发生故障，需要主从切换，需要找到binlog和pos点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错；使用GTID进行复制不需要其他的操作；MySQL会通过内部机制GTID自动找点同步。</p>
</li>
<li><p><strong>工作流程</strong></p>
<ol>
<li>主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。</li>
<li>从节点的I/O线程将变更的bin log，写入到本地的relay log中。</li>
<li>SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log）。</li>
<li>如果有记录，说明该GTID的事务已经执行，从节点会忽略。</li>
<li>如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。</li>
<li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。（<strong>没明白</strong>）</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">深度探索MySQL主从复制原理</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">mysql8复制-半同步复制</a></li>
<li><a href="https://wxy0327.blog.csdn.net/article/details/90081518" target="_blank" rel="noopener">mysql8复制-半同步复制配置</a></li>
<li><a href="https://time.geekbang.org/column/article/76446" target="_blank" rel="noopener">MySQL是怎么保证主备一致的？(极客时间)</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>初始CDN</title>
    <url>/2020/03/22/linux/CDN/</url>
    <content><![CDATA[<ul>
<li><a href="#cdn">CDN</a></li>
<li><a href="#cdn是个what">CDN是个what？</a><ul>
<li><a href="#cdn工作流程">CDN工作流程</a></li>
</ul>
</li>
<li><a href="#cdn相关技术">CDN相关技术</a><ul>
<li><a href="#负载均衡技术">负载均衡技术</a></li>
<li><a href="#动态内容分发与复制技术">动态内容分发与复制技术</a></li>
<li><a href="#缓存技术">缓存技术</a></li>
</ul>
</li>
<li><a href="#cdn的应用场景">CDN的应用场景</a></li>
<li><a href="#cdn的不足">CDN的不足</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->

</li>
</ul><h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><ul>
<li><p>随着互联网的发展，用户在使用网络时对网站的浏览速度和效果愈加重视，但由于网民数量激增，网络访问路径过长，从而使用户的访问质量受到严重影响。特别是当用户与网站之间的链路被突发的大流量数据拥塞时，对于异地互联网用户急速增加的地区来说，访问质量不良更是一个急待解决的问题。<strong>如何才能让各地的用户都能够进行高质量的访问，并尽量减少由此而产生的费用和网站管理压力呢？</strong></p>
</li>
<li><p>今天的角儿登场了：CDN（Content Delivery Network）内容发布网络变应运而生。</p>
</li>
</ul><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h1 id="CDN是个what？"><a href="#CDN是个what？" class="headerlink" title="CDN是个what？"></a>CDN是个what？</h1><ul>
<li>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可 以就近取得所需的内容，提高用户访问网站的响应速度。</li>
</ul>
<p><img src="http://study.jeffqi.cn/linux/cdn_zone_servers.jpg" alt="cdn_zone_servers"></p>
<ul>
<li>解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访 问网站的响应速度</li>
</ul>
<h2 id="CDN工作流程"><a href="#CDN工作流程" class="headerlink" title="CDN工作流程"></a>CDN工作流程</h2><ol>
<li>用户访问加入CDN服务的网站时，首先通过DNS重定向技术，找到距离用户最近的CDN节点，同时是用户指向该节点；</li>
<li>当用户的请求到达该节点的时候，CDN的服务器（节点上的高速缓存）负责将用户请求的内容提供给用户；</li>
<li><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2> 用户在自己的浏览器中输入要访问的网站的域名，浏览器向本地DNS请求对该域名的解析，本地DNS将请求发到网站的主DNS，主DNS根据一系列的策略确 定当时最适当的CDN节点，并将解析的结果（IP地址）发给用户，用户向给定的CDN节点请求相应网站的内容。</li>
</ol>
<h1 id="CDN相关技术"><a href="#CDN相关技术" class="headerlink" title="CDN相关技术"></a>CDN相关技术</h1><ul>
<li>CDN的实现需要依赖多种网络技术的支持，其中<strong>负载均衡技术、动态内容分发与复制技术、缓存技术</strong>是比较主要的几个</li>
</ul>
<h2 id="负载均衡技术"><a href="#负载均衡技术" class="headerlink" title="负载均衡技术"></a>负载均衡技术</h2><ul>
<li><p>网络中的负载均衡就是将流量尽可能的分配到不同的线路节点上，以此来减轻某些节点的负载，提高网络流量，同时提升网络服务质量</p>
</li>
<li><p>在 CDN中，负载均衡又分为<strong>服务器负载均衡</strong>和<strong>服务器整体负载均衡</strong>(也有的称为服务器全局负载均衡)</p>
</li>
<li><p><strong>服务器负载均衡</strong>：是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用</p>
</li>
<li><p><strong>服务器整体负载均衡</strong>：是指允许Web网络托管商、门户站点和企业 根据地理位置分配内容和服务；<strong>通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障</strong>。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。</p>
</li>
</ul>
<h2 id="动态内容分发与复制技术"><a href="#动态内容分发与复制技术" class="headerlink" title="动态内容分发与复制技术"></a>动态内容分发与复制技术</h2><ul>
<li><p>网站访问服务质量的好坏取决于多方面因素，包括网络带宽、服务器性能、网络状况是否良好等等。一般来说，主要是服务器与客户的距离会影响网站服务质量。距离过远就会导致，路由器的转发带来的网路延迟。</p>
</li>
<li><p>一个有效的方法就是利用内容分发与复制技术，<strong>将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上</strong>。用户访问时就能够直接从加速节点直接获取，而不需要再从远端的服务器上拉去，加速网络的访问质量</p>
</li>
</ul>
<h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><ul>
<li>Web缓存服务通过几种方式来改善用户的响应时间，如<strong>代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务</strong>等。通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低，直接走最近的缓存服务器；用户直接访问服务商的缓存内容就可以了，而无需访问真是的服务器</li>
</ul>
<h1 id="CDN的应用场景"><a href="#CDN的应用场景" class="headerlink" title="CDN的应用场景"></a>CDN的应用场景</h1><ul>
<li><p>CDN的核心作用是<strong>提高网络的访问速度</strong>，那么其用户也就是<strong>访问量很大的网站</strong>，例如ICP 、ISP、大型企业、电子商务网站和政府网站等</p>
</li>
<li><p>使用CDN是公司或者其他部门不再需要投资昂贵的服务器和流量的问题。而只关心内容的更新。这样可以保证用户能够去做自己的新业务，同时也能保证其业务的质量。</p>
</li>
</ul>
<h1 id="CDN的不足"><a href="#CDN的不足" class="headerlink" title="CDN的不足"></a>CDN的不足</h1><ul>
<li><p>CDN也有自己的天然的缺点那就是————实时性；由于需要远距离保持同步所以还是会存在延迟</p>
</li>
<li><p><strong>解决方案</strong>：在网络 内容发生变化时将新的网络内容从服务器端直接传送到缓存器，或者当对网络内容的访问增加时将数据源服务器的网络内容尽可能实时地复制到缓存服务器.</p>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/seanxyh/archive/2013/04/16/3023499.html" target="_blank" rel="noopener">搞定CDN</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>网络IO模型</title>
    <url>/2020/03/22/linux/netowrk-io-module/</url>
    <content><![CDATA[<ul>
<li><a href="#五类网络io模型">五类网络IO模型</a></li>
<li><a href="#io-多路复用之selectpollepoll">I/O 多路复用之select、poll、epoll</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->

</li>
</ul><h1 id="五类网络IO模型"><a href="#五类网络IO模型" class="headerlink" title="五类网络IO模型"></a>五类网络IO模型</h1><ul>
<li><h4 id="阻塞io："><a href="#阻塞io：" class="headerlink" title="阻塞io："></a><strong>阻塞io</strong>：</h4><p>  当进程发起调用后，系统没有将资源准备好，进程就会一直等待系统回复信号，等待系统将数据从硬件设备拷贝到内核空间，然后拷贝数据到用户空间，完成后系统才会返回信号；进程继续执行；此期间，该进程一直被挂起，不能做任何事情</p>
<p>  <img src="http://study.jeffqi.cn/linux/blocking_io.png" alt="blocking_io"></p>
</li>
<li><h4 id="非阻塞io："><a href="#非阻塞io：" class="headerlink" title="非阻塞io："></a><strong>非阻塞io</strong>：</h4><p>  当系统发起调用后，系统没有将资源准备好，但是会立即回复error，进程收到后知道数据没有准备好，于是会不断的询问，但是系统不会被阻塞，资源准备好后会将资源拷贝到用户空间；但会造成cpu空轮询，造成资源浪费；这时候一个进程可以处理多个连接请求；</p>
<p>  <img src="http://study.jeffqi.cn/linux/unblocking_io.png" alt="unblocking_io"></p>
</li>
<li><h4 id="io多路复用："><a href="#io多路复用：" class="headerlink" title="io多路复用："></a><strong>io多路复用</strong>：</h4><p>  进程发起调用后，会将一个fd注册过到select/poll中进程会阻塞在这个调用上；但是这一个进程可以同时处理多个连接请求，只需要经fd注册到select/poll中；不同于空轮询；io多路复用中内核会监控每一个fd的准备状态，任何一个准备好后，select/poll就会立即返回；然后轮询注册的fd，找到准备好的哪一个，然后将资源复制到用户空间；这样做避免了空轮询，但是每次都需要遍历所有的fd，找到准备好的fd，开销较大；而epoll就能避免遍历，当有fd准备好后，会直接返回这一个fd，进程直接就能知道是那个fd准备好时间复杂度为O(1)；节省了资源</p>
<p>  <img src="http://study.jeffqi.cn/linux/io_multiplexing.png" alt="io_multiplexing"></p>
</li>
<li><h4 id="信号io："><a href="#信号io：" class="headerlink" title="信号io："></a><strong>信号io</strong>：</h4><p>  调用后，系统立刻放回，不会阻塞进程；在资源准备好后，发送信号通知进程回调，将数据拷贝到用户空间</p>
</li>
<li><h4 id="异步io："><a href="#异步io：" class="headerlink" title="异步io："></a><strong>异步io</strong>：</h4><p>  发起调用后，立即返回，当资源拷贝到内核空间后，发送信号告诉进程资源已经在用户空间可以使用了</p>
<p>  <img src="http://study.jeffqi.cn/linux/async_io.png" alt="async_io"></p>
</li>
</ul><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h1 id="I-O-多路复用之select、poll、epoll"><a href="#I-O-多路复用之select、poll、epoll" class="headerlink" title="I/O 多路复用之select、poll、epoll"></a>I/O 多路复用之select、poll、epoll</h1><ul>
<li><h3 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h3><p>  select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds；调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>有点：跨平台</li>
<li>监听的数量有限1024个</li>
</ol>
</li>
<li><h3 id="poll："><a href="#poll：" class="headerlink" title="poll："></a>poll：</h3><p>  不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor \*/</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch \*/</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed \*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a>epoll:</h3><p>  epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<ol>
<li><p>三个接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="comment">// - epfd：是epoll_create()的返回值。</span></span><br><span class="line"><span class="comment">// - op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL,修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="line"><span class="comment">// - fd：是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="comment">// - epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="line">      <span class="comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span></span><br><span class="line">      <span class="comment">// EPOLLOUT：表示对应的文件描述符可以写；</span></span><br><span class="line">      <span class="comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">      <span class="comment">// EPOLLERR：表示对应的文件描述符发生错误；</span></span><br><span class="line">      <span class="comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 等待epfd上的io事件，最多返回maxevents个事件。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工作模式</p>
<ol>
<li><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
</li>
<li><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序 必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://blog.csdn.net/muyuyuzhong/article/details/83538860" target="_blank" rel="noopener">linux网络IO模型</a></li>
<li><a href="https://www.cnblogs.com/wlwl/p/10291397.html" target="_blank" rel="noopener">Linux五大网络IO模型图解</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>redis基础学习</title>
    <url>/2020/03/22/redis/redis_base/</url>
    <content><![CDATA[<ul>
<li><a href="#redis基础">redis基础</a></li>
<li><a href="#数据类型">数据类型</a><ul>
<li><a href="#string类型">string类型</a></li>
<li><a href="#hash类型">hash类型</a></li>
<li><a href="#list类型">list类型</a></li>
<li><a href="#set类型">set类型</a></li>
<li><a href="#sort-set">sort set</a></li>
<li><a href="#高级用法">高级用法</a></li>
</ul>
</li>
<li><a href="#事务">事务</a></li>
<li><a href="#持久化">持久化</a></li>
<li><a href="#redis集群">redis集群</a><ul>
<li><a href="#主从模式">主从模式</a></li>
<li><a href="#sentinel模式哨兵模式">Sentinel模式（哨兵模式）</a></li>
<li><a href="#cluster模式">cluster模式</a></li>
</ul>
</li>
<li><a href="#redis失效机制与淘汰策略">redis失效机制与淘汰策略</a><ul>
<li><a href="#被动删除">被动删除</a></li>
<li><a href="#主动删除">主动删除</a></li>
<li><a href="#淘汰策略">淘汰策略</a></li>
<li><a href="#lru淘汰ttl淘汰与随机淘汰">lru淘汰、ttl淘汰与随机淘汰</a></li>
</ul>
</li>
<li><a href="#缓存相关">缓存相关</a><ul>
<li><a href="#缓存穿透">缓存穿透</a></li>
</ul>
</li>
<li><a href="#参考文案">参考文案</a><!-- TOC END -->

</li>
</ul><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<h1 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h1><ul>
<li>基础学习</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/redis_base_knowledge.jpg" alt="redis_base_knowledge"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>String 类型是 Redis 中最常使用的类型，内部的实现是通过 SDS（Simple Dynamic String ）来存储的；类似python中内存池机制，预先申请一块内存来频繁创建释对象</p>
<p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存</p>
<p><strong>string适用范围较广</strong></p>
<ul>
<li>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</li>
<li>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</li>
<li>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</li>
</ul>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。</p>
<p>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p>
<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p>List 是有序列表，可以玩儿出很多花样。</p>
<p>比如可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>
<p>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>
<p>比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。</p>
<p>List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p>
<ul>
<li><strong>消息队列</strong>：<br>Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</li>
<li><strong>文章列表或者数据分页展示</strong>：<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率</li>
</ul>
<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p><strong>Set 是无序集合，会自动去重的那种。</strong></p>
<p>直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了；如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。</p>
<p>可以基于 Set 玩儿<strong>交集、并集、差集</strong>的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁</p>
<p>对比很快，操作也简单</p>
<h2 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h2><p>Sorted set 是排序的 Set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>
<p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。</p>
<ul>
<li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>
</li>
<li><p><strong>带权重</strong> 的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
<th>特性</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>String(字符串)</td>
<td>二进制安全</td>
<td>可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512M</td>
<td></td>
</tr>
<tr>
<td>Hash(字典)</td>
<td>键值对集合，即编程语言中的Map类型</td>
<td>适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td>存储、读取、修改用户属性</td>
</tr>
<tr>
<td>List(列表)</td>
<td>链表(双向链表)</td>
<td>增删快，提供了操作某一段元素的API</td>
<td>1，最新消息排行等功能(比如朋友圈的时间线) 2，消息队列</td>
</tr>
<tr>
<td>Set(集合)</td>
<td>哈希表实现，元素不重复</td>
<td>1，添加、删除，查找的复杂度都是O(1) 2，为集合提供了求交集、并集、差集等操作</td>
<td>1，共同好友 2，利用唯一性，统计访问网站的所有独立ip 3，好用推荐时，根据tag求交集，大于某个阈值就可以推荐</td>
</tr>
<tr>
<td>Sorted Set(有序集合)</td>
<td>将Set中的元素增加一个权重参数score，元素按score有序排列</td>
<td>数据插入集合时，已经进行天然排序</td>
<td>1，排行榜 2，带权重的消息队列</td>
</tr>
</tbody></table>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul>
<li><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）</p>
</li>
<li><h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>不精确的去重计数功能，比较适合用来做大规模数据的去重统计</p>
</li>
<li><h3 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h3><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p>
</li>
</ul>
<p>这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你有点东西。</p>
<ul>
<li><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3>功能是订阅发布功能，可以用作简单的消息队列。</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把<strong>内存中的数据集以快照形式写入磁盘</strong>，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是<strong>以文本日志的形式记录 Redis 处理的每一个写入或删除操作</strong>。</p>
<ul>
<li><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><ul>
<li><p><strong>工作原理及过程</strong>：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，<strong>先将数据集写入临时文件，写入成功后，再替换之前的文件</strong>，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。</p>
</li>
<li><p>优点：</p>
<ol>
<li>只有一个文件dump.rdb，方便持久化；</li>
<li>容灾性好，一个文件可以保存到安全的磁盘；</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化（使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) ；</li>
<li>如果数据集偏大，RDB的启动效率会比AOF更高。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>数据安全性低。（RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不是特别严格的时候）</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
</li>
</ul>
</li>
<li><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><ul>
<li><p><strong>工作原理及过程</strong>：AOF持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。<strong>Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</strong></p>
</li>
<li><p>优点：</p>
<ol>
<li>数据安全性更高，AOF持久化可以配置appendfsync属性，其中always，每一次操作做都记录到日志中</li>
<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</li>
<li>AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>AOF文件较大，数据集大是效率低；启动时顺序执行日志，速度没有RDB快</li>
<li>同步策略不同，运行的效率也会慢于RDB</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><ul>
<li><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><ol>
<li>主从模式</li>
<li>Sentinel模式</li>
<li>cluster模式</li>
</ol>
</li>
</ul>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><ul>
<li><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>  当slave启动后，主动向master发送sync命令。master接受到SYNC命令后在后台保存快照并缓存在保存快照这段时间执行的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接受到快照文件和命令后加载快照文件和缓存的执行命令。</p>
</li>
<li><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>主数据库可以进行读写操作，当读写操作导致数据变化是自动同步到从数据库</li>
<li>从数据库只读，接受同步的数据</li>
<li>一个master可以拥有多个slave，一个slave只属于一个master</li>
<li>slave挂了不影响其他slave的读和master的读写，重启后自动同步数据</li>
<li><strong>master挂了，不影响slave的读，但redis不可以再写，不会重新进行master的选举</strong></li>
</ul>
</li>
<li><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>若master挂了，则redis无法对外提供写服务</li>
</ul>
</li>
</ul>
<h2 id="Sentinel模式（哨兵模式）"><a href="#Sentinel模式（哨兵模式）" class="headerlink" title="Sentinel模式（哨兵模式）"></a>Sentinel模式（哨兵模式）</h2><ul>
<li><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><ol>
<li>每个sentinel每秒钟发送一次ping命令个master、slave、sentinel，如果距离最后一次实例回复ping命令的时间操作预先设置的down-after-milliseconds就标记实例为主观下线</li>
<li>如果一个master被标记为主管下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线</li>
<li>如果有足够多的数量（设置的数值）的sentinel确认master进入主观下线，则这台master进入客观下线</li>
<li>sentinel默认每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令。当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次</li>
<li>如果没有足够多的sentinel同意master下线，；如果master重新上线向sentinel回复ping命令，master的主观下线状态就会被移除</li>
</ol>
</li>
<li><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>sentinel模式简历在主从模式之上</li>
<li>sentinel通过选举出一个新的redis实例作为master，通知其他节点修改配置，指向新的master</li>
<li>原master重新上线只能作为slave</li>
<li>需要保证master高可用</li>
</ul>
</li>
<li><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>当数据量过大，一台master无法存放，主从模式和sentinel模式都不能满足要求</li>
</ul>
</li>
</ul>
<h2 id="cluster模式"><a href="#cluster模式" class="headerlink" title="cluster模式"></a>cluster模式</h2><p>cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。</p>
<p>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。</p>
<p>Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。</p>
<p>使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。</p>
<ul>
<li><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>多个redis实例之间网络互通，数据共享</li>
<li>所有节点都是一主一到多从，</li>
<li>支持在线扩展节点，删除节点</li>
<li>任意master节点可读写</li>
</ul>
</li>
</ul>
<h1 id="redis失效机制与淘汰策略"><a href="#redis失效机制与淘汰策略" class="headerlink" title="redis失效机制与淘汰策略"></a>redis失效机制与淘汰策略</h1><h2 id="被动删除"><a href="#被动删除" class="headerlink" title="被动删除"></a>被动删除</h2><ul>
<li>读写一个已过期的key，会触发删除操作，直接删除这个过期的key</li>
<li><h4 id="优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查"><a href="#优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查" class="headerlink" title="优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查"></a>优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查</h4></li>
<li><h4 id="缺点：内存中可能存在较多的过期的key，导致资源浪费"><a href="#缺点：内存中可能存在较多的过期的key，导致资源浪费" class="headerlink" title="缺点：内存中可能存在较多的过期的key，导致资源浪费"></a>缺点：内存中可能存在较多的过期的key，导致资源浪费</h4></li>
</ul>
<h2 id="主动删除"><a href="#主动删除" class="headerlink" title="主动删除"></a>主动删除</h2><p>被动删除会导致一些冷数据的长时间停留，所以需要使用主动删除来解决这些冷数据的key</p>
<ul>
<li><h4 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h4><p>  redis周期性执行这个清除计划，默认100ms。每次循环随机抽取20个key进行检查，如果少于25%的可以是过期的key，则清除这些冷数据key，然后停止执行任务。否则会当前一轮的检查结束后，会开启下一轮的检查。这个任务的执行时间超过了一定时间，就会被终止，防止消耗过多cpu</p>
</li>
<li><h4 id="优点：对于冷数据的key能够及时的清理，防止占用过多内存"><a href="#优点：对于冷数据的key能够及时的清理，防止占用过多内存" class="headerlink" title="优点：对于冷数据的key能够及时的清理，防止占用过多内存"></a>优点：对于冷数据的key能够及时的清理，防止占用过多内存</h4></li>
<li><h4 id="缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检"><a href="#缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检" class="headerlink" title="缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检"></a>缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检</h4></li>
</ul>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>如果失效的key没有被访问，也未被主动删除随机选中，可能就会永久存在</p>
<p>所以redis中有一个maxmemory配置，即redis最大能使用的内存，当redis的使用内存达到这个值，会根据配置的淘汰策略，对redis的key进行淘汰。</p>
<ul>
<li><h3 id="六种淘汰策略"><a href="#六种淘汰策略" class="headerlink" title="六种淘汰策略"></a>六种淘汰策略</h3></li>
</ul>
<ol>
<li><p><strong>vlatile-lru</strong>:从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。</p>
</li>
<li><p><strong>vlatile-ttl</strong>:除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。</p>
</li>
<li><p><strong>vlatile-random</strong>:从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。</p>
</li>
<li><p><strong>allkeys-lru</strong>:从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。</p>
</li>
<li><p><strong>allkeys-random</strong>:从数据集(server.db[i].dict）中选择任意数据淘汰。</p>
</li>
<li><p><strong>no-enviction</strong>:禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。</p>
</li>
</ol>
<h2 id="lru淘汰、ttl淘汰与随机淘汰"><a href="#lru淘汰、ttl淘汰与随机淘汰" class="headerlink" title="lru淘汰、ttl淘汰与随机淘汰"></a>lru淘汰、ttl淘汰与随机淘汰</h2><ul>
<li><h3 id="lru淘汰"><a href="#lru淘汰" class="headerlink" title="lru淘汰"></a>lru淘汰</h3><p>  LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>  在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除</p>
<p>  在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除</p>
</li>
<li><h3 id="ttl淘汰"><a href="#ttl淘汰" class="headerlink" title="ttl淘汰"></a>ttl淘汰</h3><p>  Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl 最大的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。</p>
</li>
<li><h3 id="随机淘汰"><a href="#随机淘汰" class="headerlink" title="随机淘汰"></a>随机淘汰</h3><p>  在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。</p>
</li>
</ul>
<h1 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li><p><strong>缓存穿透</strong>：如果我们查询一个不存在的数据，则会造成一直读取数据库，如果有人恶意攻击，则会造成数据库压力过大，甚至压垮服务器，这就是所谓的缓存穿透。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>如果查询出的数据为空，也放入redis缓存，只是缓存时间设置短一些</li>
</ol>
</li>
<li><p><strong>缓存雪崩</strong>：redis缓存放入大量key，然后某个时间点缓存集中过期失效。此刻就会造成大量的请求过来都会去同时查询数据库，而不走redis缓存，数据库压力陡增，在秒杀，双11等场景下，很容易压垮服务器。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期.</li>
</ol>
</li>
<li><p><strong>缓存击穿</strong>：在某些特殊节点,一个热点数据被频繁访问,在失效的瞬间就会有大量的请求进来,导致部分越过缓存去读取数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>双重校验（Dubbo Check）类似线程安全的懒汉单例模式实现，保证只会有一个线程去访问数据库。</li>
</ol>
</li>
</ul>
<h1 id="参考文案"><a href="#参考文案" class="headerlink" title="参考文案"></a>参考文案</h1><ul>
<li><a href="https://www.jianshu.com/p/b1b4eeccc140" target="_blank" rel="noopener">redis淘汰机制</a></li>
<li><a href="https://www.cnblogs.com/vieta/p/11192137.html" target="_blank" rel="noopener">redis配置</a></li>
<li><a href="https://www.cnblogs.com/happydreamzjl/p/11322937.html" target="_blank" rel="noopener">redis哨兵机制</a></li>
<li><a href="https://www.cnblogs.com/llaq/p/9470055.html" target="_blank" rel="noopener">redis缓存</a></li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>python内存管理机制</title>
    <url>/2020/03/21/python/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<ul>
<li><a href="#内存管理和垃圾回收机制">内存管理和垃圾回收机制</a><ul>
<li><a href="#内存管理">内存管理</a></li>
<li><a href="#垃圾回收机制">垃圾回收机制</a><ul>
<li><a href="#引用计数">引用计数</a></li>
<li><a href="#标记清除">标记清除</a></li>
<li><a href="#分代回收">分代回收</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->

</li>
</ul><h1 id="内存管理和垃圾回收机制"><a href="#内存管理和垃圾回收机制" class="headerlink" title="内存管理和垃圾回收机制"></a>内存管理和垃圾回收机制</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol>
<li>Python 中一切皆对象，对象又可以分为可变对象和不可变对象。二者可以通过原地修改，如果修改后地址不变，则是可变对象，否则为不可变对象，地址信息可以通过id()进行查看<br><img src="http://study.jeffqi.cn/python/python_changeable_and_unchangeable_object.jpg" alt="python可变对象与不可变对象"></li>
<li>python有内存池机制，pymalloc机制来对内存进行申请和释放内存；当创建小的对象是，如果频繁使用c中的new/malloc会导致大量内存碎片，导致效率下降；所有python中使用内存池机制来解决这个问题；内存池先申请一块内存空间，然后分割成等大小的块数；有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<strong>Pymalloc会在内存池中申请空间，一般是少于256kb，如果是大的对象，则直接调用 new/malloc 来申请新的内存空间</strong></li>
</ol><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul>
<li>Python 采用 GC 作为自动内存管理机制，GC要做的有2件事，<strong>一是找到内存中无用的垃圾对象资源，二是清除找到的这些垃圾对象，释放内存给其他对象使用</strong></li>
<li>引用计数</li>
<li>标记清除</li>
<li>分代回收</li>
<li>引用计数为主，其余两种为辅助回收机制</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ol>
<li><p>查看源码，每一个对象，在源码里就是一个结构体表示，都会有一个计数字段.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">  <span class="keyword">int</span> ob_refcnt;    <span class="comment">//计数</span></span><br><span class="line">  struct_typeobject \*ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。</p>
</li>
</ol>
<ul>
<li>优点<ol>
<li>简单</li>
<li>实时性强，能够实时的无用的对象的内存进行释放</li>
</ol>
</li>
<li>缺点<ol>
<li>需要维护一个计数，占用额外的空间</li>
<li>循环引用：两个对象相互引用，且没有任何外部引用</li>
</ol>
</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ol>
<li>为了解决循环引用带来的可能导致内存泄露的问题</li>
<li><strong>第一阶段是标记阶段</strong>，GC会把所有的 活动对象 打上标记</li>
<li><strong>第二阶段是清除阶段</strong>，把那些没有标记的对象 非活动对象 进行回收</li>
<li>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。<br><img src="http://study.jeffqi.cn/python/mark-gc.jpg" alt="标记清除"></li>
<li>如上图中，1、2、3是可到达的，而4、5就是不可到达的需要被清理掉</li>
<li>标记清除主要是用来处理python中的容器对象如list、dict等；Python使用一个双向链表将这些容器对象组织起来</li>
<li>清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象</li>
</ol>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ol>
<li>在python中没创建一个对象，就将对象放到一个链表中，如果有引用计数就加一；从而构成一个双向链表；这个链表就是零代链表；<br><img src="http://study.jeffqi.cn/python/gc-generator-1.png" alt="分代回收1"><br><img src="http://study.jeffqi.cn/python/gc-generator-2.png" alt="分代回收2"></li>
<li>检测循环引用：python会遍历零代链表，给每个计数减一，将计数为零的对象的内存释放掉；活着的对象进入下一代链表（一代链表）<br><img src="http://study.jeffqi.cn/python/gc-generator-3.png" alt="分代回收3"><br><img src="http://study.jeffqi.cn/python/gc-generator-4.png" alt="分代回收4"></li>
<li>弱代假说：在零代链表中的对象python默认会认为他们会很快更新，比如创建了一个临时对象；而经过一次筛选后的对象，python会认为他们会被经常使用到；同理在二代链表中也是如此；由于循环引用，导致分配计数和释放计数的比值越来越大，当到达一个阈值后，会触发收集器执行清理操作，对所有对象引用计数减一然后回收为零的对象，添加非零对象到下一代链表中；在下一代链表中也存在这一个阈值，不过python会认为下一代的使用时间更久，所以这个阈值会更大。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/fb1d4dc8e367" target="_blank" rel="noopener">https://www.jianshu.com/p/fb1d4dc8e367</a></li>
<li><a href="https://www.jianshu.com/p/1e375fb40506" target="_blank" rel="noopener">https://www.jianshu.com/p/1e375fb40506</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>上下文切换</title>
    <url>/2020/03/20/linux/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<ul>
<li><a href="#上下文切换">上下文切换</a><ul>
<li><a href="#进程上下文切换">进程上下文切换</a></li>
<li><a href="#线程上下文切换">线程上下文切换</a></li>
<li><a href="#中断上下文切换">中断上下文切换</a></li>
<li><a href="#案例分析">案例分析</a><!-- TOC END -->

</li>
</ul>
</li>
</ul><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><ol>
<li>CPU 寄存器：CPU 内置的容量小、但速度极快的内存</li>
<li>程序计数器：用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置</li>
<li>CPU寄存器和程序计数器是运行任何任务的前提，必须依赖的环境也称为CPU上下文</li>
<li>上下文切换类型<ol>
<li>进程上下文切换</li>
<li>线程上下文切换</li>
<li>中断上下文切换</li>
</ol>
</li>
</ol><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><ol>
<li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li>
<li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。<br><img src="http://study.jeffqi.cn/linux/linux-source-space.png" alt></li>
<li>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过系统调用来完成；<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换；系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong><ol>
<li>进程上下文切换是在不同进程之间</li>
<li>系统调用只在一个进程中</li>
<li><strong>系统调用过程通常称为特权模式切换，而不是上下文切换；但是也不可避免CPU的上下文切换</strong></li>
</ol>
</li>
<li><strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>；进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</li>
<li>进程切换场景<ol>
<li>时间片轮转结束，或进程执行完成</li>
<li>调用sleep函数</li>
<li>等待系统资源</li>
<li>更高优先级进程抢占</li>
<li>硬件中断</li>
</ol>
</li>
</ol>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><ol>
<li>线程属于不同的进程，与进程上下文切换一致</li>
<li>当进程拥有多个线程时，这些线程会<strong>共享</strong>相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li>
<li><strong>线程也有自己的私有数据</strong>，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li>
</ol>
<h2 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h2><ol>
<li>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong></li>
<li><strong>终端上下文不涉及用户空间</strong>；中断过程打断了一个正处在用户态的进程，不会保存和恢复用户空间的虚拟内存、全局变量等；只包含内核空间的栈、CPU寄存器等</li>
<li>中断处理比进程拥有更高的优先级；中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能</li>
</ol>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ol>
<li>使用vmstat查看内存使用情况;vmstat 只给出了系统总体的上下文切换情况<br><img src="http://study.jeffqi.cn/linux/vmstat.jpg" alt="vmstat"></li>
<li>pid查看进程详细情况；-w 选项，你就可以查看每个进程上下文切换的情况；<br><img src="http://study.jeffqi.cn/linux/pidstat_w.jpg" alt="pidstat_w"></li>
<li>上图中：cswch，表示每秒<strong>自愿</strong>上下文切换（voluntary context switches）的次数； nvcswch ，表示每秒<strong>非自愿</strong>上下文切换（non voluntary context switches）的次数<ol>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li>
<li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换</li>
</ol>
</li>
<li><strong>实验</strong></li>
<li>sysbench：是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况；sysstat<br><img src="http://study.jeffqi.cn/linux/sysbench_threads=5.jpg" alt="sysbench_threads=5"></li>
<li>vmstat查看实验前上下文切换情况；对比上面实验前的结果；r、in、cs、us、sy参数激增<br><img src="http://study.jeffqi.cn/linux/vmstat_sysbench.jpg" alt="vmstat_sysbench"></li>
<li>pidstat查看进程线程的上下文切换情况；sysbench基于多线程工作模式，需要使用-t参数查看<br><img src="http://study.jeffqi.cn/linux/pidstat_w_u_sysbench.jpg" alt="pidstat_w_u_sysbench"><br><img src="http://study.jeffqi.cn/linux/pidstat_w_t_sysbench.jpg" alt="pidstat_w_t_sysbench"></li>
<li>查看中断上下文切换通过查看/proc/interrupt文件（<strong>单核服务器中看不出变化，需要在多核服务器上RES明显变化</strong>）<br><img src="http://study.jeffqi.cn/linux/cat_proc_interrupts.jpg" alt="cat_proc_interrupt"><br><img src="http://study.jeffqi.cn/linux/cat_proc_interrupts_mulits.jpg" alt="cat_proc_interrupt_mulit"><ol>
<li>重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断</li>
</ol>
</li>
<li>总结<ol>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2020/03/20/python/python_base/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#文件操作">文件操作</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#命名空间和作用域">命名空间和作用域</a></li>
<li><a href="#函数-1">函数</a></li>
<li><a href="#装饰器">装饰器</a></li>
<li><a href="#迭代器生成器">迭代器生成器</a></li>
<li><a href="#推导式">推导式</a></li>
<li><a href="#内置函数和匿名函数">内置函数和匿名函数</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol>
<li><p>打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. 打开文件，得到文件句柄并赋值给一个变量</span></span><br><span class="line">f=open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="comment">#默认打开模式就为r</span></span><br><span class="line"><span class="comment">#2. 通过句柄对文件进行操作</span></span><br><span class="line">data=f.read()</span><br><span class="line"><span class="comment">#3. 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> read_f,open(<span class="string">'b.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">  data=read_f.read()</span><br><span class="line">  write_f.write(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件打开模式和编码</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>字符</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读模式【默认模式，文件必须存在，不存在则抛出异常】</td>
</tr>
<tr>
<td>w</td>
<td>只写模式【不可读；不存在则创建；存在则清空内容】</td>
</tr>
<tr>
<td>a</td>
<td>只追加写模式【不可读；不存在则创建；存在则只追加内容】</td>
</tr>
<tr>
<td>*b</td>
<td>r、w、a + b 使用二进制方式打开</td>
</tr>
<tr>
<td>r+</td>
<td>读写【可读，可写】覆盖写</td>
</tr>
<tr>
<td>w+</td>
<td>写读【可写，可读】覆盖写</td>
</tr>
<tr>
<td>a+</td>
<td>写读【可写，可读】追加写</td>
</tr>
<tr>
<td>r+b</td>
<td>读写【可读，可写】</td>
</tr>
<tr>
<td>w+b</td>
<td>写读【可写，可读】</td>
</tr>
<tr>
<td>a+b</td>
<td>写读【可写，可读】</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>文件输入与输出</p>
<ol>
<li><p>输出</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f.read(size)：读多少字节，默认为一次性读完</span><br><span class="line">f.readline()：读一行，默认为‘\n’符号</span><br><span class="line">f.readlines()：读所有行，符号为 \n</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f.write(<span class="string">'xxxx'</span>)：写入</span><br></pre></td></tr></table></figure>
</li>
<li><p>f.tell()：返回当前文件指正</p>
</li>
<li><p>f.seek()：如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seek(x,<span class="number">0</span>) ： 从起始位置即文件首行首字符开始移动 x 个字符</span><br><span class="line">seek(x,<span class="number">1</span>) ： 表示从当前位置往后移动x个字符</span><br><span class="line">seek(-x,<span class="number">2</span>)：表示从文件的结尾往前移动x个字符</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li><p>return关键字的作用</p>
<ol>
<li>return 是一个关键字，这个词翻译过来就是“返回”，所以我们管写在return后面的值叫“返回值”。</li>
<li>不写return的情况下，会默认返回一个None</li>
<li>一旦遇到return，结束整个函数。</li>
<li>返回的多个值会被组织成元组被返回，也可以用多个值来接收</li>
</ol>
</li>
<li><p>函数的参数</p>
<ol>
<li><p>按照位置传值：位置参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span>   </span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数：在调用函数时，按照key=value的形式定义的实参，称为关键字参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">fun(x=<span class="number">1</span>,y=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置、关键字形式混着用：混合传参；结合上面两种</p>
<ol>
<li><strong>位置参数必须在关键字参数的前面<br>对于一个形参只能赋值一次</strong></li>
</ol>
</li>
<li><p>默认参数:<strong>默认参数是一个可变数据类型</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(x=<span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname()</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态参数：动态参数，也叫不定长传参，就是你需要传给函数的参数很多，<strong>不定个数</strong>，那这种情况下，你就用<em>args，*</em>kwargs接收，<strong>args是元祖形式</strong>，接收除去键值对以外的所有参数，<strong>kwargs接收的只是键值对的参数</strong>，并保存在字典中</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(*arg, **kwargs)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname(<span class="string">'aaron'</span>,<span class="number">1</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],&#123;<span class="string">'a'</span>:<span class="number">123</span>,<span class="string">'b'</span>:<span class="number">321</span>&#125;,country=<span class="string">'china'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>形参、实参：</p>
<ol>
<li>形参：定义函数时的参数</li>
<li>实参：调用函数时的参数</li>
<li>根据实际参数类型不同，将实际参数传递给形参的方式有两种：值传递和引用传递<ol>
<li>值传递：实参为不可变对象，传递给形参后，形参的值改变，实参值不变。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li>引用传递：实参为可变对象，传递给形参后，形参的值改变，实参值改变。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ol>
</li>
</ol>
</li>
<li><p>形式参数前加 * 号表示可变长参数，实参前加 * 号表示解包，将list或者tuple内的元素提取出来</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, *args)</span>:</span></span><br><span class="line">  print(<span class="string">'a:%s'</span> % a)</span><br><span class="line">  print(<span class="string">'args:'</span>, end=<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">      print(i, end=<span class="string">' '</span>)</span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">fun(*li)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">a:<span class="number">1</span></span><br><span class="line">args: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h1><ol>
<li><p>创建的存储“变量名与值的关系”的空间叫做全局命名空间；在函数的运行中开辟的临时的空间叫做局部命名空间</p>
</li>
<li><p>类型：</p>
<ol>
<li>全局</li>
<li>局部</li>
<li>内置</li>
</ol>
</li>
<li><p>调用顺序</p>
<ol>
<li>局部调用：局部&gt;全局&gt;内置</li>
<li>全局调用：全局&gt;内置</li>
</ol>
</li>
<li><p>作用域</p>
<ol>
<li>全局作用域：包含内置名称空间、全局名称空间，在整个文件的任意位置都能被引用、全局有效</li>
<li>局部作用域：局部名称空间，只能在局部范围内生效</li>
</ol>
</li>
<li><p>globals和locals方法</p>
<ol>
<li><p>global</p>
<ol>
<li>声明一个全局变量。</li>
<li>在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字)。可变数据类型可以直接引用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> a</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">func()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count = <span class="number">2</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">search()</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>local</p>
<ol>
<li>不能修改全局变量</li>
<li>在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_b</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span><span class="params">()</span>:</span></span><br><span class="line">        b = <span class="number">10</span></span><br><span class="line">        print(b)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dd_nolocal</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> b <span class="comment"># 父级改变</span></span><br><span class="line">            b = b + <span class="number">20</span></span><br><span class="line">            print(b)</span><br><span class="line">        dd_nolocal()</span><br><span class="line">        print(b)</span><br><span class="line">    do_global()</span><br><span class="line">    print(b)</span><br><span class="line">add_b()</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数名本质上就是函数的内存地址；可以被引用；可以当做容器元素存在如list中；可以作为返回值</li>
<li>闭包：内层函数对于外层函数定义的变量的调用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">()</span>:</span></span><br><span class="line">  name = <span class="string">'hjq'</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">  print(inner.__closure__)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ol>
<li><p>让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景</p>
</li>
<li><p>函数可以作为参数传递给另一个函数，但是使用比较麻烦；使用装饰器更加简便</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure>
</li>
<li><p>加上装饰器后函数的信息就失效了，可以使用 @wrap(fun_name) 装饰器保留原函数的信息</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开放封闭原则</strong></p>
<ol>
<li>开放封闭原则的核心的思想是软件实体是可扩展，而不可修改的。<ol>
<li>对扩展是开放的</li>
<li>对修改是封闭的</li>
</ol>
</li>
</ol>
</li>
<li><p>多个装饰器</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'第一个装饰器，在程序运行之前'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'第一个装饰器，在程序运行之后'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'第二个装饰器，在程序运行之前'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'第二个装饰器，在程序运行之后'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="meta">@wrapper1</span></span><br><span class="line"><span class="meta">@wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">f()</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">第一个装饰器，在程序运行之前</span><br><span class="line">第二个装饰器，在程序运行之前</span><br><span class="line">Hello</span><br><span class="line">第二个装饰器，在程序运行之后</span><br><span class="line">第一个装饰器，在程序运行之后</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="迭代器生成器"><a href="#迭代器生成器" class="headerlink" title="迭代器生成器"></a>迭代器生成器</h1><ol>
<li>可迭代对象：可以使用for循环遍历的对象</li>
<li>可迭代协议：可以被迭代要满足的要求就叫做可迭代协议。可迭代协议的定义非常简单，就是内部实现了iter方法来返回一个迭代器对象</li>
<li>迭代器：内部实现了iter方法和next方法；迭代器惰性计算，同一时刻在内存中只出现一条数据，极大限度的节省了内存；只有在需要时才会生成</li>
<li>for循环遍历可迭代对象<ol>
<li>将可迭代对象转化成迭代器。（可迭代对象.iter()）</li>
<li>内部使用next方法，一个一个取值。</li>
<li>加了异常处理功能，取值到底后自动停止。</li>
</ol>
</li>
<li>生成器：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行</li>
<li>生成器协议：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表</li>
</ol>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;k.lower():dic1.get(k.lower(),<span class="number">0</span>) + dic1.get(k.upper(),<span class="number">0</span>) <span class="keyword">for</span> k <span class="keyword">in</span> dic1.keys()&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置函数和匿名函数"><a href="#内置函数和匿名函数" class="headerlink" title="内置函数和匿名函数"></a>内置函数和匿名函数</h1><ol>
<li><p>作用域相关</p>
<ul>
<li>locals():函数会以字典的类型返回当前位置的全部局部变量</li>
<li>globals():：函数以字典的类型返回全部全局变量</li>
</ul>
</li>
<li><p>字符串类型代码的执行 eval，exec，complie</p>
<ul>
<li><p>eval：执行字符串代码返回结果；只能执行一行代码</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ret = eval(<span class="string">'2 + 2'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec：执行字符串代码；可以执行多行代码，但是拿不到结果</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'''</span></span><br><span class="line"><span class="string">for i in range(5):</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">exec(s</span><br></pre></td></tr></table></figure>
</li>
<li><p>complie：:将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值</p>
<ol>
<li>数source：字符串。即需要动态执行的代码段。</li>
<li>参数 filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。当传入了source参数时，filename参数传入空字符即可。</li>
<li>参数model：指定编译代码的种类，可以指定为 ‘exec’,’eval’,’single’。<strong>当source中包含流程语句时，model应指定为‘exec’；当source中只包含一个简单的求值表达式，model应指定为‘eval’；当source中包含了交互式命令语句，model应指定为’single’</strong><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"for i in range(0,10): print(i)"</span></span><br><span class="line">c = compile(str,<span class="string">''</span>,<span class="string">'exec'</span>)</span><br><span class="line">exec(c)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>输入输出</p>
<ul>
<li>input():函数接受一个标准输入数据，返回为 string 类型</li>
<li>print():标准输出</li>
</ul>
</li>
<li><p>内存相关</p>
<ul>
<li>hash()：获取对象（可哈希对象：int，str，Bool，tuple）的hash值</li>
<li>id()：获取内存地址</li>
</ul>
</li>
<li><p>文件操作相关</p>
<ul>
<li>open()：函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写</li>
</ul>
</li>
<li><p>调用相关</p>
<ul>
<li>callable：函数用于检查一个对象是否是可调用  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">print(callable(demo1))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>内置属性</p>
<ul>
<li>dir()：函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法</li>
</ul>
</li>
<li><p>迭代器生成器相关</p>
<ul>
<li>range：函数可创建一个整数对象，一般用在 for 循环中。</li>
<li>next：内部实际使用了<strong>next</strong>方法，返回迭代器的下一个项目</li>
</ul>
</li>
<li><p>基础数据类型</p>
<ul>
<li>bool ：用于将给定参数转换为布尔类型，如果没有参数，返回 False。</li>
<li>int：函数用于将一个字符串或数字转换为整型。</li>
<li>float：函数用于将整数和字符串转换成浮点数。</li>
<li>complex：函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。。</li>
</ul>
</li>
<li><p>进制转换</p>
<ul>
<li>bin：将十进制转换成二进制并返回。</li>
<li>oct：将十进制转化成八进制字符串并返回。</li>
<li>hex：将十进制转化成十六进制字符串并返回。</li>
</ul>
</li>
<li><p>数学运算</p>
<ul>
<li>abs：函数返回数字的绝对值。</li>
<li>divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。</li>
<li>round：保留浮点数的小数位数，默认保留整数。</li>
<li>pow：函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z）</li>
<li>sum：对可迭代对象进行求和计算（可设置初始值）。</li>
<li>min：返回可迭代对象的最小值（可加key，key为函数名，通过函数的规则，返回最小值）。</li>
<li>max：返回可迭代对象的最大值（可加key，key为函数名，通过函数的规则，返回最大值）</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>list()：将一个可迭代对象转化成列表（如果是字典，默认将key作为列表的元素）。</li>
<li>tuple()：将一个可迭代对象转化成元祖（如果是字典，默认将key作为元祖的元素）。</li>
<li>dict()：创建一个字典。</li>
<li>set()：创建一个集合。</li>
<li>frozenset()：返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</li>
</ul>
</li>
<li><p>内置函数</p>
<ul>
<li><p>reversed()：翻转一个列表生成<strong>迭代器</strong></p>
</li>
<li><p>str()：将数据转化成字符串。</p>
</li>
<li><p>bytes():用于不同编码之间转换</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'你好'</span></span><br><span class="line">bs = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">s1 = bs.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(s1)</span><br><span class="line">bs = bytes(s, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">b = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line">b1 = b.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(b1.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>len():返回一个对象中元素的个数。</p>
</li>
<li><p>sorted()：对所有可迭代的对象进行排序操作</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(sorted(l, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)) <span class="comment"># 降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()：用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">ret = filter(func,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>匿名函数</p>
<ul>
<li>为了解决那些功能很简单的需求而设计的一句话函数</li>
<li>函数名 = lambda 参数 ：返回值<ol>
<li>参数可以有多个，用逗号隔开</li>
<li>匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值</li>
<li>返回值和正常的函数一样可以是任意数据类型<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">999</span>,<span class="number">213</span>,<span class="number">1111</span>,<span class="number">31121</span>,<span class="number">333</span>]</span><br><span class="line">print(max(l))</span><br><span class="line">dic=&#123;<span class="string">'k1'</span>:<span class="number">10</span>,<span class="string">'k2'</span>:<span class="number">100</span>,<span class="string">'k3'</span>:<span class="number">30</span>&#125;</span><br><span class="line">print(max(dic))</span><br><span class="line">print(dic[max(dic,key=<span class="keyword">lambda</span> k:dic[k])])</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h1><ol>
<li><p>什么是模块</p>
<ul>
<li>使用python编写的代码（.py文件）</li>
<li>已被编译为共享库或DLL的C或C++扩展</li>
<li>包好一组模块的包</li>
<li>使用C编写并链接到python解释器的内置模块</li>
</ul>
</li>
<li><p>为什么要使用模块</p>
<ol>
<li>实现代码和功能的复用性</li>
</ol>
</li>
<li><p>import module_name</p>
<ul>
<li>模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，<strong>它们只在模块名第一次遇到导入import语句时才执行</strong></li>
<li>第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句</li>
</ul>
</li>
<li><p>import时做的事情</p>
<ol>
<li>为模块创建新的命名空间</li>
<li>在新的命名空间中执行模块中的代码函数</li>
<li><strong>创建名字来引用这个命名空间</strong></li>
</ol>
</li>
<li><p>from import</p>
<ul>
<li>from 语句相当于import，也会创建新的名称空间，<strong>但是将my_module中的名字直接导入到当前的名称空间中</strong>，在当前名称空间中，直接使用名字就可以了</li>
<li>from my_module import * 把<strong>my_module中所有的不是以下划线(_)开头的名字都导入到当前位置</strong>，这样做可能造成覆盖掉你之前的定义的名字</li>
<li>想从包api中导入所有，实际上该语句只会导入包api下<strong>init</strong>.py文件中定义的名字，我们可以在这个文件中定义<strong>all</strong>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'from api.__init.py'</span>)</span><br><span class="line">__all__=[<span class="string">'x'</span>,<span class="string">'func'</span>,<span class="string">'policy'</span>]</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>模块搜索路径</p>
<ol>
<li>内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块</li>
</ol>
</li>
<li><p>编译python文件</p>
<ul>
<li>为了提高加载模块的速度，python解释器会在<strong>pycache</strong>目录中下缓存每个模块编译后的版本</li>
</ul>
</li>
<li><p>绝对导入和相对导入</p>
<ol>
<li>绝对导入<ol>
<li>优点：执行文件与被导入的模块中都可以使用</li>
<li>缺点：比较麻烦写入路径名称</li>
</ol>
</li>
<li>相对导入<ol>
<li>优点：方便</li>
<li>缺点：只能在导入包中的模块时才能使用</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="常用的模块"><a href="#常用的模块" class="headerlink" title="常用的模块"></a>常用的模块</h1><h2 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h2><ol>
<li>Json模块提供了四个功能：dumps、dump、loads、load</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ensure_ascii</td>
<td>当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可，此时存入json的中文即可正常显示。</td>
</tr>
<tr>
<td>separators</td>
<td>分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">data = &#123;<span class="string">'name'</span>:<span class="string">'陈松'</span>,<span class="string">'sex'</span>:<span class="string">'female'</span>,<span class="string">'age'</span>:<span class="number">88</span>&#125;</span><br><span class="line">json_dic2 = json.dumps(data,sort_keys=<span class="literal">True</span>,indent=<span class="number">2</span>,separators=(<span class="string">','</span>,<span class="string">':'</span>),ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">print(json_dic2)</span><br></pre></td></tr></table></figure>

<h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h2><ol>
<li><p>pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load<br>不仅可以序列化字典，列表…可以把python中任意的数据类型序列化</p>
</li>
<li><p>区别</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>模块</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>json</td>
<td>用于字符串 和 python数据类型间进行转换</td>
</tr>
<tr>
<td>pickle</td>
<td>用于python特有的类型 和 python的数据类型间进行转换</td>
</tr>
</tbody></table>
<h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h2><ol>
<li>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">'how to use md5 in python hashlib?'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># md5.update('how to use md5 in python hashlib?'.encode('utf-8')) # 多次调用</span></span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果数据大，可以分块多次调用update()，最后计算的结果是一样的</li>
</ol>
<h2 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h2><ol>
<li>日志等级<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  <span class="comment"># （默认）</span></span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                    filename=<span class="string">'test.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'w'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logging.error(<span class="string">'error message'</span>)</span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>解释</p>
<ol>
<li>logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：</li>
<li>filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。</li>
<li>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</li>
<li>format：指定handler使用的日志显示格式。</li>
<li>datefmt：指定日期时间格式。</li>
<li>level：设置rootlogger（后边会讲解具体概念）的日志级别</li>
<li>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open- (‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</li>
<li>format参数中可能用到的格式化串：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “<span class="number">2003</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">49</span>:<span class="number">45</span>,<span class="number">896</span>”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s用户输出的消息</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>logger对象设置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"><span class="comment"># 创建一个handler，用于写入日志文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'test.log'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 再创建一个handler，用于输出到控制台</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line">logger.addHandler(fh) <span class="comment">#logger对象可以添加多个fh和ch对象</span></span><br><span class="line">logger.addHandler(ch)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h2><ol>
<li><p>在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等</p>
<ol>
<li>namedtuple: 生成可以使用名字来访问元素内容的tuple</li>
<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>
<li>Counter: 计数器，主要用来计数</li>
<li>OrderedDict: 有序字典</li>
<li>defaultdict: 带有默认值的字典</li>
</ol>
</li>
<li><p>namedtuple</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">point = namedtuple(<span class="string">'point'</span>,[<span class="string">'x'</span>,<span class="string">'y'</span>])</span><br><span class="line">p = point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(p.x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>deque</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">q = deque([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">q.append(<span class="string">'x'</span>)</span><br><span class="line">q.appendleft(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OrderedDict</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = dict([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>),(<span class="string">'c'</span>,<span class="number">3</span>)])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">od = OrderedDict([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>),(<span class="string">'c'</span>,<span class="number">3</span>)])</span><br><span class="line">print(od)</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultdict</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line">result=defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> row &gt; <span class="number">66</span>:</span><br><span class="line">        result[<span class="string">'key1'</span>].append(row)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[<span class="string">'key2'</span>].append(row)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>counter</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="string">'qazxswqazxswqazxswsxaqwsxaqws'</span>)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><ol>
<li>time.sleep(secs)：(线程)推迟指定的时间运行。单位为秒。</li>
<li>time.time()：获取当前时间戳</li>
<li>格式：时间戳、元祖、格式化显示</li>
</ol>
<table>
<thead>
<tr>
<th>格式化</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>%y</td>
<td>两位数的年份表示（00-99）</td>
</tr>
<tr>
<td>%Y</td>
<td>四位数的年份表示（000-9999）</td>
</tr>
<tr>
<td>%m</td>
<td>月份（01-12）</td>
</tr>
<tr>
<td>%d</td>
<td>月内中的一天（0-31）</td>
</tr>
<tr>
<td>%H</td>
<td>24小时制小时数（0-23）</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制小时数（01-12）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟数（00=59）</td>
</tr>
<tr>
<td>%S</td>
<td>秒（00-59）</td>
</tr>
</tbody></table>
<ol start="4">
<li>时间转换<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化时间 ----&gt;  结构化时间</span></span><br><span class="line">ft = time.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br><span class="line">st = time.strptime(ft,<span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br><span class="line">print(st)</span><br><span class="line"><span class="comment"># 结构化时间 ---&gt; 时间戳</span></span><br><span class="line">t = time.mktime(st)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 ----&gt; 结构化时间</span></span><br><span class="line">t = time.time()</span><br><span class="line">st = time.localtime(t)</span><br><span class="line">print(st)</span><br><span class="line"><span class="comment"># 结构化时间 ---&gt; 格式化时间</span></span><br><span class="line">ft = time.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>,st)</span><br><span class="line">print(ft)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><ol>
<li>随机模块<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">random.randint(m, n)：m、n之间的随机数</span><br><span class="line">random.randrange(m, n, s)：m、n之间的随机数，步长s</span><br><span class="line">random.choice(argv)：从argv中随机选择其中的数据</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><ol>
<li>os模块是与操作系统交互的一个接口</li>
</ol>
<h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><ol>
<li>sys模块是与python解释器交互的一个接口</li>
</ol>
<h2 id="re正则模块"><a href="#re正则模块" class="headerlink" title="re正则模块"></a>re正则模块</h2><ol>
<li>re.match(pattern, string, flags=0)：re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</li>
<li>re.search(pattern, string, flags=0)：扫描整个字符串并返回第一个成功的匹配</li>
<li>findall(string[, pos[, endpos]])：在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表；<strong>match 和 search 是匹配一次 findall 匹配所有。</strong></li>
</ol>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ol>
<li><p>为每一种异常定制了一个类型，然后提供了一种特定的语法结构用来进行异常处理</p>
</li>
<li><p>基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型：</span><br><span class="line">     执行的操作</span><br><span class="line"><span class="comment">#try中一旦检测到异常，就执行这个位置的逻辑</span></span><br><span class="line"><span class="comment">## 多分支，通用异常，else方法，finally</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    int(s1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 通用异常捕获</span></span><br><span class="line">   print(e)</span><br><span class="line"><span class="keyword">else</span>:   <span class="comment"># try 正常执行时，跳转到这个</span></span><br><span class="line">    print(<span class="string">'try内代码块没有异常则执行我'</span>)</span><br><span class="line"><span class="keyword">finally</span>:  <span class="comment"># 无论如何都会运行</span></span><br><span class="line">    print(<span class="string">'无论异常与否,都会执行该模块,通常是进行清理工作'</span>)</span><br><span class="line"><span class="comment">## 主动抛出异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'类型错误'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常操作的优点</p>
<ol>
<li>把错误处理和真正的工作分开来</li>
<li>代码更易组织，更清晰，复杂的工作任务更容易实现</li>
<li>毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了</li>
</ol>
</li>
</ol>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><ol>
<li><p>面向对象编程的优点</p>
<ol>
<li>少代码的重用性。</li>
<li>增强代码的可读性。</li>
</ol>
</li>
<li><p>构造</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""docstring for ."""</span></span><br><span class="line">  var = <span class="string">'string'</span>  <span class="comment"># 静态变量，静态属性</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span>  <span class="comment"># 方法、函数、动态属性</span></span><br><span class="line">    super(, self).__init__()</span><br><span class="line">    self.arg = arg</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<ol>
<li>在内存中开辟了一个对象空间。</li>
<li>自动执行类中的init方法，并将这个对象空间（内存地址）传给了init方法的第一个位置参数self。</li>
<li>在init 方法中通过self给对象空间添加属性。</li>
</ol>
</li>
<li><p>操作和类中的属性：通过万能的点 . 进行操作；查看对象和类中的所有内容可以通过 <strong>dic</strong> 来查看</p>
</li>
<li><p>类中的方法都会有一个self参数。因为一般情况下这些方法都是通过对象来执行的。在执行的时候将对象的地址空间传给第一个参数，这个self就是对象本省</p>
</li>
</ol>
<h1 id="类空间问题以及类之间的关系"><a href="#类空间问题以及类之间的关系" class="headerlink" title="类空间问题以及类之间的关系"></a>类空间问题以及类之间的关系</h1><ol>
<li><p>类和对象都可以在内外部添加</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self, sex)</span>:</span></span><br><span class="line">    self.sex = sex</span><br><span class="line">A.age = <span class="string">'12'</span>  <span class="comment"># 类内部</span></span><br><span class="line">A.func(<span class="string">'男'</span>) <span class="comment"># 类外部</span></span><br><span class="line">a = A(<span class="string">'margin'</span>) <span class="comment"># 对象</span></span><br><span class="line">a.age = <span class="string">'20'</span>  <span class="comment"># 对象内部</span></span><br><span class="line">a.func(<span class="string">'女'</span>) <span class="comment"># 对象外部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何找到属性</p>
<ol>
<li>对象空间<ol>
<li>产生这个对象空间，并有一个类对象指针</li>
<li>执行<strong>init</strong>方法，给对象封装属性</li>
</ol>
</li>
<li>对象查找属性的顺序：先从对象空间找 ——&gt; 类空间找 ——&gt; 父类空间找 ——-&gt;…</li>
<li>类名查找属性的顺序：先从本类空间找 ——-&gt; 父类空间找——–&gt; …</li>
</ol>
</li>
<li><p>类之间关系</p>
<ol>
<li>依赖关系<ol>
<li>将大象装进冰箱，需要大象类和冰箱类相互依赖</li>
</ol>
</li>
<li>关联关系、组合关系、聚合关系<ol>
<li>关联关系. 两种事物必须是互相关联的. 但是在某些特殊情况下是<strong>可以更改和更换的</strong></li>
<li>聚合关系. 属于关联关系中的⼀种特例. <strong>侧重点是xxx和xxx聚合成xxx. 各⾃有各⾃的声明周期</strong>. 比如电脑. 电脑⾥有CPU, 硬盘, 内存等等. 电脑挂了. CPU还是好的. 还是完整的个体</li>
<li>组合关系. 属于关联关系中的⼀种特例. 写法上差不多. <strong>组合关系比聚合还要紧密</strong>. 比如⼈的⼤脑, ⼼脏, 各个器官. 这些器官组合成⼀个⼈. 这时. ⼈如果挂了. 其他的东⻄也跟着挂了（<strong>将一个类的对象封装到另一个类的对象的属性中，就叫组合</strong>）</li>
</ol>
</li>
<li>实现关系</li>
<li>继承关系(类的三大特性之一：继承。)</li>
</ol>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li>优点<ol>
<li>增加了类的耦合性（耦合性不宜多，宜精）。</li>
<li>减少了重复代码。</li>
<li>使得代码更加规范化，合理化。</li>
</ol>
</li>
<li>python中类的类型<ol>
<li>⼀个叫经典类. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.</li>
<li>⼀个叫新式类. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。</li>
<li>python3中使⽤的都是新式类. 如果基类谁都不继承. 那这个类会默认继承 object</li>
</ol>
</li>
<li>执行顺序<ol>
<li>子类中重新方法就会覆盖</li>
<li>子类中调用父类方法<ol>
<li>父类名.方法</li>
<li>super().方法</li>
</ol>
</li>
</ol>
</li>
<li>多继承<ol>
<li>经典类的计算：深度优先</li>
<li>新式类的计算：mro算法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2), [ Base1, Base2] )</span><br><span class="line"><span class="number">1</span>-merge不为空，取出第一个列表列表①的表头E，进行判断                              </span><br><span class="line">各个列表的表尾分别是[O], [E,F,O]，E在这些表尾的集合中，因而跳过当前当前列表</span><br><span class="line"><span class="number">2</span>-取出列表②的表头C，进行判断</span><br><span class="line">C不在各个列表的集合中，因而将C拿出到merge外，并从所有表头删除</span><br><span class="line">merge( [E,O], [C,E,F,O], [C]) = [C] + merge( [E,O], [E,F,O] )</span><br><span class="line"><span class="number">3</span>-进行下一次新的merge操作 ......</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="面向对象编程特性：继承，封装，多态"><a href="#面向对象编程特性：继承，封装，多态" class="headerlink" title="面向对象编程特性：继承，封装，多态"></a>面向对象编程特性：继承，封装，多态</h1><ol>
<li>封装：把很多数据封装到⼀个对象中。把固定功能的代码封装到⼀个代码块，函数，对象，打包成模块</li>
<li>继承： ⼦类可以⾃动拥有⽗类中除了私有属性外的其他所有内容；两个类具有相同的功能或者特征的时候就可以使用继承，提高代码的重用率</li>
<li>多态： 同⼀个对象，多种形态；子类可以使用父类的方法也可以重写父类的方法</li>
<li>类的约束<ol>
<li>取⽗类：然后在⽗类中定义好⽅法。在这个⽅法中什么都不⽤⼲。就抛⼀个异常就可以了。这样所有的⼦类都必须重写这个⽅法。否则。访问的时候就会报错。⼈为抛出异常的⽅案</li>
<li>使⽤元类来描述⽗类：在元类中给出⼀个抽象⽅法。这样⼦类就不得不给出抽象⽅法的具体实现。也可以起到约束的效果。  </li>
</ol>
</li>
<li>super()深入了解？？？？？？？？</li>
</ol>
<h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><ol>
<li><p>对于这些<strong>私有</strong>成员来说,他们<strong>只能在类的内部使用,不能在类的外部以及派生类中使用</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    company_name = <span class="string">'陈松'</span>  <span class="comment"># 静态变量(静态字段)</span></span><br><span class="line">    __iphone = <span class="string">'132333xxxx'</span>  <span class="comment"># 私有静态变量(私有静态字段)</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> <span class="comment">#特殊方法</span></span><br><span class="line">        self.name = name  <span class="comment">#对象属性(普通字段)</span></span><br><span class="line">        self.__age = age  <span class="comment"># 私有对象属性(私有普通字段)</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>  <span class="comment"># 普通方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span> <span class="comment">#私有方法</span></span><br><span class="line">        print(<span class="number">666</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @classmethod  # 类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_func</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">""" 定义类方法，至少有一个cls参数 """</span></span><br><span class="line">        print(<span class="string">'类方法'</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @staticmethod  #静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">""" 定义静态方法 ，无默认参数"""</span></span><br><span class="line">        print(<span class="string">'静态方法'</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @property  # 属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：普通方法、静态方法和类方法，三种方法在内存中都归属于类</p>
<ol>
<li><p>实例方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</span><br><span class="line">调用：只能由实例对象调用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>类方法：通过类调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</span><br><span class="line">调用：实例对象和类对象都可以调用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态方法：逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</span><br><span class="line">调用：实例对象和类对象都可以调用。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>属性：property：property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值；将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本<strong>无法察觉自己的name是执行了一个函数然后计算出来的</strong>，这种特性的使用方式遵循了统一访问的原则</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get的时候运行我啊'</span>)</span><br><span class="line"><span class="meta">    @AAA.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'set的时候运行我啊'</span>)</span><br><span class="line"><span class="meta">    @AAA.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'delete的时候运行我啊'</span>)</span><br><span class="line"><span class="comment">#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br></pre></td></tr></table></figure>
</li>
<li><p>isinstance(a,b)：判断a是否是b类（或者b类的派生类）实例化的对象</p>
</li>
<li><p>issubclass(a,b)： 判断a类是否是b类（或者b的派生类）的派生类</p>
</li>
</ol>
<h1 id="对象反射"><a href="#对象反射" class="headerlink" title="对象反射"></a>对象反射</h1><ol>
<li>通过字符串的形式操作对象相关的属性<ol>
<li>hasattr()：判断是否有属性</li>
<li>getattr()：获取这个属性</li>
</ol>
</li>
<li>函数和方法的区别<ol>
<li>数的是显式传递数据的。如我们要指明为len()函数传递一些要处理数据。</li>
<li><strong>函数则跟对象无关。</strong></li>
<li>方法中的数据则是隐式传递的。</li>
<li>方法可以操作类内部的数据。</li>
<li><strong>方法跟对象是关联的</strong>。如我们在用strip()方法是，是不是都是要通过str对象调用，比如我们有字符串s,然后s.strip()这样调用。是的，strip()方法属于str对象</li>
</ol>
</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol>
<li><p>在程序运行的过程中，所有的变量都是在内存中，程序结束后全部回收，没有吧变量存储下来；我们把变量从内存中变成可存储或传输的过程称之为序列化；python的pickle模块可以将变量序列化存储到磁盘中；但是这个只适用于python，无法在其他语言中恢复</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line">pickle.dumps(d)</span><br><span class="line">f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(d, f)</span><br><span class="line">f.close()</span><br><span class="line">f = open(<span class="string">'dump.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line">d = pickle.load(f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON提供一种通用的序列化格式；dict对象可以直接序列化为JSON的{}</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>JSON模块：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span> <span class="comment"># 返回一个str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在序列化对象的时候，我们需要将其字典化</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span><span class="params">(std)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'name'</span>: std.name,</span><br><span class="line">        <span class="string">'age'</span>: std.age,</span><br><span class="line">        <span class="string">'score'</span>: std.score</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"score"</span>: <span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>网络参数</title>
    <url>/2020/03/19/linux/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<ul>
<li><a href="#零碎知识点">零碎知识点</a><ul>
<li><a href="#网络内核参数">网络内核参数</a><ul>
<li><a href="#arp_ignore与arp_announce">arp_ignore与arp_announce</a><!-- TOC END -->

</li>
</ul>
</li>
</ul>
</li>
</ul><h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><h2 id="网络内核参数"><a href="#网络内核参数" class="headerlink" title="网络内核参数"></a>网络内核参数</h2><h3 id="arp-ignore与arp-announce"><a href="#arp-ignore与arp-announce" class="headerlink" title="arp_ignore与arp_announce"></a>arp_ignore与arp_announce</h3><ul>
<li>arp_ignore和arp_announce参数都和<strong>ARP协议相关</strong>，主要用于<strong>控制系统返回arp响应和发送arp请求时的动作</strong>。这两个参数很重要，特别是在LVS的DR场景下，它们的配置直接影响到DR转发是否正常。</li>
</ul><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<ol>
<li><strong>arp_ignore</strong>：控制系统在收到外部的arp请求时，是否要返回arp响应<ul>
<li><strong>sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效</strong></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。</td>
</tr>
<tr>
<td>1</td>
<td>只响应目的IP地址为接收网卡上的本地地址的arp请求。</td>
</tr>
<tr>
<td>2</td>
<td>只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。</td>
</tr>
<tr>
<td>3</td>
<td>如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。</td>
</tr>
<tr>
<td>4~7</td>
<td>保留未使用</td>
</tr>
<tr>
<td>8</td>
<td>不回应所有的arp请求</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>arp_announce</strong>：控制系统在对外发送arp请求时，如何选择arp请求数据包的源IP地址<ul>
<li><strong>sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效</strong></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>允许使用任意网卡上的IP地址作为arp请求的源IP，通常就是使用数据包a的源IP。</td>
</tr>
<tr>
<td>1</td>
<td>尽量避免使用不属于该发送网卡子网的本地地址作为发送arp请求的源IP地址。</td>
</tr>
<tr>
<td>2</td>
<td>忽略IP数据包的源IP地址，选择该发送网卡上最合适的本地地址作为arp请求的源IP地址。</td>
</tr>
</tbody></table>
<ol start="3">
<li>参考网址：<a href="https://www.cnblogs.com/lipengxiang2009/p/7451050.html" target="_blank" rel="noopener">https://www.cnblogs.com/lipengxiang2009/p/7451050.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>平均负载</title>
    <url>/2020/03/19/linux/%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<ul>
<li><a href="#平均负载均衡">平均负载均衡</a><ul>
<li><a href="#案例分析">案例分析</a><!-- TOC END -->

</li>
</ul>
</li>
</ul><h1 id="平均负载均衡"><a href="#平均负载均衡" class="headerlink" title="平均负载均衡"></a>平均负载均衡</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># uptime</span></span><br><span class="line"> 22:59:05 up 2 min,  2 users,  load average: 0.25, 0.33, 0.14</span><br></pre></td></tr></table></figure><ol>
<li><p>通过top命令或者uptime命令查看；load average字段为1 分钟、5 分钟、15 分钟的平均负载</p>
</li>
<li><p>平均负载概念：单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是<strong>平均活跃进程数</strong></p>
<ul>
<li>可运行状态（R）：正在使用 CPU 或者正在等待 CPU 的进程</li>
<li>不可中断状态（D）：进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的（io写入的进程）</li>
</ul>
</li>
<li><p>比如当平均负载为 2 时，意味着什么呢？</p>
<ul>
<li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li>
<li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li>
<li>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</li>
</ul>
</li>
<li><p>查看CPU核数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | wc -l</span><br><span class="line"><span class="comment"># lscpu</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一般负载超过70%就需要排查</p>
</li>
<li><p>cpu使用率不等于平均负载：可以由第2点得知；正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程</p>
</li>
</ol><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->




<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ol>
<li>sysstat：包含工具iostat、mpstat、pidstat用于查找负载升高的原因<ol>
<li>mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</li>
<li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</li>
</ol>
</li>
<li>stress：压力测试工具</li>
<li><strong>模拟cpu密集型服务器压力测试</strong></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用一个cpu，占满100%，时间600s</span></span><br><span class="line">[root@node1 ~]<span class="comment"># stress --cpu 1 --timeout 600</span></span><br><span class="line">stress: info: [2319] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据$</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mpstat -P ALL 5     </span></span><br><span class="line">11:31:59 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:32:00 PM  all   50.50    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.50</span><br><span class="line">11:32:00 PM    0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">11:32:00 PM    1    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出占用cpu的进程</span></span><br><span class="line">[root@node1 ~]<span class="comment"># pidstat -u 5 1      </span></span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (node1) 	03/17/2020 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">11:34:37 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:34:42 PM     0      2320   99.40    0.00    0.00   99.40     0  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0      2320   99.40    0.00    0.00   99.40     -  stress</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>模拟io压力</strong><ul>
<li>iowait无法升高的问题，是因为案例中stress使用的是 sync() 系统调用，它的作用是刷新缓冲区内存到磁盘中。对于新安装的虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了。所以，你会看到只有系统CPU使用率升高。解决方法是使用stress的下一代stress-ng，它支持更丰富的选项，比如 stress-ng -i 1 –hdd 1 –timeout 600（–hdd表示读写临时文件）。</li>
</ul>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">占满io，时间600s</span><br><span class="line">[root@node1 ~]<span class="comment"># stress-ng --hdd -i 1 --timeout 600</span></span><br><span class="line">stress: info: [3143] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有的cpu和内存的使用情况</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">11:30:05 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:30:08 AM  all    0.35    0.00    5.30   92.93    0.00    0.00    1.41    0.00    0.00    0.00</span><br><span class="line">11:30:08 AM    0    0.35    0.00    5.30   92.93    0.00    0.00    1.41    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line">Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">Average:     all    1.10    0.02   16.43   76.55    0.00    0.02    0.58    0.00    0.00    5.31</span><br><span class="line">Average:       0    1.10    0.02   16.43   76.55    0.00    0.02    0.58    0.00    0.00    5.31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@baidu ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.27.2.el7.x86_64 (baidu) 	03/18/2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">11:33:26 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:33:31 AM     0     25768    0.00   18.38    0.00   18.38     0  stress-ng-hdd</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0     25790    0.35   21.75    0.00   22.11     -  stress-ng-hdd</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>大量进程模拟</strong></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启多个线程大于核数</span></span><br><span class="line">[root@node1 ~]<span class="comment"># stress --cpu 4 --timeout 600</span></span><br><span class="line">stress: info: [3607] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">[root@node1 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (node1) 	03/17/2020 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">11:47:34 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:47:39 PM     0      3608   54.76    0.00    0.00   54.76     1  stress</span><br><span class="line">11:47:39 PM     0      3609   45.24    0.00    0.00   45.24     1  stress</span><br><span class="line">11:47:39 PM     0      3610   47.62    0.00    0.00   47.62     0  stress</span><br><span class="line">11:47:39 PM     0      3611   50.00    0.20    0.00   50.20     0  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0      3608   54.76    0.00    0.00   54.76     -  stress</span><br><span class="line">Average:        0      3609   45.24    0.00    0.00   45.24     -  stress</span><br><span class="line">Average:        0      3610   47.62    0.00    0.00   47.62     -  stress</span><br><span class="line">Average:        0      3611   50.00    0.20    0.00   50.20     -  stress</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>总结</strong><ul>
<li>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况</li>
<li>平均负载高有可能是 CPU 密集型进程导致的；</li>
<li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li>
<li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2020/02/25/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8BMyCat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>mycat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）</li>
<li>mycat的三大功能：分表、读写分离、主从切换</li>
</ul><a id="more"></a>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><ol>
<li><p>下载安装 Java jdk</p>
<ul>
<li>网址：<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></li>
<li>解压，添加环境变量/etc/profile  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_241</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>下载安装 MyCat</p>
<ul>
<li><p>网址：<a href="https://github.com/MyCATApache/Mycat-download" target="_blank" rel="noopener">https://github.com/MyCATApache/Mycat-download</a></p>
</li>
<li><p>解压，完成安装</p>
</li>
<li><p>指令：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux：</span><br><span class="line">./mycat start 启动</span><br><span class="line">./mycat stop 停止</span><br><span class="line">./mycat console 前台运行</span><br><span class="line">./mycat install 添加到系统自动启动（暂未实现）</span><br><span class="line">./mycat remove 取消随系统自动启动（暂未实现）</span><br><span class="line">./mycat restart 重启服务</span><br><span class="line">./mycat pause 暂停</span><br><span class="line">./mycat status 查看启动状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试连接—Mycat连接测试：测试mycat与测试mysql完全一致</p>
</li>
</ul>
</li>
</ol>
<h3 id="MyCat-配置文件"><a href="#MyCat-配置文件" class="headerlink" title="MyCat 配置文件"></a>MyCat 配置文件</h3><h4 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--bin 启动目录</span><br><span class="line">--conf 配置文件存放配置文件：</span><br><span class="line">  --server.xml：是Mycat服务器参数调整和用户授权的配置文件。</span><br><span class="line">  --schema.xml：是逻辑库定义和表以及分片定义的配置文件。</span><br><span class="line">  --rule.xml：  是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</span><br><span class="line">  --log4j.xml： 日志存放在logs/log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要可以调整输出级别为debug；debug级别下，会输出更多的信息，方便排查问题。</span><br><span class="line">  --autopartition-long.txt,partition-hash-int.txt,sequence_conf.properties， sequence_db_conf.properties 分片相关的id分片规则配置文件</span><br><span class="line">  --lib	    MyCAT自身的jar包或依赖的jar包的存放目录。</span><br><span class="line">  --logs        MyCAT日志的存放目录。日志存放在logs/log中，每天一个文件</span><br></pre></td></tr></table></figure>

<h4 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h4><ol>
<li><p>server.xml</p>
<ul>
<li>添加两个mycat逻辑库：user,pay: system 参数是所有的mycat参数配置，比如添加解析器：defaultSqlParser，其他类推 user 是用户参数。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSqlParser"</span>&gt;</span>druidparser<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>mycat<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>user,pay<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>schema.xml</p>
<ul>
<li>修改dataHost和schema对应的连接信息，user,pay 垂直切分后的配置如下所示：schema 是实际逻辑库的配置，user，pay分别对应两个逻辑库，多个schema代表多个逻辑库。dataNode是逻辑库对应的分片，如果配置多个分片只需要多个dataNode即可。dataHost是实际的物理库配置地址，可以配置多主主从等其他配置，多个dataHost代表分片对应的物理库地址，下面的writeHost、readHost代表该分片是否配置多写，主从，读写分离等高级特性。以下例子配置了两个writeHost为主从。  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"pay"</span>  <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"pay"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">dataNode</span>=<span class="string">"pay1,pay2"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"pay1"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"pay1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"pay2"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"pay2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select 1<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.0.2:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.0.3:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>rule.xml</p>
<ul>
<li>该规则配置了order表的数据切分方式，及数据切分字段。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://org.opencloudb/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"org.opencloudb.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h4><ul>
<li><p>server.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:server SYSTEM "server.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>456789<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>schema.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"mycat_test"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.80.130:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Hjqme525+"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.80.131:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span> <span class="attr">password</span>=<span class="string">"Hjqme525+"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS3"</span> <span class="attr">url</span>=<span class="string">"192.168.80.129:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span> <span class="attr">password</span>=<span class="string">"Hjqme525+"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>docker machine</title>
    <url>/2020/02/24/docker/docker-machine/</url>
    <content><![CDATA[<h2 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker machine"></a>docker machine</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>短时间内在本地或云环境中搭建一套 Docker 主机集群；负责实现对Docker 运行环境进行安装和管理</li>
<li>基本功能<ol>
<li>在指定节点或平台上安装Docker 引擎，配置其为可使用的Docker 环境；</li>
<li>集中管理（包括启动、查看等）所安装的 Docker 环境</li>
</ol>
</li>
</ul><h3 id="安装Machine"><a href="#安装Machine" class="headerlink" title="安装Machine"></a>安装Machine</h3><a id="more"></a>
<ol>
<li><p>下载编译好的二进制文件</p>
<ul>
<li>docker machine安装教程 git 网址：<a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">https://github.com/docker/machine/releases/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt; /tmp/docker-machine &amp;&amp;</span><br><span class="line">chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>检查安装是否完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine version</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建docker主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine -d 驱动 --generic-ip-address=&apos;ip&apos; name</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>docker compose</title>
    <url>/2020/02/23/docker/docker-compose/</url>
    <content><![CDATA[<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li><p>负责实现对Docker 容器集群的快速编排</p>
</li>
<li><p>允许用户通过一个单独的docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
</li>
<li><p>compose 中有两个重要的概念：</p>
<ol>
<li>任务（task）：一个容器被称为一个任务。任务拥有独一无二的ID ，在同一个服务中的多个任务序号依次递增。</li>
<li>服务（service）：某个相同应用镜像的容器副本集合，一个服务可以横向扩展为多个容器实例。</li>
<li>服务栈（stack）：由多个服务组成，相互配合完成特定业务，如Web 应用服务、数据库服务共同构成Web 服务钱，一般由一个docker-cornpose . yaml 文件定义</li>
</ol>
</li>
<li><p>Compose 掌管运行时的编排能力。使用Compose模板文件，用户可以编写包括若干服务的一个模板文件快速启动服务栈；分发给他人，也可快速创建一套相同的服务栈。</p>
</li>
</ul><a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>pip安装  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U docker-compose</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="文件及目录创建"><a href="#文件及目录创建" class="headerlink" title="文件及目录创建"></a>文件及目录创建</h3><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><ol>
<li><p>编写 docker-compose.yml 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    mysql:</span><br><span class="line">        network_mode: &quot;bridge&quot;</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: &quot;Hjqme525-&quot;</span><br><span class="line">            MYSQL_USER: &quot;jerqi&quot;</span><br><span class="line">            MYSQL_PASS: &quot;Hjqme525+&quot;</span><br><span class="line">        image: &quot;docker.io/mysql:latest&quot;</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">            - &quot;./data:/var/lib/mysql&quot;</span><br><span class="line">            - &quot;./conf/my.cnf:/etc/my.cnf&quot;</span><br><span class="line">            - &quot;./init:/docker-entrypoint-initdb.d/&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;6363:3306&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 my.cnf 配置文件（安装MySQL）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写初始化文件 init.sql（MySQL初始化）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified with &apos;mysql_native_password&apos; by &apos;Hjqme525-&apos;;</span><br><span class="line">update user set host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">update mysql set host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line">create database `test`;</span><br><span class="line">use test;</span><br><span class="line">create table `t1`</span><br><span class="line">(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">age int check &apos;age &gt;= 1&apos;</span><br><span class="line">);</span><br><span class="line">insert into `t1`</span><br><span class="line">values</span><br><span class="line">(1,1),(2,2),(3,3),(4,4);</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker_mysql</span><br><span class="line">├── conf</span><br><span class="line">│   └── my.cnf</span><br><span class="line">├── data</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── init</span><br><span class="line">    └── init.sql</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li><p>下拉镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>linux替换python3</title>
    <url>/2020/02/21/linux/python-install/</url>
    <content><![CDATA[<ol>
<li><p>安装python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install python36 python36-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换bin文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改yum配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /usr/bin/yum</span><br><span class="line">vim /usr/libexec/urlgrabber-ext-down</span><br><span class="line">将文件 #!/usr/bin/python修改为#!/usr/bin/python2即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>

</li>
</ol><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install -y python36 python36-devel</span><br><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br><span class="line">sed -i &apos;s/python2/python/&apos; /usr/bin/yum</span><br><span class="line">sed -i &apos;s/python2/python/&apos; /usr/libexec/urlgrabber-ext-down</span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>MySQL高可用之MHA搭建</title>
    <url>/2020/02/20/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8BMHA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案；是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用；</li>
</ul><a id="more"></a>
<h3 id="组成与工作原理"><a href="#组成与工作原理" class="headerlink" title="组成与工作原理"></a>组成与工作原理</h3><ul>
<li>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）</li>
<li>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明；</li>
<li>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失；但是如果发生了硬件故障等就无法获取到日志，导致数据丢失。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性；</li>
<li>至少需要三台服务器完成</li>
</ul>
<h3 id="工作过秤"><a href="#工作过秤" class="headerlink" title="工作过秤"></a>工作过秤</h3><ol>
<li>从宕机崩溃的master保存二进制日志事件（binlog events）;</li>
<li>识别含有最新更新的slave；</li>
<li>应用差异的中继日志（relay log）到其他的slave；</li>
<li>应用从master保存的二进制日志事件（binlog events）；</li>
<li>提升一个slave为新的master；</li>
<li>使其他的slave连接新的master进行复制；</li>
</ol>
<h3 id="MHA软件"><a href="#MHA软件" class="headerlink" title="MHA软件"></a>MHA软件</h3><ul>
<li><p>MHA软件由两部分组成，Manager工具包和Node工具包</p>
<ol>
<li><p>Manager工具包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh              检查MHA的SSH配置状况</span><br><span class="line">masterha_check_repl             检查MySQL复制状况</span><br><span class="line">masterha_manager                启动MHA</span><br><span class="line">masterha_check_status           检测当前MHA运行状态</span><br><span class="line">masterha_master_monitor         检测master是否宕机</span><br><span class="line">masterha_master_switch          控制故障转移（自动或者手动）</span><br><span class="line">masterha_conf_host              添加或删除配置的server信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node工具包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save_binary_logs                保存和复制master的二进制日志</span><br><span class="line">apply_diff_relay_logs           识别差异的中继日志事件并将其差异的事件应用于其他的slave</span><br><span class="line">filter_mysqlbinlog              去除不必要的ROLLBACK事件（MHA已不再使用这个工具）</span><br><span class="line">purge_relay_logs                清除中继日志（不会阻塞SQL线程）</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了尽可能的减少主库硬件损坏宕机造成的数据丢失，因此在配置MHA的同时建议配置成MySQL 5.5的半同步复制</p>
</li>
</ul>
<h2 id="部署MHA"><a href="#部署MHA" class="headerlink" title="部署MHA"></a>部署MHA</h2><ul>
<li>准备：四台服务器（一个manager节点，一个master节点，两个slave节点</li>
</ul>
<h3 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h3><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol>
<li>开启二进制日志功能与中继日志</li>
<li>从节点显示开启read-only只读设置，并设置relay_log_purge = 0 清理中继日志的功能</li>
<li>每个节点的server-id不同</li>
</ol>
<h4 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h4><ul>
<li><p>master节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=1</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave-1节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=2</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">read-only</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave-2节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=3</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">read-only</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后重启 MySQL 服务</p>
</li>
</ul>
<h3 id="配置MHA"><a href="#配置MHA" class="headerlink" title="配置MHA"></a>配置MHA</h3><ul>
<li><p>管理节点安装manager和node软件；数据库节点安装node软件</p>
</li>
<li><p>软件地址：</p>
<ul>
<li><p>mha4mysql-manager</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/yoshinorim/mha4mysql-manager</span><br></pre></td></tr></table></figure>
</li>
<li><p>mha4mysql-node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/yoshinorim/mha4mysql-node</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安装rpm包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置manager节点mha配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/mha/cluster1.conf #没有文件需要自己创建</span><br><span class="line"></span><br><span class="line">[server default]</span><br><span class="line">user=test    #管理用户为数据库上的账户</span><br><span class="line">password=Hjqme525+   #管理密码</span><br><span class="line">manager_workdir=/data/mastermha/cluster1/     #mha工作路径</span><br><span class="line">manager_log=/data/mastermha/cluster1/manager.log   #mha日志文件</span><br><span class="line">remote_workdir=/data/mastermha/cluster1/      #每个远程主机的工作目录</span><br><span class="line">ssh_user=root</span><br><span class="line">repl_user=repl_user        #主从复制用户名称</span><br><span class="line">repl_password=Hjqme525+    #复制用户数据库密码</span><br><span class="line">ping_interval=1            #ping时间时长</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[server1]</span><br><span class="line">hostname=192.168.80.129  #主服务器IP地址</span><br><span class="line">candidate_master=1  #优先选为master节点</span><br><span class="line">[server2]</span><br><span class="line">hostname=192.168.80.130   #候选主服务器IP地址</span><br><span class="line">candidate_master=1  #优先选为master节点</span><br><span class="line">[server3]</span><br><span class="line">hostname=192.168.80.131</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置上所有节点见免密登陆，通过密钥对进行登陆</p>
</li>
</ul>
<h2 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h2><ol>
<li><p>检验SSH登陆</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验主从复制状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_repl --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动MHA(前台开启)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_manager --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看MHA运行状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_status --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL高可用</title>
    <url>/2020/02/20/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="MySQL高可用"><a href="#MySQL高可用" class="headerlink" title="MySQL高可用"></a>MySQL高可用</h2><h3 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h3><ul>
<li><p>主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值；</p>
</li>
<li><p>查看主备延迟</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> stauts;  <span class="comment">/*second_behind_master 参数*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于 seconds_behind_master 参数</p>
<ul>
<li>sbm参数事从服务器落后与主服务器的时间</li>
<li>由于主服务器性能或者网络等问题，可能导致，主服务器的日志到达从服务器的时候就已经很慢，不能通过这个时间直接判断<ol>
<li>sbm出现NULL值：<ul>
<li>出现空值时主从复制就断了或者停止工作</li>
</ul>
</li>
<li>sbm值大于等于0：<ul>
<li>大于0时，则主从服务器已经数据不一致，有滞后现象</li>
<li>等于0时，只能说明SQL解析线程relay_log到目前为止没有延迟</li>
</ul>
</li>
</ol>
</li>
<li>稍微准确的方法<ol>
<li>首先查看master_log_file参数，同relay_master_log_file参数的差异，比较日志的同步情况</li>
<li>其次查看read_master_log_pos和exec_master_log_pos参数的差异，比较日志的读取和执行差异</li>
<li>最后查看seconds_behind_master参数</li>
</ol>
</li>
<li>较新的GTID和pt工具<ol>
<li>较新的GIID的复制方式有更好的方式来判断时间点主从复制的差异</li>
<li>pt工具中的beatheart判断<ul>
<li>pt工具：在主服务器上有一个库表，定时写入数据，从服务器读取来分析差异</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>主备延迟来源：</p>
<ol>
<li>主备数据库服务器性能差距大</li>
<li>备库压力大，大量 DML 操作</li>
<li>大事务的执行是将过长</li>
<li>大表做 DDL 操作</li>
</ol>
</li>
<li><p>主备延迟——过期读</p>
<ol>
<li>强制走主库</li>
<li>sleep方法</li>
<li>判断主备延迟方法</li>
<li>配合使用semi-sync（半同步复制）</li>
<li>等主库位点</li>
<li>等GTID方法</li>
</ol>
</li>
</ul><a id="more"></a>
<h3 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h3><ol>
<li>可靠性优先策略<ul>
<li>数据一致性良好，但是可能照成数据库处于不可用状态。还可能照成数据暂时性丢失；</li>
</ul>
</li>
<li>可用性优先策略<ul>
<li>数据库不存在不可用状态，但是会造成数据不一致；</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL全局锁与表锁</title>
    <url>/2020/02/12/mysql/MySQL_lock/</url>
    <content><![CDATA[<h2 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h2><ul>
<li>计算机协调多个进程或线程并发访问同一资源的机制</li>
<li>MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</li>
<li>锁分类<ol>
<li>表锁：开销小，性能差</li>
<li>页锁：介于行锁与表锁之间</li>
<li>行锁：开销大，性能好，适于高并发</li>
<li>间隙锁：解决幻读的锁</li>
</ol>
</li>
<li>读锁：阻塞写不阻塞读，只能操作自己上锁表和数据</li>
<li>写锁：同时阻塞读写，其他会话的写操作会阻塞</li>
</ul><a id="more"></a>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul>
<li><p>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;  <span class="comment">/*此时整个库处于只读状态*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的</p>
</li>
<li><p>MySQL中的innodb支持事务：当 mysqldump 使用参数：–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图；同时过程中数据可更新</p>
</li>
<li><p>推荐使用ftwrl命令，少用set global variable readonly=true</p>
<ol>
<li>readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库</li>
<li>执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁；而后者则会一直持有锁不会自动释放</li>
</ol>
</li>
</ul>
<ol>
<li><p>查看加锁表</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分析表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Table_lock%'</span>;</span><br><span class="line">table_lock_immediate  <span class="comment">/*累计加锁次数*/</span></span><br><span class="line">table_lock_waited <span class="comment">/*正在等待的加索的进程*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><ul>
<li>语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> … <span class="keyword">read</span>/write <span class="comment">#加锁</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span> <span class="comment">#释放</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><ul>
<li>访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性</li>
<li>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性</li>
<li><strong>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</strong>，需要小心使用避免误操作使数据库挂掉。在拿不到MDL使需要进行处理<ul>
<li>这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃</li>
<li>DDL NOWAIT/WAIT n 语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="行锁-1"><a href="#行锁-1" class="headerlink" title="行锁"></a>行锁</h4><ul>
<li>行锁实现于存储引擎层</li>
</ul>
<ol>
<li><p>事务的ACID特性（原子性，一致性，隔离性，持久性）</p>
</li>
<li><p>事务隔离级别（read uncommited,read commited,repeatable read,lock read）</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommited</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>read commited</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>repeatable read</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>lock read</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
</li>
<li><p>查看当前事务隔离级别</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> lik <span class="string">'transaction_isolation'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引失效会导致行锁变为表锁；例如使用类型转换</p>
</li>
<li><p>间隙锁会在锁定一个范围导致一些操作无法操作</p>
</li>
<li><p>锁定一行</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> s <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="间隙锁（gap锁）"><a href="#间隙锁（gap锁）" class="headerlink" title="间隙锁（gap锁）"></a>间隙锁（gap锁）</h4><ul>
<li>为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)</li>
<li>间隙锁，锁的就是两个值之间的空隙</li>
<li>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系</li>
<li>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间</li>
<li>gap锁是一个动态概念，数据修改后可能会扩展范围</li>
<li>间隙锁的引入，解决了幻读的问题。但是导致同样的语句锁住更大的范围，影响了并发度</li>
<li>你如果把隔离级别设置为读提交，就没有间隙锁了。但同时需要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row</li>
</ul>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><ul>
<li>innodb中行锁在需要时加上，事务提交时释放</li>
<li><strong>如果需要锁多行，则需要将并发度高的放后面</strong></li>
</ul>
<h4 id="死锁于死锁检测"><a href="#死锁于死锁检测" class="headerlink" title="死锁于死锁检测"></a>死锁于死锁检测</h4><ul>
<li>死锁：由于不同线程出现资源相互等待而进入无限循环状态<ul>
<li>解决方法：<ol>
<li>等待超时：参数：innodb_lock_wait_timeout：设置等待超时时间</li>
<li>死锁检测：参数：innodb_deadlock_detect：设置开启死锁检测</li>
</ol>
</li>
<li>解决方案的优缺点</li>
</ul>
</li>
<li>提高并发度建议：<ol>
<li>关闭死锁检测</li>
<li>控制并发数</li>
<li>逻辑上通过将一行使用多行来代替</li>
</ol>
</li>
</ul>
<h3 id="加锁规则（两原则，两优化，一bug）"><a href="#加锁规则（两原则，两优化，一bug）" class="headerlink" title="加锁规则（两原则，两优化，一bug）"></a>加锁规则（两原则，两优化，一bug）</h3><ol>
<li>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间</li>
<li>原则 2：查找过程中访问到的对象才会加锁</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ol>
<h4 id="上锁注意点"><a href="#上锁注意点" class="headerlink" title="上锁注意点"></a>上锁注意点</h4><ul>
<li>锁是加载在索引上。执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</li>
<li>删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</li>
<li>next-key lock 先是加间隙锁，加锁成功；然后加上行锁</li>
<li>读提交隔离级别下：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>MySQL全局锁与表级锁</li>
<li>备库时看是否支持事务，选择锁库方式</li>
<li>注意MDL元数据表锁的使用</li>
<li>数据库出现 lock tables 语句时，需要引起注意。检查存储引擎和业务代码</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2019/12/10/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul>
<li>索引是特殊的数据结构</li>
<li>索引可以加速数据库对数据的检索速度，对数据进行排序</li>
<li>索引就是对数据进行排序加速检索速度的特殊数据结构</li>
</ul><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><ul>
<li>优点<ol>
<li>建立索引可以加速对于数据的检索速度</li>
<li>可以消除排序的操作，加快 SQL 执行速度，节省 CPU 资源</li>
<li>可以较低磁盘的 IO 读写</li>
</ol>
</li>
<li>缺点<ol>
<li>索引实质还是一张表，建立索引意味着额外的资源开销</li>
<li>维护许多索引需要较大的内存等资源开销</li>
<li>索引加快了读操作，但是降低了写操作的速度，因为修改表的操作同时需要对索引进行修改</li>
<li>需要花费更多的时间来建立一个优秀的索引</li>
</ol>
</li>
</ul><a id="more"></a>

<h3 id="常见索引类型"><a href="#常见索引类型" class="headerlink" title="常见索引类型"></a>常见索引类型</h3><h4 id="哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据"><a href="#哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据" class="headerlink" title="哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据"></a>哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据</h4><ol>
<li>无序索引,数据添加容易,直接追加</li>
<li>适合等值查找，范围查找性能差<h4 id="有序数组：按照字段排序来确定存放位置"><a href="#有序数组：按照字段排序来确定存放位置" class="headerlink" title="有序数组：按照字段排序来确定存放位置"></a>有序数组：按照字段排序来确定存放位置</h4></li>
</ol>
<ul>
<li>采用N叉树：B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数</li>
</ul>
<ol>
<li>有序索引，范围查找更优秀</li>
<li>适用于静态存储引擎</li>
<li>插入数据删除数据时存在一定问题，可能会导致页分裂和页合并，造成数据的空洞</li>
</ol>
<h3 id="Innodb的索引模型"><a href="#Innodb的索引模型" class="headerlink" title="Innodb的索引模型"></a>Innodb的索引模型</h3><ul>
<li>InnoDB 中，表都是根据主键顺序以索引的形式存放</li>
<li>主键为聚簇索引：主键索引的叶子节点存的是整行数据</li>
<li>非主键索引：非主键索引的叶子节点内容是主键的值（二级索引）</li>
<li>回表：在非主键索引中找到主键，然后回到主键索引树搜索的操作</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><ul>
<li>在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引</li>
<li>覆盖索引可以减少树的搜索次数，显著提升查询性能</li>
</ul>
<h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4><ul>
<li>利用索引的“最左前缀”，来定位记录</li>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><ul>
<li>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>普通索引重建时可以提高磁盘利用率，使索引更紧凑</li>
<li>重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建；建议使用 “alter table T engine=InnoDB”</li>
</ul>
<h2 id="索引选择出错"><a href="#索引选择出错" class="headerlink" title="索引选择出错"></a>索引选择出错</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;    //开启慢查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;    //普通查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;   //强制索引查询</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由优化器选择出最有索引，通过扫描行数来决定最优的，越少则访问磁盘次数最少</p>
</li>
<li><p>区分度：索引统计信息，索引的不同值的多少。不同值越多，区分度愈大。区分度大好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_nane;//查看基数值</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过局部估算来获得基数值。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数。当数据库修改的数据超过阈值 1/M 时会重新计算基数值。也可以手动重新计算基数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> table_name;//重新计算基数值</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种统计方法置参数 innodb_stats_persistent</p>
<ol>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="字符串索引创建"><a href="#字符串索引创建" class="headerlink" title="字符串索引创建"></a>字符串索引创建</h2><ol>
<li>直接索引，使用较大存储空间</li>
<li>前缀索引，增加回表次数，无法使用覆盖索引</li>
<li>倒叙再前缀索引，弥补前缀索引区分度不够</li>
<li>hash索引，性能稳定，额外开销</li>
</ol>
<h2 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h2><h3 id="条件函数操作"><a href="#条件函数操作" class="headerlink" title="条件函数操作"></a>条件函数操作</h3><ol>
<li><p>如果在 sql 语句中条件不部分使用了函数操作，则会导致索引失效，走全盘扫描。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对索引字段做函数操作，可能会破坏索引值的有序性，优化器就决定放弃走树搜索功能</p>
</li>
<li><p>对于索引右边的数据可以进行函数操作</p>
</li>
<li><p><strong>解决</strong>：避免在 where 条件中左边使用函数操作</p>
</li>
</ul>
</li>
<li><p>隐式类型转换</p>
<ul>
<li>字符串和数字做比较的话，是将字符串转换成数字（同使用了函数操作类似）</li>
<li><strong>解决</strong>：写语句时注意字段类型</li>
</ul>
</li>
<li><p>隐式字符编码转换</p>
<ul>
<li>关联表中的数据进行对比时如果不是一个字符集则需要进行类型转换</li>
<li><strong>解决</strong>：连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL隔离级别</title>
    <url>/2019/12/09/mysql/MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h2 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h2><ul>
<li>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</li>
</ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul>
<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到</li>
<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</li>
<li>串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>
<li><strong>隔离级别越高，并发性能越低</strong></li>
</ul><a id="more"></a>

<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><ul>
<li>数据库在事务启动时会创建一个视图，整个事务过程都需要使用</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问</li>
<li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响</li>
</ul>
<h4 id="事务隔离实现"><a href="#事务隔离实现" class="headerlink" title="事务隔离实现"></a>事务隔离实现</h4><ul>
<li>实现：每条记录在更新时都记录有一条回滚操作，记录上的新值通过回滚操作回到上一个状态的值</li>
<li>回滚日志删除：系统判断没有比当前回滚日志更早的视图时自动删除</li>
<li><strong>避免使用长事务：</strong>长事务会使系统存在很老的视图，所以会一直保留回滚日志。照成较大的存储空间浪费；同时还有可能照成锁的占用，拖垮数据库</li>
</ul>
<h4 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h4><ol>
<li>显示启动事务：通过begin或者start transaction来启动事务，通过commit提交或rollback回滚</li>
<li>隐式自动提交事务：系统设置 set autocommit=1 自动提交事务<ul>
<li>显示开启事务：使用 commit work and chain 来提交事务并自动开启下一个事务</li>
</ul>
</li>
<li>查看时间超过60s的长事务<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx</span><br><span class="line"><span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>参数：transaction_isolation：查看数据库当前隔离状态</li>
<li>参数：MAX_EXECUTION_TIME：set MAX_EXECUTION_TIME来设置事务最大执行时间</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2019/12/08/mysql/MySQL%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="MySQL日志模块"><a href="#MySQL日志模块" class="headerlink" title="MySQL日志模块"></a>MySQL日志模块</h2><h3 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo-log（重做日志）"></a>redo-log（重做日志）</h3><ul>
<li>MySQL如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</li>
<li>MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，在系统不是那么繁忙时再将内存中数据写入磁盘</li>
<li>redo-log大小固定，类似循环队列</li>
<li>为MySQL提供cache-safe功能，中途crash也能恢复</li>
</ul><a id="more"></a>
<h3 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h3><ul>
<li>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志</li>
</ul>
<h3 id="两种日志比较"><a href="#两种日志比较" class="headerlink" title="两种日志比较"></a>两种日志比较</h3><ol>
<li>redo-log是innodb存储引擎的日志系统；binlog是MySQL的server层的日志系统</li>
<li>redo-log是物理日志，记录数据库那个页上发生了改变；binlog是逻辑日志，记录某一条具体的数据库操作</li>
<li>redo-log大小固定，循环写，类似循环队列；binlog采用追加方式，写满后跳转下一个日志文件，不会覆盖前面的文件</li>
</ol>
<h3 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h3><ul>
<li>prepare状态与commit状态</li>
<li>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>redo log 用于保证 crash-safe 能力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">#这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘</span><br><span class="line"></span><br><span class="line">sync_binlog=1</span><br><span class="line">#这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘</span><br></pre></td></tr></table></figure>
</li>
<li><p>两阶段提交保证两个日志保持逻辑上一致</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>初始Docker</title>
    <url>/2019/11/29/docker/%E5%88%9D%E8%AF%86Docker/</url>
    <content><![CDATA[<h2 id="Docker第一步"><a href="#Docker第一步" class="headerlink" title="Docker第一步"></a>Docker第一步</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><ol>
<li><p>安装必要工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data.x86_64 \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建yum源repo文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新并安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum install docker-ce-19.03.2-3.el7</span><br></pre></td></tr></table></figure>

</li>
</ol><a id="more"></a>
<h3 id="创建docker用户组"><a href="#创建docker用户组" class="headerlink" title="创建docker用户组"></a>创建docker用户组</h3><ul>
<li>默认情况下，docker 命令会使用Unix socket与Docker引擎通讯。而只有root用户和docker 组的用户才可以访问Docker引擎的Unix socket</li>
<li>使普通用户也能使用docker所以需要将用户加入docker用户组中</li>
</ul>
<h2 id="Docker国内镜像加速"><a href="#Docker国内镜像加速" class="headerlink" title="Docker国内镜像加速"></a>Docker国内镜像加速</h2><ol>
<li><p>镜像加速页</p>
<ul>
<li><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></li>
</ul>
</li>
<li><p>选择镜像加速服务</p>
</li>
<li><p>启用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json \&lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://3hijzt0l.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h3><ul>
<li>定制每一层所添加的配置、文件</li>
</ul>
<h3 id="FROM-与-RUN-构建"><a href="#FROM-与-RUN-构建" class="headerlink" title="FROM 与 RUN 构建"></a>FROM 与 RUN 构建</h3><h4 id="FROM指定基础对象"><a href="#FROM指定基础对象" class="headerlink" title="FROM指定基础对象"></a>FROM指定基础对象</h4><ul>
<li>Dockerfile 中FROM 是必备的指令，并且必须是第一条指令</li>
</ul>
<h4 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h4><ul>
<li>执行命令行命令</li>
<li>每一个指令都会建立一层</li>
<li>确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉</li>
</ul>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li>创建一个镜像<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build [option] &lt;context上下文路劲&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="构建上下文Context"><a href="#构建上下文Context" class="headerlink" title="构建上下文Context"></a>构建上下文Context</h4><ul>
<li>一切都是使用的远程调用形式在服务端（Docker 引擎）完成</li>
<li>docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker 引擎</li>
</ul>
<h3 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h3><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><ul>
<li><p>格式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等</p>
</li>
</ul>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><ul>
<li>与copy相似</li>
<li>ADD 指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;</li>
<li>ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>
</ul>
<h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><ul>
<li>用于指定默认的容器主进程的启动命令</li>
<li>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出</li>
</ul>
<h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><ul>
<li>指定容器启动程序及参数</li>
<li>指定了ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给ENTRYPOINT 指令</li>
</ul>
<h4 id="env与arg设置变量参数"><a href="#env与arg设置变量参数" class="headerlink" title="env与arg设置变量参数"></a>env与arg设置变量参数</h4><ul>
<li>ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的</li>
</ul>
<h4 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h4><ul>
<li><p>尽量保持容器存储层不发生写操作</p>
</li>
<li><p>数据持久化</p>
</li>
<li><p>格式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">VOLUME [<span class="string">"&lt;路径1&gt;"</span>, <span class="string">"&lt;路径2&gt;"</span>...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名卷：任何写入操作都写入宿主机中不写入容器存储层。从而实现数据持久化</p>
</li>
</ul>
<h4 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h4><ul>
<li>声明运行时容器提供服务端口，在运行时并不会开启这个端口的服务</li>
<li>-p参数是映射宿主端口和容器端口；EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射</li>
</ul>
<h4 id="workdir与user"><a href="#workdir与user" class="headerlink" title="workdir与user"></a>workdir与user</h4><ul>
<li>workdir:指定工作目录</li>
<li>user:指定当前用户</li>
</ul>
<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><ul>
<li>健康检查</li>
<li>如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务</li>
<li>HEALTHCHECK 支持下列选项：<ol>
<li>--interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为30 秒；</li>
<li>--timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认30 秒；</li>
<li>--retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为unhealthy ，默认3 次</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Web网络攻击</title>
    <url>/2019/11/27/network/%E5%9B%BE%E8%A7%A3HTTP_11/%E5%9B%BE%E8%A7%A3HTTP_11/</url>
    <content><![CDATA[<h2 id="Web网络攻击"><a href="#Web网络攻击" class="headerlink" title="Web网络攻击"></a>Web网络攻击</h2><p>###</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据备份</title>
    <url>/2019/11/26/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h2 id="MySQL备份"><a href="#MySQL备份" class="headerlink" title="MySQL备份"></a>MySQL备份</h2><h3 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h3><h4 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h4><ul>
<li>全量备份</li>
<li>增量备份</li>
</ul><h4 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h4><h4 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h4><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><h4 id="mysqldump备份与还原数据"><a href="#mysqldump备份与还原数据" class="headerlink" title="mysqldump备份与还原数据"></a>mysqldump备份与还原数据</h4><ol>
<li><p>备份单/多库保留建库语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p <span class="comment">--databases database_1_name [database_2_name] &gt; /some/path/to/save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>备份多库与全库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p <span class="comment">--all-databases &gt; /some/path/to/save</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还原数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p &lt; /file/to/return</span><br></pre></td></tr></table></figure>

</li>
</ol><a id="more"></a>

<h4 id="利用mysqlbinlog备份数据"><a href="#利用mysqlbinlog备份数据" class="headerlink" title="利用mysqlbinlog备份数据"></a>利用mysqlbinlog备份数据</h4><ol>
<li><p>查看二进制日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog /binary/log</span><br><span class="line">mysqlbinlog <span class="comment">--base64-output=decode-rows --verbose /binary/log/path</span></span><br></pre></td></tr></table></figure>

<ul>
<li>at：可以理解为事务的执行点</li>
</ul>
</li>
<li><p>选择还原点还原</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--stop-positon='point(at_point)' /binary/log/path</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>构建Web内容的技术</title>
    <url>/2019/11/26/network/%E5%9B%BE%E8%A7%A3HTTP_10/%E5%9B%BE%E8%A7%A3HTTP_10/</url>
    <content><![CDATA[<h2 id="构建Web内容的技术"><a href="#构建Web内容的技术" class="headerlink" title="构建Web内容的技术"></a>构建Web内容的技术</h2><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><ul>
<li>为了发送Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML 文档内的这种特殊字符串叫做HTML 标签（Tag）</li>
</ul><a id="more"></a>
<h3 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h3><ul>
<li>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一</li>
<li>CSS的理念就是让文档的结构和设计分离，达到解耦的目的</li>
</ul>
<h3 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h3><ul>
<li>通过调用客户端脚本语言JavaScript，实现对HTML 的Web 页面的动态改造</li>
</ul>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ul>
<li>用以操作HTML 文档和XML 文档的API（Application Programming Interface，应用编程接口）</li>
</ul>
<h3 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h3><ul>
<li>通过Web 功能提供的应用程序</li>
</ul>
<h4 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h4><ul>
<li>Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制<br><img src="/2019/11/26/network/图解HTTP_10/图解HTTP_10/10.1.png" alt="CGI"></li>
</ul>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><ul>
<li>一种能在服务器上创建动态内容的程序</li>
<li>CGI，由于每次接到请求，程序都要跟着启动一次;而Servlet 运行在与Web 服务器相同的进程中，因此受到的负载较小<br><img src="/2019/11/26/network/图解HTTP_10/图解HTTP_10/10.2.png" alt="Servlet"></li>
</ul>
<h3 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h3><h4 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h4><ul>
<li>按应用目标进行扩展的通用标记语言</li>
<li>XML和HTML一样，使用标签构成树形结构，并且可自定义扩展标签</li>
</ul>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><ul>
<li>以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP追加协议</title>
    <url>/2019/11/26/network/%E5%9B%BE%E8%A7%A3HTTP_9/%E5%9B%BE%E8%A7%A3HTTP_9/</url>
    <content><![CDATA[<h2 id="基于HTTP-的功能追加协议"><a href="#基于HTTP-的功能追加协议" class="headerlink" title="基于HTTP 的功能追加协议"></a>基于HTTP 的功能追加协议</h2><h3 id="http瓶颈"><a href="#http瓶颈" class="headerlink" title="http瓶颈"></a>http瓶颈</h3><ul>
<li>原因<ol>
<li>一条连接上只可发送一个请求</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求/ 响应首部未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。<br><img src="/2019/11/26/network/图解HTTP_9/图解HTTP_9/9.1.png" alt="http"></li>
</ol>
</li>
</ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h4><a id="more"></a>
<ul>
<li>局部Web 页面替换加载的异步通信手段<br><img src="/2019/11/26/network/图解HTTP_9/图解HTTP_9/9.2.png" alt="Ajax"></li>
</ul>
<h4 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h4><ul>
<li>通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能</li>
<li>Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应<br><img src="/2019/11/26/network/图解HTTP_9/图解HTTP_9/9.3.png" alt="Comet"></li>
</ul>
<h4 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h4><ul>
<li><p>以会话层的形式加入，控制对数据的流动<br><img src="/2019/11/26/network/图解HTTP_9/图解HTTP_9/9.4.png" alt="SPDY"></p>
</li>
<li><p>设计</p>
<ol>
<li>多路复用流：通过单一的TCP 连接，可以无限制处理多个HTTP 请求</li>
<li>设置优先级</li>
<li>压缩HTTP首部</li>
<li>推送与服务器提示功能：支持服务器主动向客户端推送数据的功能；服务器可以主动提示客户端请求所需的资源</li>
</ol>
</li>
</ul>
<h3 id="全双工通信的-WebSocket"><a href="#全双工通信的-WebSocket" class="headerlink" title="全双工通信的 WebSocket"></a>全双工通信的 WebSocket</h3><ul>
<li>Web 浏览器与Web 服务器之间全双工通信标准<ol>
<li>推送功能</li>
<li>减少通信量：一直保持连接状态</li>
</ol>
</li>
<li>使用http首部中的upgrade首部字段实现连接<ol>
<li>握手请求</li>
<li>握手响应</li>
</ol>
</li>
<li>通信过程<br><img src="/2019/11/26/network/图解HTTP_9/图解HTTP_9/9.5.png" alt="WebSocket通信"></li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL磁盘扩展与介质迁移</title>
    <url>/2019/11/23/mysql/MySQL%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%E4%B8%8E%E4%BB%8B%E8%B4%A8%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="MySQL外部表（MySQL8-0）"><a href="#MySQL外部表（MySQL8-0）" class="headerlink" title="MySQL外部表（MySQL8.0）"></a>MySQL外部表（MySQL8.0）</h2><ul>
<li>使用MySQL的外部表进行数据的迁移可扩展</li>
</ul><h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><ul>
<li>存储空间不够，一些大表需要更大的存储空间</li>
<li>存储介质更新，需要迁移到更块的介质中</li>
</ul><h2 id="实验实例"><a href="#实验实例" class="headerlink" title="实验实例"></a>实验实例</h2><ul>
<li>源数据库位于 /var/lib/mysql/pre_database</li>
<li>外部表库位于 /var/lib/mysql_extend/pre_database</li>
</ul><a id="more"></a>


<ol>
<li><p>新建的表，位于新的存储位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mysql_extend_table`</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">21</span></span><br><span class="line">)<span class="keyword">DATA</span> <span class="keyword">DIRECTORY</span> = <span class="string">'/var/lib/mysql_extend'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend1.png" alt="权限"></p>
</li>
<li><p>可以看见，新建的表已经在指定的存储位置</p>
<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend2.png" alt="权限"></p>
</li>
<li><p><strong>注意相应文件夹权限要够</strong><br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend3.png" alt="权限"></p>
</li>
</ol>
<h3 id="实验迁移（MySQL5-7）"><a href="#实验迁移（MySQL5-7）" class="headerlink" title="实验迁移（MySQL5.7）"></a>实验迁移（MySQL5.7）</h3><ol>
<li><p>转移前<br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra1.png" alt="转移前"></p>
</li>
<li><p>创建表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">tablespace</span> mysql_pre_table</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">datafile</span> <span class="string">'/var/lib/mysql_extend/pre_database/tra_table.ibd'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra2.png" alt="创建"></p>
</li>
<li><p>迁移表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mysql_pre_table <span class="keyword">tablespace</span> mysql_pre_table;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果:原pre_table转移为现在的now_table<br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra3.png" alt="转移后"></p>
</li>
<li><p>查看表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_SYS_TABLESPACES;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra4.png" alt="tablespace"></p>
<ol>
<li>FILE_FORMAT:ANY ROW_FORMAT:ANY SPACE_TYPE:General 表明：<ol>
<li>这个表空间并不是 per_table 的，是可以多个表公用的存储空间</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li><p>在MySQL8.0中无法在其他数据目录下创建tablespace</p>
<ul>
<li>需要配置 innodb_directories 参数：官方文档链接(<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories</a>)</li>
<li>定义要在启动时扫描的表空间文件的目录。当服务器脱机时将表空间文件移动或还原到新位置时，将使用此选项。它还用于指定使用绝对路径创建或位于数据目录外部的表空间文件的目录</li>
</ul>
</li>
<li><p>在MySQL8.0中，将表创建在其他地方，不会在当前数据目录下创建任何东西，无 .isl 文件</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>安全的HTTPS</title>
    <url>/2019/11/23/network/%E5%9B%BE%E8%A7%A3HTTP_7/%E5%9B%BE%E8%A7%A3HTTP_7/</url>
    <content><![CDATA[<h2 id="确保Web-安全的HTTPS"><a href="#确保Web-安全的HTTPS" class="headerlink" title="确保Web 安全的HTTPS"></a>确保Web 安全的HTTPS</h2><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ul>
<li>使用明文通信</li>
<li>不验证通信方身份</li>
<li>无法证明报文完整性</li>
</ul><h4 id="使用明文通信"><a href="#使用明文通信" class="headerlink" title="使用明文通信"></a>使用明文通信</h4><ul>
<li>HTTP 本身不具备加密的功能，在互联网上传输容易找到窃听</li>
<li>加密处理防止窃听<ol>
<li>通信的加密<ul>
<li>通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP 的通信内容</li>
<li>SSL 建立安全通信线路之后，就可以在这条线路上进行HTTP通信</li>
</ul>
</li>
<li>内容加密<ul>
<li>对传输的内容进行加密</li>
</ul>
</li>
</ol>
</li>
</ul><a id="more"></a>

<h4 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="headerlink" title="不验证通信方的身份就可能遭遇伪装"></a>不验证通信方的身份就可能遭遇伪装</h4><ul>
<li>HTTP任何人都可以访问<ul>
<li>无法确定请求发送至目标的Web 服务器是否是按真实意图返回响应的那台服务器</li>
<li>无法确定客户端就是真实需要返回响应的客户端</li>
<li>无法确认通信的对方的访问权限</li>
<li>无法判定请求来之哪里</li>
<li>容易遭到DoS、DDos攻击</li>
</ul>
</li>
<li>通过查看对方证书来确认</li>
</ul>
<h4 id="无法证明报文完整性"><a href="#无法证明报文完整性" class="headerlink" title="无法证明报文完整性"></a>无法证明报文完整性</h4><ul>
<li>无法确认报文是否被篡改</li>
<li>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><ul>
<li>使用SSL或TSL进行加密认证通信</li>
</ul>
<h4 id="HTTPS-是身披SSL-外壳的HTTP"><a href="#HTTPS-是身披SSL-外壳的HTTP" class="headerlink" title="HTTPS 是身披SSL 外壳的HTTP"></a>HTTPS 是身披SSL 外壳的HTTP</h4><ul>
<li>使用SSL 时，则演变成先和SSL 通信，再由SSL 和TCP 通信</li>
</ul>
<h4 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h4><ul>
<li>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</li>
</ul>
<h4 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h4><ul>
<li>由可信第三方机构颁发的可信任证明</li>
<li>HTTPS通信<br><img src="/2019/11/23/network/图解HTTP_7/图解HTTP_7/7.9.png" alt="HTTPS通信"><br><img src="/2019/11/23/network/图解HTTP_7/图解HTTP_7/7.10.png" alt="HTTPS通信"></li>
</ul>
<h4 id="SSL通信慢"><a href="#SSL通信慢" class="headerlink" title="SSL通信慢"></a>SSL通信慢</h4><ul>
<li>加密与解密需要占用CPU和其他硬件资源</li>
<li>SSL通信部分会消耗网络资源，增加延迟</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP响应首部与实体首部字段</title>
    <url>/2019/11/21/network/%E5%9B%BE%E8%A7%A3HTTP_6/%E5%9B%BE%E8%A7%A3HTTP_6/</url>
    <content><![CDATA[<h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><ul>
<li>由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息</li>
</ul><h4 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h4><ul>
<li>告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源<ol>
<li>可处理范围请求时指定其为bytes</li>
<li>不能处理则指定其为none</li>
</ol>
</li>
</ul><h4 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h4><ul>
<li>告知客户端，源服务器在多久前创建了响应<ol>
<li>创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值</li>
</ol>
</li>
</ul><a id="more"></a>


<h4 id="ETage"><a href="#ETage" class="headerlink" title="ETage"></a>ETage</h4><ul>
<li>告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式<ol>
<li>当资源更新时，ETag 值也需要更新</li>
<li>强ETag 值和弱Tag 值<ul>
<li>强ETag：细微的变化都会改变其值</li>
<li>弱ETag：只有资源发生了根本改变，产生差异时才会改变ETag 值。字段值最开始处附加W/</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><ul>
<li>将响应接收方引导至某个与请求URI 位置不同的资源</li>
</ul>
<h4 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h4><ul>
<li>把由代理服务器所要求的认证信息发送给客户端</li>
</ul>
<h4 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h4><ul>
<li>告知客户端应该在多久之后再次发送请求</li>
</ul>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><ul>
<li>告知客户端当前服务器上安装的HTTP 服务器应用程序的信息</li>
</ul>
<h4 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h4><ul>
<li>代理服务器接收到带有Vary 首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为121响应返回</li>
</ul>
<h4 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h4><ul>
<li>用于HTTP 访问认证<ol>
<li>告知客户端适用于访问请求URI 所指定资源的认证方案（Basic 或是Digest）和带参数提示的质询（challenge）</li>
</ol>
</li>
</ul>
<h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><ul>
<li>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息</li>
</ul>
<h4 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h4><ul>
<li>通知客户端能够支持Request-URI 指定资源的所有HTTP 方法</li>
</ul>
<h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><ul>
<li>告知客户端服务器对实体的主体部分选用的内容编码方式</li>
</ul>
<h4 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h4><ul>
<li>告知客户端，实体主体使用的自然语言</li>
</ul>
<h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><ul>
<li>实体主体部分的大小</li>
</ul>
<h4 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h4><ul>
<li>给出与报文主体部分相对应的URI<ol>
<li>当返回的页面内容与实际请求的对象不同时，首部字段Content-Location内会写明URI</li>
</ol>
</li>
</ul>
<h4 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h4><ul>
<li>检查报文主体在传输过程中是否保持完整，以及确认传输到达</li>
</ul>
<h4 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h4><ul>
<li>告知客户端作为响应返回的实体的哪个部分符合范围请求</li>
</ul>
<h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><ul>
<li>说明了实体主体内对象的媒体类型</li>
</ul>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><ul>
<li>将资源失效的日期告知客户端</li>
</ul>
<h4 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h4><ul>
<li>指明资源最终修改的时间</li>
</ul>
<h3 id="为Cookie-服务的首部字段"><a href="#为Cookie-服务的首部字段" class="headerlink" title="为Cookie 服务的首部字段"></a>为Cookie 服务的首部字段</h3><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><ul>
<li>当服务器准备开始管理客户端的状态时，会事先告知各种信息<ul>
<li>属性<ol>
<li>expires：指定浏览器可发送Cookie 的有效期</li>
<li>path：用于限制指定Cookie 的发送范围的文件目录</li>
<li>domain：通过Cookie 的domain 属性指定的域名可做到与结尾匹配一致</li>
<li>secure：限制Web 页面仅在HTTPS 安全连接时，才可以发送Cookie</li>
<li>HttpOnly：使JavaScript 脚本无法获得Cookie。防止XSS跨站脚本攻击对cookie的窃取</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><ul>
<li>告知服务器，当客户端想获得HTTP 状态管理支持时，就会在请求中包含从服务器接收到的Cookie</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5基础</title>
    <url>/2019/11/20/python/Django2.0/HTML%E5%9F%BA%E7%A1%80/HTML5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="HTML5基础"><a href="#HTML5基础" class="headerlink" title="HTML5基础"></a>HTML5基础</h2><h3 id="HTML格式与部分元素"><a href="#HTML格式与部分元素" class="headerlink" title="HTML格式与部分元素"></a>HTML格式与部分元素</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档类型说明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!Doctype html&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--头部信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--元信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML基础<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--包含页面内的所有主体内容--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--直接显示文本--&gt;</span></span><br><span class="line">    Hello Html5!</span><br><span class="line">    <span class="comment">&lt;!-- class:给元素添加一个或多个样式表类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>here is title!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contenteditable:表示文件是否可编辑 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span>可编辑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 显示内容的开始位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">"rtl"</span>&gt;</span>在右边哟,不是在左边<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：元素的唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"myheader"</span>&gt;</span>这是显示id的作用!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- style：行内元素的样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: blue;text-align: center"</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>这也是标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: yellow;text-align: center;"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tabindex：tab键的选取顺序 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com/"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.aliyun.com/"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span>Aliyun<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.tencent.com/"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span>Tencent<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- title：鼠标悬停时显示的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"http://www.jd.com/"</span>&gt;</span>JD<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a>  

<ol>
<li><p>HTML基础标签</p>
<ul>
<li>head、body<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML标题</p>
<ul>
<li>&lt;h1&gt;到&lt;h6&gt;缩进标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML段落</p>
<ul>
<li>&lt;p&gt;标识段落<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML超链接</p>
<ul>
<li>&lt;a&gt;标识超链接<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com/"</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML图像</p>
<ul>
<li><img>标签为图片<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"local"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><ol>
<li><p>元素</p>
<ul>
<li>元素是指开始标签从开始到结束标签的所有代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>：换行标签（空元素标签）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>语法</p>
<ol>
<li>空元素在开始标签中结束关闭</li>
<li>大多数HTML元素可以嵌套</li>
</ol>
</li>
</ol>
<h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><ol>
<li><p>标签可以拥有属性为元素提供更多信息</p>
</li>
<li><p>属性以键值对形式出现</p>
</li>
<li><p>常用标签</p>
<ol>
<li><p>&lt;h1&gt;:align对其方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>title 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;body&gt;：bgcolor背景颜色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"#82cf05"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;a&gt;:target规定在何处打开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"localhost.html"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">1. _self：当前页面打开</span><br><span class="line">2. _blank：新页面打开</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>通用属性：</p>
<ol>
<li>class：规定元素的类名</li>
<li>id：标记元素的唯一ID</li>
<li>style：规定元素的样式</li>
<li>title：元素额外信息</li>
</ol>
</li>
</ol>
<h3 id="HTML格式化"><a href="#HTML格式化" class="headerlink" title="HTML格式化"></a>HTML格式化</h3><p><img src="/2019/11/20/python/Django2.0/HTML基础/HTML5基础/%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt></p>
<h3 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h3><p><img src="/2019/11/20/python/Django2.0/HTML基础/HTML5基础/HTML%E5%88%97%E8%A1%A8.png" alt></p>
<h4 id="HTML块"><a href="#HTML块" class="headerlink" title="HTML块"></a>HTML块</h4><p><img src="/2019/11/20/python/Django2.0/HTML基础/HTML5基础/HTML%E5%9D%97.png" alt></p>
<h3 id="HTML样式"><a href="#HTML样式" class="headerlink" title="HTML样式"></a>HTML样式</h3><ol>
<li><p>标签</p>
<ul>
<li>&lt;style&gt;：样式定义</li>
<li>&lt;link&gt;：资源引用</li>
</ul>
</li>
<li><p>属性</p>
<ol>
<li>rel=”syslesheet”：外部样式表</li>
<li>type=”text/css”：引入文档的类型</li>
<li>margin-left：边距</li>
</ol>
</li>
<li><p>插入方法</p>
<ol>
<li><p>外部样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">body &#123;background-color: gred&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内联样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h3 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h3><ul>
<li>div布局</li>
<li>table布局</li>
</ul>
<h3 id="HTML链接属性"><a href="#HTML链接属性" class="headerlink" title="HTML链接属性"></a>HTML链接属性</h3><ol>
<li><p>链接数据：</p>
<ul>
<li>文本链接</li>
<li>图片链接</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>href：指向另一个文档的链接</li>
<li>name：创建文档内的链接（同一页面内的内容跳转）</li>
</ul>
</li>
<li><p>img标签属性</p>
<ul>
<li>alt：替换文本属性</li>
<li>width：宽</li>
<li>height：高</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"suo.jpeg"</span> <span class="attr">width</span>=<span class="string">"200px"</span> <span class="attr">hight</span>=<span class="string">"200px"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> &gt;</span></span><br><span class="line">        用户：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密码：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"sign in"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        多选:</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        苹果：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        西红柿：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        男：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">        女：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        选项网址：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.jeffqi.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">row</span>=<span class="string">"30"</span>&gt;</span>填写个人信息<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>请求首部字段</title>
    <url>/2019/11/20/network/%E5%9B%BE%E8%A7%A3HTTP_5/%E5%9B%BE%E8%A7%A3HTTP_5/</url>
    <content><![CDATA[<h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><ul>
<li>从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容</li>
</ul><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><ul>
<li>通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级<ol>
<li>使用type/subtype 这种形式，一次指定多种媒体类型</li>
<li>使用q= 来额外表示权重值权重值q 的范围是0~1（可精确到小数点后3 位），且1 为最大值</li>
<li>首先返回权重值最高的媒体类型</li>
</ol>
</li>
</ul><a id="more"></a>

<h4 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h4><ul>
<li>通知服务器用户代理支持的字符集及字符集的相对优先顺序</li>
</ul>
<h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><ul>
<li>告知服务器用户代理支持的内容编码及内容编码的优先级顺序<ol>
<li>同accept一样，可有权重</li>
</ol>
</li>
</ul>
<h4 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h4><ul>
<li>告知服务器用户代理能够处理的自然语言集（指中文或英文等）<ol>
<li>有权重</li>
</ol>
</li>
</ul>
<h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><ul>
<li>告知服务器，用户代理的认证信息（证书值）<ol>
<li>客户端与服务器</li>
</ol>
</li>
</ul>
<h4 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h4><ul>
<li>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息<ol>
<li>客户端与代理服务器</li>
</ol>
</li>
</ul>
<h4 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h4><ul>
<li>告知服务器，期望出现的某种特定行为</li>
</ul>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><ul>
<li>告知服务器，期望出现的某种特定行为</li>
</ul>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><ul>
<li>告知服务器，请求的资源所处的互联网主机名和端口号<ol>
<li>唯一一个必须被包含在请求内的首部字段</li>
</ol>
</li>
</ul>
<h4 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h4><ul>
<li>服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求<ol>
<li>ETag：实体标记是与特定资源关联的确定值。资源更新变化后ETag随着改变</li>
<li>服务器会比对If-Match 的字段值和资源的ETag 值，仅当两者一致时，才会执行请求</li>
<li>可以使用星号(*)指定If-Match 的字段值。针对这种情况，服务器将会忽略ETag 的值，只要资源存在就处理请求</li>
</ol>
</li>
</ul>
<h4 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None_Match"></a>If-None_Match</h4><ul>
<li>资源不存在时返回响应，通常用来获取最新的资源</li>
</ul>
<h4 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h4><ul>
<li>如果在If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求</li>
</ul>
<h4 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h4><ul>
<li>告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求<h4 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h4></li>
<li>告知服务器若指定的IfRange字段值（ETag 值或者时间）和请求资源的ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源</li>
</ul>
<h4 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h4><ul>
<li>以十进制整数形式指定可经过的服务器最大数目</li>
</ul>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h4><ul>
<li>只需获取部分资源的范围请求<ol>
<li>处理请求后返回范围资源响应</li>
<li>无法处理时，返回全部资源响应</li>
</ol>
</li>
</ul>
<h4 id="Refere"><a href="#Refere" class="headerlink" title="Refere"></a>Refere</h4><ul>
<li>告知服务器请求的原始资源的URI</li>
</ul>
<h4 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h4><ul>
<li>告知服务器客户端能够处理响应的传输编码方式及相对优先级<ol>
<li>用于传输编码</li>
<li>指定伴随trailer 字段的分块传输编码的方式<ul>
<li>需要将trailers赋值给该字段</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><ul>
<li>将创建请求的浏览器和用户代理名称等信息传达给服务器</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Other</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP首部</title>
    <url>/2019/11/15/network/%E5%9B%BE%E8%A7%A3HTTP_4/%E5%9B%BE%E8%A7%A3HTTP/</url>
    <content><![CDATA[<h2 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h2><h3 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><ol>
<li>组成：方法、URI、HTTP 版本、HTTP 首部字段等</li>
</ol><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ol>
<li>组成：HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段</li>
</ol><h3 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h3><h4 id="4类HTTP首部字段类型"><a href="#4类HTTP首部字段类型" class="headerlink" title="4类HTTP首部字段类型"></a>4类HTTP首部字段类型</h4><ol>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ol><h4 id="非HTTP-1-1首部字段"><a href="#非HTTP-1-1首部字段" class="headerlink" title="非HTTP/1.1首部字段"></a>非HTTP/1.1首部字段</h4><ol>
<li>端到端首部（End-to-end Header）<ul>
<li>首部会转发给请求/ 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定必须被转发</li>
</ul>
</li>
<li>逐跳首部（Hop-by-hop Header）<ul>
<li>首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
<li>使用hop-by-hop 首部，需提供Connection 首部字段</li>
</ul>
</li>
</ol><a id="more"></a>



<h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><h4 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h4><ul>
<li><p>作用：通过指定首部字段Cache-Control 的指令，操作缓存的工作</p>
</li>
<li><p>缓存指令：</p>
<ol>
<li>public<ul>
<li>当指定使用public 指令时，则明确表明其他用户也可利用缓存</li>
</ul>
</li>
<li>private<ul>
<li>当指定private 指令后，响应只以特定的用户作为对象</li>
</ul>
</li>
<li>no-cache<ul>
<li>防止从缓存中返回过期的资源<ol>
<li>客户端将不会接收缓存过的响应。需要将请求转发给源服务器</li>
<li>服务器返回响应包含no-cache指令，则缓存服务器不能对资源进行缓存</li>
</ol>
</li>
<li>no-chche=location<ol>
<li>字段被指定参数值则客户端不能缓存响应报文。无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数</li>
</ol>
</li>
</ul>
</li>
<li>no-store<ul>
<li>暗示请求（和对应的响应）或响应中包含机密信息</li>
<li>no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源；no-store才是不进行缓存</li>
<li>该指令规定缓存不能在本地存储请求或响应的任一部分</li>
</ul>
</li>
<li>s-maxage和max-age<ul>
<li>客户端：允许返回过期一定时间的缓存</li>
<li>服务端：一定时间内缓存服务器自己处理缓存，不用向源服务器确认</li>
<li>不同：smaxage指令只适用于供多位用户使用的公共缓存服务器</li>
</ul>
</li>
<li>min-fresh<ul>
<li>要求缓存服务器返回至少还未过指定时间的缓存资源。返回的资源较新</li>
</ul>
</li>
<li>max-stale<ul>
<li>过期的资源还能被接收</li>
</ul>
</li>
<li>only-if-cache<ul>
<li>客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回；否则返回504 gateway timeout状态码</li>
</ul>
</li>
<li>must-revalidate<ul>
<li>必须再次确认返回的响应缓存的有效性</li>
</ul>
</li>
<li>proxy-revalidate<ul>
<li>缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</li>
</ul>
</li>
<li>no-transform<ul>
<li>缓存都不能改变实体主体的媒体类型</li>
</ul>
</li>
<li>cache-control扩展<ul>
<li>Cache-Control 首部字段本身没有community 这个指令。借助extension tokens 实现了该指令的添加</li>
<li>extension tokens 仅对能理解它的缓存服务器来说是有意义的</li>
</ul>
</li>
</ol>
</li>
<li><p>Connection</p>
<ul>
<li>管理不在转发给代理的首部字段</li>
<li>管理持久连接<ol>
<li>指定Connection 首部字段的值为Keep-Alive</li>
</ol>
</li>
</ul>
</li>
<li><p>Date</p>
<ul>
<li>报文创建时间</li>
</ul>
</li>
<li><p>Pragma</p>
<ul>
<li>客户端会要求所有的中间服务器不返回缓存的资源</li>
<li>属于通用首部字段，但只用在客户端发送的请求中</li>
</ul>
</li>
<li><p>Trailer</p>
<ul>
<li>事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1 版本分块传输编码时</li>
</ul>
</li>
<li><p>Transfer-Encoding</p>
<ul>
<li>定了传输报文主体时采用的编码方式</li>
<li>HTTP/1.1 的传输编码方式仅对分块传输编码有效</li>
</ul>
</li>
<li><p>Upgrand</p>
<ul>
<li>检测HTTP协议及其他协议是否可以使用更高的协议通信</li>
</ul>
</li>
<li><p>Via</p>
<ul>
<li>记录报文的传输路径</li>
</ul>
</li>
<li><p>Warning</p>
<ul>
<li>告知用户一些与缓存相关的问题警告</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>图解HTTP_3</title>
    <url>/2019/11/13/network/%E5%9B%BE%E8%A7%A3HTTP_3/%E5%9B%BE%E8%A7%A3HTTP_3/</url>
    <content><![CDATA[<h2 id="返回结果的HTTP-状态码"><a href="#返回结果的HTTP-状态码" class="headerlink" title="返回结果的HTTP 状态码"></a>返回结果的HTTP 状态码</h2><ul>
<li>HTTP 状态码负责表示客户端HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作</li>
</ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul>
<li>2XX 的响应结果表明请求被正常处理了<ol>
<li>200 OK<ul>
<li>表示从客户端发来的请求在服务器端被正常处理</li>
</ul>
</li>
<li>204 No Content<ul>
<li>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</li>
</ul>
</li>
<li>206 Partial Content<ul>
<li>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>响应报文中包含由Content-Range 指定范围的实体内容</li>
</ul>
</li>
</ol>
</li>
</ul><a id="more"></a>

<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul>
<li>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求<ol>
<li>301 Moved Permanently（永久重定向）<ul>
<li>表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>
</ul>
</li>
<li>302 Found（零时重定向）<ul>
<li>表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI 访问</li>
</ul>
</li>
<li>303 See Other<ul>
<li>表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>303 状态码明确表示客户端应当采用GET 方法获取资源</li>
</ul>
</li>
<li>304 Not Modified<ul>
<li>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li>
</ul>
</li>
<li>307 Temporary Redirect（临时重定向）<ul>
<li>该状态码与302 Found 有着相同的含义</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul>
<li>4XX 的响应结果表明客户端是发生错误的原因所在<ol>
<li>401 Bad Request<ul>
<li>表示请求报文中存在语法错误</li>
</ul>
</li>
<li>401 Unauthorized<ul>
<li>该状态码表示发送的请求需要有通过HTTP认证</li>
</ul>
</li>
<li>403 Forbidden<ul>
<li>表明对请求资源的访问被服务器拒绝了</li>
</ul>
</li>
<li>404 Not Found<ul>
<li>标识服务器上无法找到请求的资源</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul>
<li>5XX 的响应结果表明服务器本身发生错误<ol>
<li>500 Internal Server Error<ul>
<li>服务器在执行时发生错误</li>
</ul>
</li>
<li>503 Service Unavailable<ul>
<li>服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>图解HTTP_2</title>
    <url>/2019/11/12/network/%E5%9B%BE%E8%A7%A3HTTP_2/%E5%9B%BE%E8%A7%A3HTTP_2/</url>
    <content><![CDATA[<h2 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h2><ul>
<li>HTTP通信过程：从客户端发往服务端的请求以及从服务器端返回客服端的响应</li>
</ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><ol>
<li>分类：<ul>
<li>请求报文：客服端向服务端</li>
<li>响应报文：服务端向客服端</li>
</ul>
</li>
</ol><h3 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h3><ol>
<li>报文首部<ul>
<li>请求行或状态行</li>
<li>首部字段<ul>
<li>请求首部、响应首部、通用首部、实体首部、（可能还有Cookie等）</li>
</ul>
</li>
</ul>
</li>
<li>空行（CR + LF）</li>
<li>报文主体（不一定存在）</li>
</ol><a id="more"></a>


<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><ul>
<li>传输过程中通过编码提升传输速率，可能消耗更多CPU资源</li>
<li>报文主体和实体主体的差异<ol>
<li>报文：HTTP 通信中的基本单位</li>
<li>实体：请求或响应的有效载荷，由实体首部和实体主体构成</li>
</ol>
</li>
<li>压缩传输的内容编码<ol>
<li>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</li>
</ol>
</li>
</ul>
<h3 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h3><ul>
<li>通过将数据分割成多块进行传输，让浏览器逐步显示页面</li>
</ul>
<h3 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h3><ol>
<li>解释：一次发送可以有不同的数据类型</li>
<li>对部分对象集合包含的对象：<ul>
<li>multipart/form-data（表单）</li>
<li>multipart/byteranges（响应报文包含多个范围）</li>
</ul>
</li>
<li>使用多部分对象集合时，需要在首部字段里加上Content-type<ul>
<li>boundary 字符串来划分多部分对象集合指明的各类实体</li>
<li>起始和结尾都加入“–”标记开始和结尾</li>
<li><strong>多部分对象集合的每个部分类型中，都可以含有首部字段</strong></li>
<li><strong>可以在某个部分中嵌套使用多部分对象集合</strong></li>
</ul>
</li>
</ol>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><ul>
<li>指定范围发送的请求叫做范围请求</li>
<li>执行范围请求时，会用到首部字段Range 来指定资源的byte范围</li>
</ul>
<h3 id="内容协商返回最合适内容"><a href="#内容协商返回最合适内容" class="headerlink" title="内容协商返回最合适内容"></a>内容协商返回最合适内容</h3><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源</li>
<li>三种类型<ol>
<li>服务端驱动协商</li>
<li>客户端启动协商</li>
<li>透明协商</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL高可用之主从复制搭建</title>
    <url>/2019/11/07/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="配置主服务器"><a href="#配置主服务器" class="headerlink" title="配置主服务器"></a>配置主服务器</h2><ol>
<li><p>修改master配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">port=3306  </span><br><span class="line"></span><br><span class="line">basedir=/usr</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">tmpdir=/tmp</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line">log-bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个用于复制的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &apos;repl_user&apos;@&apos;%&apos; identified with &apos;mysql_native_password&apos; by &apos;123456&apos;;</span><br><span class="line">grant replication slave on *.* to &apos;repl_user&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启master服务器的MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置slave配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">port=3306  </span><br><span class="line"></span><br><span class="line">basedir=/usr</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">tmpdir=/tmp</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启slave服务器MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave切换master（MySQL服务中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">change master to</span><br><span class="line">  master_host=&apos;ip&apos;,</span><br><span class="line">  master_port=3306,</span><br><span class="line">  master_user=&apos;repl_user&apos;</span><br><span class="line">  master_password=&apos;123456&apos;,</span><br><span class="line">  &lt;!-- Master_log_file=&apos;&apos;,</span><br><span class="line">  master_log_pos=&apos;&apos; --&gt;</span><br><span class="line">  master_auto_position=1;</span><br><span class="line"></span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  mysql&gt; show slave status\G</span><br><span class="line"></span><br><span class="line">               Slave_IO_State: Waiting for master to send event   //检查</span><br><span class="line">                  Master_Host: xxx.xxx.xxx.xxx</span><br><span class="line">                  Master_User: repl_user</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: master-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 3117</span><br><span class="line">               Relay_Log_File: slave-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 3333</span><br><span class="line">        Relay_Master_Log_File: master-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes                                //检查</span><br><span class="line">            Slave_SQL_Running: Yes                                //检查</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 3117</span><br><span class="line">              Relay_Log_Space: 3541</span><br><span class="line">              Until_Condition: None</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: 74be5d5f-9fe5-11e9-8853-e02651c</span><br><span class="line">             Master_Info_File: mysql.slave_master_info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates //检查</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">        Get_master_public_key: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>awk</title>
    <url>/2019/10/11/linux/awk/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Awk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>默认情况下，awk通过空格分隔输入，使用 -F 指定分割符。选择输入的第的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk -F , &apos;&#123;print $1,$3&#125;&apos;</span><br><span class="line">Hello nice</span><br><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk -F &apos;,&apos; &apos;&#123;print $1,$3&#125;&apos;</span><br><span class="line">Hello awk</span><br></pre></td></tr></table></figure>
</li>
<li><p>awk中内置的$NF变量代表字段的数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk &apos;&#123;print $NF&#125;&apos;</span><br><span class="line">you</span><br></pre></td></tr></table></figure>
</li>
<li><p>维持跨行状态，END代表的是我们在执行完每行的处理之后只处理下面的代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo -e &apos;a 1\nb 2\nc 3&apos; | awk &apos;&#123;print $2&#125;&apos;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[root@aliyun ~]# echo -e &apos;one 1\ntwo 2&apos; | awk &apos;&#123;sum+=$2&#125; END &#123;print sum&#125;&apos;&apos;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
