<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>redis 安装</title>
    <url>/2020/05/15/redis/redis-install/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#install-redis-on-centos7">install redis on centos7</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="install-redis-on-centos7"><a href="#install-redis-on-centos7" class="headerlink" title="install redis on centos7"></a>install redis on centos7</h1><ol>
<li><p>下载安装包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis官网：http://download.redis.io/</span><br><span class="line">wget http://download.redis.io/releases/redis-5.0.7.tar.gz</span><br><span class="line">tar -xzvf redis-5.0.7.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd redis-5.0.7</span><br><span class="line">make</span><br><span class="line">make test</span><br></pre></td></tr></table></figure>

<p>安装报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make[1]: Entering directory `/root/softwares/redis-5.0.8/src&apos;</span><br><span class="line">You need tcl 8.5 or newer in order to run the Redis test</span><br><span class="line">make[1]: *** [test] Error 1</span><br><span class="line">解决：更新tcl</span><br><span class="line">wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz  </span><br><span class="line">sudo tar xzvf tcl8.6.1-src.tar.gz  -C /usr/local/  </span><br><span class="line">cd  /usr/local/tcl8.6.1/unix/  </span><br><span class="line">sudo ./configure  </span><br><span class="line">sudo make  </span><br><span class="line">sudo make install   </span><br><span class="line"></span><br><span class="line">或者直接安装tcl</span><br><span class="line">yum install -y tcl(注意版本要满足要求)</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /src</span><br><span class="line">./redis-server  # 默认配置启动</span><br><span class="line">./redis-server &amp;  # 后台启动</span><br><span class="line"># ./redis-server ../redis.conf  # redis.conf 为默认配置文件，可以修改</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./redis-cli</span><br><span class="line">commond</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://blog.csdn.net/zhangshu123321/java/article/details/51440106" target="_blank" rel="noopener">tcl报错</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>openstack起步</title>
    <url>/2020/05/13/docker/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/openstack/</url>
    <content><![CDATA[<!-- TOC -->

<ul>
<li><a href="#多平台">多平台</a></li>
<li><a href="#云平台">云平台</a></li>
<li><a href="#openstack">openstack</a></li>
<li><a href="#openstack基础环境搭建">openstack基础环境搭建</a><ul>
<li><a href="#实验准备">实验准备</a></li>
<li><a href="#环境构建">环境构建</a></li>
</ul>
</li>
<li><a href="#openstack-keystone认证服务">openstack keystone认证服务</a><ul>
<li><a href="#概念">概念</a></li>
<li><a href="#keystone认证过程">keystone认证过程</a></li>
<li><a href="#openstack-keystone-认证服务部署">openstack keystone 认证服务部署</a></li>
</ul>
</li>
<li><a href="#openstack-glance镜像服务">openstack glance镜像服务</a><ul>
<li><a href="#概念-1">概念</a></li>
<li><a href="#核心架构">核心架构</a></li>
<li><a href="#安装部署">安装部署</a></li>
</ul>
</li>
<li><a href="#openstack后续服务">openstack后续服务</a></li>
<li><a href="#参考文档">参考文档</a></li>
</ul>
<!-- /TOC -->
<a id="more"></a>

<h1 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h1><ol>
<li><p>多主机/多用户：资源相互依赖影响，无隔离</p>
</li>
<li><p>多单机/多虚拟机：资源共享，虚拟机相互隔离</p>
</li>
<li><p>多主机/多虚拟机：资源调度、业务流程、用户和权限管理</p>
</li>
</ol>
<h1 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h1><ul>
<li><h2 id="IaaS（基础设施即服务）"><a href="#IaaS（基础设施即服务）" class="headerlink" title="IaaS（基础设施即服务）"></a>IaaS（基础设施即服务）</h2><ol>
<li><p>laaS负责管理虚机的生命周期，包括创建、修改、备份、起停、销毁等</p>
</li>
<li><p>使用者需要关心虚机的类型（OS）和配置（CPU、内存、磁盘），并且自己负责部署上层的中间件及用</p>
</li>
</ol>
</li>
<li><h2 id="PaaS（平台即服务）"><a href="#PaaS（平台即服务）" class="headerlink" title="PaaS（平台即服务）"></a>PaaS（平台即服务）</h2><ol>
<li><p>提供的服务是应用的运行环境和一系列中间件服务（比如数据库、消息日志）使用着只需要专注应用的开发，并将自己的应用和数据部署到PaaS环境中</p>
</li>
<li><p>面向开发人员</p>
</li>
</ol>
</li>
<li><h2 id="SaaS（软件即服务）"><a href="#SaaS（软件即服务）" class="headerlink" title="SaaS（软件即服务）"></a>SaaS（软件即服务）</h2><ol>
<li>使用者只需要登录使用应用，无需关心应用使用什么技术实现，也不需要关系应用部署在哪里</li>
</ol>
</li>
</ul>
<h1 id="openstack"><a href="#openstack" class="headerlink" title="openstack"></a>openstack</h1><ul>
<li><p>定义：OpenStack对数据中心的计算、存储和网络资源进行同一管理，由此可见，OpenStack针对IT基础设施、是laaS这个层次的云操作系统。</p>
</li>
<li><p>OpenStack为虚拟机提供并管理三大类资源：计算、网络和存储</p>
</li>
<li><p>openstack 核心架构</p>
<p>  <img src="http://study.jeffqi.cn/cloud/openstack-core.jpg" alt="openstack-core"></p>
</li>
<li><h2 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h2><table>
<thead>
<tr>
<th>名称</th>
<th>服务</th>
</tr>
</thead>
<tbody><tr>
<td>Keystone</td>
<td>认证服务，为各种服务提供认证和权限管理服务</td>
</tr>
<tr>
<td>Glance</td>
<td>镜像服务，管理VM启动时的镜像</td>
</tr>
<tr>
<td>Nova</td>
<td>计算服务，管理VM的生命周期</td>
</tr>
<tr>
<td>Neutron</td>
<td>网络服务，提供网络连接服务，负责为VM创建L2和L3网络</td>
</tr>
<tr>
<td>Cinder</td>
<td>块存储服务，Cinder的每一个Volume对于VM都像一块Disk</td>
</tr>
<tr>
<td>Swift</td>
<td>对象存储服务，VM通过Restful API存储对象数据（可选）</td>
</tr>
</tbody></table>
</li>
<li><h2 id="可选服务"><a href="#可选服务" class="headerlink" title="可选服务"></a>可选服务</h2><table>
<thead>
<tr>
<th>名称</th>
<th>服务</th>
</tr>
</thead>
<tbody><tr>
<td>Ceilometer</td>
<td>监控计量服务，为报警、统计或计费提供</td>
</tr>
<tr>
<td>Heat</td>
<td>编排服务，管理编排资源，完成编排</td>
</tr>
<tr>
<td>Horizon</td>
<td>为Openstack用户提供一个Web的自服务Port</td>
</tr>
<tr>
<td>Trove</td>
<td>数据库服务，为数据库引擎提供云部署的</td>
</tr>
<tr>
<td>Telemetry</td>
<td>收集服务，对计量数据进行</td>
</tr>
</tbody></table>
</li>
<li><h2 id="neutron组成架构"><a href="#neutron组成架构" class="headerlink" title="neutron组成架构"></a>neutron组成架构</h2><ol>
<li><p>服务各个组成部分以及组件之间的逻辑关系，各个组件也能部署到不同的物理节点上</p>
</li>
<li><p>Openstack本身是一个分布式系统，不仅各服务可以分布部署，服务中的各个组件也可以分布部署。</p>
</li>
<li><p>极大的灵活性、伸缩性和高可用性，学习难度变大</p>
</li>
</ol>
</li>
</ul>
<h1 id="openstack基础环境搭建"><a href="#openstack基础环境搭建" class="headerlink" title="openstack基础环境搭建"></a>openstack基础环境搭建</h1><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><ol>
<li>centos7 * 2,每台两张网卡</li>
<li>修改 /etc/hosts 文件，主机名解析<ol>
<li>node1 controller</li>
<li>node2 computer</li>
</ol>
</li>
<li>关闭防火墙与selinux</li>
<li>配置yum阿里源</li>
</ol>
<h2 id="环境构建"><a href="#环境构建" class="headerlink" title="环境构建"></a>环境构建</h2><ol>
<li><p>设置时间同步</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y chrony</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件（控制节点）</span></span><br><span class="line">vim /etc/chrony.conf</span><br><span class="line">server time1.aliyun.com iburst</span><br><span class="line">server 210.72.145.44 iburst</span><br><span class="line">server s1a.time.edu.cn iburst</span><br><span class="line">allow  192.168.31.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件（计算节点）</span></span><br><span class="line">server controller iburst</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> chronyd &amp;&amp; systemctl restart chronyd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试同步</span></span><br><span class="line">chronyc sources</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改时区命令</span></span><br><span class="line">时区修改命令：timedatectl <span class="built_in">set</span>-timezone <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="2">
<li><p>安装Opnestack包（Q版本）： 所有节点</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install centos-release-openstack-queens</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件修改baseurl国内源</span></span><br><span class="line">vim /etc/yum.repo.d/centos-openstack-queens</span><br><span class="line">[centos-openstack-queens]</span><br><span class="line">name=CentOS-7 - OpenStack queens</span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/$contentdir/$releasever/cloud/$basearch/openstack-queens/</span></span><br><span class="line">baseurl=https://mirrors.aliyun.com/centos/7/cloud/x86_64/openstack-queens/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装客户端</span></span><br><span class="line">yum install python-openstackclient</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装数据库（控制节点）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y mariadb mariadb-server python2-PyMySQL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改编辑mariadb配置文件</span></span><br><span class="line">vim /etc/my.cnf.d/openstack.cnf</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="built_in">bind</span>-address = 0.0.0.0 // 绑定IP地址选择管理网络IP地址</span><br><span class="line">default-storage-engine = innodb</span><br><span class="line">innodb_file_per_table = on</span><br><span class="line">max_connections = 4096</span><br><span class="line">collation-server = utf8_general_ci</span><br><span class="line">character-set-server = utf8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行数据库</span></span><br><span class="line">systemctl <span class="built_in">enable</span> mariadb &amp;&amp; systemctl start mariadb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库</span></span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录验证</span></span><br><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装消息队列（控制节点）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">   yum install -y rabbitmq-server</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 启动服务</span></span><br><span class="line">   systemctl <span class="built_in">enable</span> rabbitmq-server.service &amp;&amp; systemctl start rabbitmq-server.service</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 添加openstack用户（密码为openstack）</span></span><br><span class="line">rabbitmqctl add_user openstack openstack</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 对openstack进行授权（rwx）</span></span><br><span class="line">rabbitmqctl set_permissions openstack <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 检查默认监听的5672端口</span></span><br><span class="line">   ss -ant | grep 5672</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装缓存服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y memcached python-memcached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /etc/sysconfig/memcached</span><br><span class="line">OPTIONS=<span class="string">"-l 127.0.0.1,::1,controller"</span>       <span class="comment"># 启用其他节点访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> memcached.service &amp;&amp; systemctl start memcached.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查监听默认11211端口</span></span><br><span class="line">ss -ant | grep 11211</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装etcd服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim /etc/etcd/etcd.conf</span><br><span class="line">ETCD_DATA_DIR=<span class="string">"/var/lib/etcd/default.etcd"</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS=<span class="string">"http://192.168.100.10:2380"</span></span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=<span class="string">"http://192.168.100.10:2379"</span></span><br><span class="line">ETCD_NAME=<span class="string">"controller"</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=<span class="string">"http://192.168.100.10:2380"</span></span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=<span class="string">"http://192.168.100.10:2379"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER=<span class="string">"controller=http://192.168.100.10:2380"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=<span class="string">"etcd-cluster"</span></span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=<span class="string">"new"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> etcd &amp;&amp; systemctl start etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查默认端口2379和2380</span></span><br><span class="line">ss -ant | grep -E <span class="string">'2379|2380'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="openstack-keystone认证服务"><a href="#openstack-keystone认证服务" class="headerlink" title="openstack keystone认证服务"></a>openstack keystone认证服务</h1><ul>
<li>keystone主要为openstack提供认证授权服务</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol>
<li><p>User</p>
<ul>
<li>指代任何使用OpenStack 的实体，可以是真正的用户，其他系统或者服务</li>
</ul>
</li>
<li><p>Credentials</p>
<ul>
<li>User 用来证明自己身份的信息，类比身份证。可以是：1. 用户名/密码2. Token 3. API Key 4. 其他高级方式</li>
</ul>
</li>
<li><p>Authentication</p>
<ul>
<li>Keystone 验证User 身份的过程</li>
</ul>
</li>
<li><p>Token</p>
<ul>
<li>token是由数字和字母组成的字符串，User 成功Authentication 后由Keystone 分配给User。类比通行证</li>
</ul>
</li>
<li><p>Project</p>
<ul>
<li><p>用于将OpenStack 的资源（计算、存储和网络）进行分组和隔离</p>
</li>
<li><p>资源的所有权属于project</p>
</li>
<li><p>每个user必须挂载在一个project上才能访问里面的资源</p>
</li>
</ul>
</li>
<li><p>Service</p>
<ul>
<li><p>OpenStack 的Service 包括Compute (Nova)、Block Storage (Cinder)、bject Storage (Swift)、Image Service(Glance) 、Networking Service (Neutron) 等。</p>
</li>
<li><p>每个Service 都会提供若干个Endpoint，User 通过Endpoint 访问资源和执行操作</p>
</li>
</ul>
</li>
<li><p>Endpoint</p>
<ul>
<li>是一个网络上可访问的地址，通常是一个URL。Service 通过Endpoint 暴露自己的API</li>
</ul>
</li>
<li><p>Role</p>
<ul>
<li><p>安全包含两部分：Authentication（认证）和Authorization（鉴权）Authentication 解决的是“你是谁？”的问题Authorization 解决的是“你能干什么？”的问题</p>
</li>
<li><p>一个用户可被分配多个角色</p>
</li>
<li><p>Service 决定每个Role 能做什么事情Service 通过各自的policy.json 文件对Role 进行访问控制</p>
</li>
</ul>
</li>
</ol>
<h2 id="keystone认证过程"><a href="#keystone认证过程" class="headerlink" title="keystone认证过程"></a>keystone认证过程</h2><ol>
<li>用户使用credentials想keystone服务发起认证</li>
<li>keystone认证完成后，返回token</li>
<li>用户询问可以访问的project，keystone返回可访问的清单</li>
<li>用户询问访问service的入口endpoint，keystone查询后返回结果</li>
<li>用户拿着token去访问endpoint的服务</li>
<li>service向keystone询问改token是否合法，然后提供或拒绝服务请求</li>
</ol>
<h2 id="openstack-keystone-认证服务部署"><a href="#openstack-keystone-认证服务部署" class="headerlink" title="openstack keystone 认证服务部署"></a>openstack keystone 认证服务部署</h2><ol>
<li><p>创建keyston用户和keystone库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line">create database keystone;</span><br><span class="line">GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'1'</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON keystone.* TO <span class="string">'keystone'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装openstack-keystone httpd mod_wsgi</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install openstack-keystone httpd mod_wsgi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改keystone配置文件</span></span><br><span class="line">[database]</span><br><span class="line">...</span><br><span class="line">connection = mysql://keystone:KEYSTONE_DBPASS@controller/keystone</span><br><span class="line">[memcache]</span><br><span class="line">...</span><br><span class="line">servers = localhost:11211</span><br><span class="line">[token]</span><br><span class="line">...</span><br><span class="line">provider = fernet</span><br><span class="line">[revoke]</span><br><span class="line">...</span><br><span class="line">driver = sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 认证身份初始化数据库</span></span><br><span class="line">su -s /bin/sh -c <span class="string">"keystone-manage db_sync"</span> keystone</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录查看数据库</span></span><br><span class="line">mysql -ukeystone -p</span><br><span class="line">use keystone;</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置http服务</span></span><br><span class="line">vim /etc/httpd/conf/httpd.conf</span><br><span class="line">ServerName controller</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改http配置</span></span><br><span class="line">ln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> httpd.service &amp;&amp; systemctl start httpd.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化fernet秘钥存储库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</span><br><span class="line">keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</span><br></pre></td></tr></table></figure>
</li>
<li><p>引导身份认证（设置admin密码）（也可向官网那样，创建访问点endpoint，然后创建用户）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">keystone-manage bootstrap --bootstrap-password 000000 \</span><br><span class="line">--bootstrap-admin-url http://controller:5000/v3/ \</span><br><span class="line">--bootstrap-internal-url http://controller:5000/v3/ \</span><br><span class="line">--bootstrap-public-url http://controller:5000/v3/ \</span><br><span class="line">--bootstrap-region-id RegionOne</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入系统变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OS_USERNAME=admin</span><br><span class="line"><span class="built_in">export</span> OS_PASSWORD=0        <span class="comment"># （设置的admin的密码）</span></span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_NAME=admin</span><br><span class="line"><span class="built_in">export</span> OS_USER_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_AUTH_URL=http://controller:5000/v3</span><br><span class="line"><span class="built_in">export</span> OS_IDENTITY_API_VERSION=3</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建project</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">   <span class="comment"># 创建service project</span></span><br><span class="line">openstack project create --domain default --description <span class="string">"Service Project"</span> service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建demo project</span></span><br><span class="line">openstack project create --domain default --description <span class="string">"Demo Project"</span> demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建demo用户,user角色</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建demo用户</span></span><br><span class="line">openstack user create --domain default \</span><br><span class="line">    --password-prompt demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 闯将user角色</span></span><br><span class="line">openstack role create user</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授予user角色到demo项目和用户</span></span><br><span class="line">openstack role add --project demo --user demo user</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openstack token issue       <span class="comment"># 确保环境变量导入真确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展（通过脚本导入变量验证）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim admin-openstack-env.sh</span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_USER_DOMAIN_NAME=Default</span><br><span class="line"><span class="built_in">export</span> OS_PROJECT_NAME=admin</span><br><span class="line"><span class="built_in">export</span> OS_USERNAME=admin</span><br><span class="line"><span class="built_in">export</span> OS_PASSWORD=1        <span class="comment"># 你设置的admin用户的密码</span></span><br><span class="line"><span class="built_in">export</span> OS_AUTH_URL=http://controller:5000/v3</span><br><span class="line"><span class="built_in">export</span> OS_IDENTITY_API_VERSION=3</span><br><span class="line"><span class="built_in">export</span> OS_IMAGE_API_VERSION=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line"><span class="built_in">source</span> admin-openstack-env.sh &amp;&amp; openstack token issue</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="openstack-glance镜像服务"><a href="#openstack-glance镜像服务" class="headerlink" title="openstack glance镜像服务"></a>openstack glance镜像服务</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>OpenStack 的镜像服务 (glance) 允许用户发现、注册和恢复虚拟机镜像。它提供了一个 REST API，允许您查询虚拟机镜像的 metadata 并恢复一个实际的镜像。您可以存储虚拟机镜像通过不同位置的镜像服务使其可用，就像 OpenStack 对象存储那样从简单的文件系统到对象存储系统。</p>
</li>
<li><p>镜像：Image 是一个模板，里面包含了基本的操作系统和其他的软件</p>
</li>
</ul>
<h2 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h2><ul>
<li><p>核心架构图</p>
<p>  <img src="http://study.jeffqi.cn/cloud/openstack-glance.jpg" alt="openstack-glance"></p>
</li>
</ul>
<ol>
<li><p>glance api</p>
<ul>
<li><p>glance-api 是系统后台运行的服务进程。对外提供REST API，响应image 查询、获取和存储的调用</p>
</li>
<li><p>不会真正处理请求。如果是与image metadata（元数据）相关的操作，glance-api 会把请求转发给glance-registry；如果是与image 自身存取相关的操作，glance-api 会把请求转发给该image 的store backend。</p>
</li>
</ul>
</li>
<li><p>glance-registry</p>
<ul>
<li><p>glance-registry 是系统后台运行的服务进程。负责处理和存取image 的metadata，例如image 的大小和类型</p>
</li>
<li><p>支持多种image格式</p>
</li>
</ul>
</li>
<li><p>Database</p>
<ul>
<li>Image 的metadata会保持到database中</li>
</ul>
</li>
<li><p>Store backend</p>
<ul>
<li>存放image的地方</li>
</ul>
</li>
</ol>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><ol>
<li><p>创建glance数据库和glance用户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">create database glance;</span><br><span class="line">GRANT ALL PRIVILEGES ON glance.* TO <span class="string">'glance'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'1'</span>;</span><br><span class="line">GRANT ALL PRIVILEGES ON glance.* TO <span class="string">'glance'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'1'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入环境变量获取admin用户权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> admin-openstack-env.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建glance用户,添加admin角色</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openstack user create --domain default --password-prompt glance</span><br><span class="line">openstack role add --project service --user glance admin</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建服务实体</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">openstack service create --name glance --description <span class="string">"OpenStack Image service"</span> image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建endpoint</span></span><br><span class="line">openstack endpoint create --region RegionOne image public http://controller:9292</span><br><span class="line">openstack endpoint create --region RegionOne image internal http://controller:9292</span><br><span class="line">openstack endpoint create --region RegionOne image admin http://controller:9292</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查endpoint</span></span><br><span class="line">openstack endpoint list</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装openstack-glance python-glance python-glanceclient</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install openstack-glance python-glance python-glanceclient</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改/etc/glance/glance-api.conf配置文件</span></span><br><span class="line">vim /etc/glance/glance-api.conf</span><br><span class="line">[database]</span><br><span class="line">...</span><br><span class="line">connection = mysql://glance:1@controller/glance</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">...</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:35357</span><br><span class="line">auth_plugin = password</span><br><span class="line">project_domain_id = default</span><br><span class="line">user_domain_id = default</span><br><span class="line">project_name = service</span><br><span class="line">username = glance</span><br><span class="line">password = 123      <span class="comment"># 用户设置的openstack中glance用户的密码</span></span><br><span class="line">[paste_deploy]</span><br><span class="line">...</span><br><span class="line">flavor = keystone</span><br><span class="line">[glance_store]</span><br><span class="line">...</span><br><span class="line">default_store = file</span><br><span class="line">filesystem_store_datadir = /var/lib/glance/images/</span><br><span class="line">[DEFAULT]</span><br><span class="line">...</span><br><span class="line">notification_driver = noop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑/etc/glance/glance-registry.conf配置文件</span></span><br><span class="line">vim /etc/glance/glance-registry.conf</span><br><span class="line">[database]</span><br><span class="line">...</span><br><span class="line">connection = mysql://glance:1@controller/glance</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">...</span><br><span class="line">auth_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:35357</span><br><span class="line">auth_plugin = password</span><br><span class="line">project_domain_id = default</span><br><span class="line">user_domain_id = default</span><br><span class="line">project_name = service</span><br><span class="line">username = glance</span><br><span class="line">password = 123      <span class="comment"># 用户设置的openstack中glance用户的密码</span></span><br><span class="line">[paste_deploy]</span><br><span class="line">...</span><br><span class="line">flavor = keystone</span><br><span class="line">[DEFAULT]</span><br><span class="line">...</span><br><span class="line">notification_driver = noop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同步数据库    </span></span><br><span class="line">su -s /bin/sh -c <span class="string">"glance-manage db_sync"</span> glance</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录验证数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">systemctl <span class="built_in">enable</span> openstack-glance-api.service openstack-glance-registry.service</span><br><span class="line">systemctl start openstack-glance-api.service openstack-glance-registry.service</span><br></pre></td></tr></table></figure>
</li>
<li><p>导入环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> OS_IMAGE_API_VERSION=2   <span class="comment"># 可加入前面的脚本中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载实验镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget http://download.cirros-cloud.net/0.3.4/cirros-0.3.5-x86_64-disk.img</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openstack image create <span class="string">"cirros"</span> --file cirros-0.3.5-x86_64-disk.img --disk-format qcow2 --container-format bare --public</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">openstack image list</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="openstack后续服务"><a href="#openstack后续服务" class="headerlink" title="openstack后续服务"></a>openstack后续服务</h1><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.openstack.org/" target="_blank" rel="noopener">openstack官方网站</a></li>
<li><a href="https://docs.openstack.or" target="_blank" rel="noopener">openstack官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>sed使用</title>
    <url>/2020/05/12/linux/sed/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#sed基础使用">sed基础使用</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="sed基础使用"><a href="#sed基础使用" class="headerlink" title="sed基础使用"></a>sed基础使用</h1><ul>
<li><p>行编辑器，sed是一种流编辑器</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed 参数 <span class="string">'匹配、正则、动作'</span> 源文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-n</td>
<td>不输出模式空间内容到屏幕</td>
</tr>
<tr>
<td>-e</td>
<td>多点编辑</td>
</tr>
<tr>
<td>-f /path/to/script_file</td>
<td>从指定文件中读取编辑脚本</td>
</tr>
<tr>
<td>-r</td>
<td>支持使用扩展正则表达式</td>
</tr>
<tr>
<td>-i</td>
<td>原处编辑</td>
</tr>
</tbody></table>
</li>
<li><p>动作</p>
<table>
<thead>
<tr>
<th>动作</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</td>
</tr>
<tr>
<td>i</td>
<td>插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)</td>
</tr>
<tr>
<td>c</td>
<td>取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</td>
</tr>
<tr>
<td>d</td>
<td>删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</td>
</tr>
<tr>
<td>p</td>
<td>打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</td>
</tr>
<tr>
<td>s</td>
<td>取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</td>
</tr>
</tbody></table>
</li>
<li><p>锚定符</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>默认</td>
<td>全文</td>
</tr>
<tr>
<td>#</td>
<td>第#行</td>
</tr>
<tr>
<td>$</td>
<td>最后一行</td>
</tr>
<tr>
<td>#,#</td>
<td>第#行到第 # 行</td>
</tr>
<tr>
<td>#,+#</td>
<td>第#行到第 # + # 行</td>
</tr>
<tr>
<td>~</td>
<td>步进 1<del>2 奇数行；2</del>2 偶数行</td>
</tr>
</tbody></table>
</li>
<li><p>正则</p>
<table>
<thead>
<tr>
<th>匹配符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>开头匹配</td>
</tr>
<tr>
<td>$</td>
<td>末尾匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配单个字符</td>
</tr>
<tr>
<td>*</td>
<td>0到多个前面的字符</td>
</tr>
<tr>
<td>+</td>
<td>1到多个前面的字符</td>
</tr>
<tr>
<td>?</td>
<td>0或一次</td>
</tr>
<tr>
<td>\</td>
<td>转义字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>0～9字符</td>
</tr>
<tr>
<td>[a-z],[A-Z]</td>
<td>大小写字符</td>
</tr>
<tr>
<td>|</td>
<td>或操作</td>
</tr>
<tr>
<td>\{m\}</td>
<td>匹配前面的m次（{n,m}，匹配n到m次）</td>
</tr>
<tr>
<td>\b</td>
<td>用来匹配单词开头（\bxx）或（xx\b）的任意字符，因此\bthe\b将匹配the，但不匹配they，\bthe将匹配the或they</td>
</tr>
<tr>
<td>\(\)</td>
<td>（）中的内容可以在后续通过 \number 来引用</td>
</tr>
<tr>
<td>&amp;</td>
<td>表示引用前面引用的字段</td>
</tr>
</tbody></table>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/bulh/articles/11071783.html" target="_blank" rel="noopener">sed指定位置添加</a></li>
<li><a href="https://www.cnblogs.com/zd520pyx1314/p/6061339.html" target="_blank" rel="noopener">sed正则使用</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux下文件描述极其作用</title>
    <url>/2020/04/29/linux/linux%E4%B8%8B%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#pid文件">pid文件</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="pid文件"><a href="#pid文件" class="headerlink" title="pid文件"></a>pid文件</h1><ul>
<li><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>  一般在 /var/run/ 下会有许多*.pid结尾的文件。这些文件是在程序运行后产生的。</p>
</li>
<li><h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><p>  *.pid 文件中只能看到进程号，只有一行数据</p>
</li>
<li><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>  防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。</p>
</li>
<li><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  调用fcntl设置pid文件的锁定F_SETLK状态，其中锁定的标志位F_WRLCK</p>
<p>  如果成功锁定，则写入进程当前PID，进程继续往下执行。</p>
<p>  如果锁定不成功，说明已经有同样的进程在运行了，当前进程结束退出。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock.l_type = F_WRLCK;</span><br><span class="line">lock.l_whence = SEEK_SET;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fcntl(fd, F_SETLK, &amp;lock) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//锁定不成功, 退出......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sprintf</span> (buf, <span class="string">"%d\n"</span>, (<span class="keyword">int</span>) pid);</span><br><span class="line">pidsize = <span class="built_in">strlen</span>(buf);</span><br><span class="line"><span class="keyword">if</span> ((tmp = write (fd, buf, pidsize)) != (<span class="keyword">int</span>)pidsize)&#123;</span><br><span class="line">    <span class="comment">//写入不成功, 退出......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>如果进程退出，则该进程加的锁自动失效。</li>
<li>如果进程关闭了该文件描述符fd， 则加的锁失效。(整个进程运行期间不能关闭此文件描述符)</li>
<li>锁的状态不会被子进程继承。如果进程关闭则锁失效而不管子进程是否在运行。</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://blog.csdn.net/shanzhizi/article/details/23272437?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-8" target="_blank" rel="noopener">pid文件作用</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Django起步</title>
    <url>/2020/04/27/python/Django3.0/Django%E5%9F%BA%E7%A1%80/%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AAapp/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#安装">安装</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://docs.djangoproject.com/en/3.0/" target="_blank" rel="noopener">Django官方文档</a></li>
<li><a href="https://www.youtube.com/watch?v=F5mRW0jo-U4&t=2944s" target="_blank" rel="noopener">youtube视频教学</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>jumpserver基础学习</title>
    <url>/2020/04/21/linux/jumpserver_study/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#jumpserver简介">jumpserver简介</a></li>
<li><a href="#jumpserver安装使用">jumpserver安装使用</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="jumpserver简介"><a href="#jumpserver简介" class="headerlink" title="jumpserver简介"></a>jumpserver简介</h1><pre><code>1. JumpServer 是全球首款完全开源的堡垒机, 使用 GNU GPL v2.0 开源协议；
2. 使用 Python / Django 进行开发, 遵循 Web 2.0 规范
3. JumpServer 采纳分布式架构, 支持多机房跨区域部署, 中心节点提供 API, 各机房部署登录节点, 可横向扩展、无并发访问限制
4. JumpServer 现已支持管理 SSH、 Telnet、 RDP、 VNC 协议资产
5. jumpserver核心功能包括身份认证、账号管理、权限控制和安全审计
6. 同时jumpserver还具有分布式、云存储等特点；有丰富便捷的可视化图形web界面

- [jumpserver官网](https://www.jumpserver.org/)</code></pre><h1 id="jumpserver安装使用"><a href="#jumpserver安装使用" class="headerlink" title="jumpserver安装使用"></a>jumpserver安装使用</h1><ul>
<li><p>jumpserver提供多种安装方式，直接安装或者通过docker安装（后续实验我们采用docker进行安装）</p>
</li>
<li><p>环境要求：</p>
<ol>
<li>硬件配置: 2个CPU核心, 4G 内存, 50G 硬盘（最低）</li>
<li>操作系统: Linux 发行版 x86_64</li>
<li>Python = 3.6.x</li>
<li>Mysql Server ≥ 5.6</li>
<li>Mariadb Server ≥ 5.5.56</li>
<li>Redis</li>
</ol>
</li>
<li><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>安装python3 mysql redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">自行查阅文档安装</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建Python虚拟环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 -m venv /opt/py3</span><br></pre></td></tr></table></figure>
</li>
<li><p>载入虚拟环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /opt/py3</span><br><span class="line"><span class="comment"># 注意，以后每次操作jumpserver的时候都需要载入python的这个虚拟环境</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git获取jumpserver代码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/jumpserver/jumpserver.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装环境依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jumpserver/requirements</span><br><span class="line">pip3 install wheel &amp;&amp; pip3 install --upgrade pip setuptools &amp;&amp; pip3 install -r requirements.txt</span><br><span class="line"><span class="comment"># 被反复折磨，网络超时，还是清华源；反复折磨知道去世</span></span><br><span class="line"><span class="comment"># 如有依赖问题可google</span></span><br></pre></td></tr></table></figure>

<p>下面我遇到的几个报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错：No package &apos;gss&apos; found Command &quot;python setup.py egg_info&quot; failed with error</span><br><span class="line">解决：yum install krb5-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">报错：安装python-ldap模块报错无法找到 lber.h 文件</span><br><span class="line">解决：yum install openldap-devel</span><br><span class="line"></span><br><span class="line">报错：gcc</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件（参考官网）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SECURITY WARNING: keep the secret key used in production secret!</span><br><span class="line"># 加密秘钥 生产环境中请修改为随机字符串，请勿外泄, 可使用命令生成</span><br><span class="line"># cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 49;echo</span><br><span class="line">SECRET_KEY: W5Ic3fMXNZ0p5RIy5DhJYJllppTfcfkW8Yuf94VBMfpcssbfu</span><br><span class="line"></span><br><span class="line"># SECURITY WARNING: keep the bootstrap token used in production secret!</span><br><span class="line"># 预共享Token coco和guacamole用来注册服务账号，不在使用原来的注册接受机制</span><br><span class="line">BOOTSTRAP_TOKEN: zxffNymGjP79j6BN</span><br><span class="line"></span><br><span class="line"># Development env open this, when error occur display the full process track, Production disable it</span><br><span class="line"># DEBUG 模式 开启DEBUG后遇到错误时可以看到更多日志</span><br><span class="line">DEBUG: false</span><br><span class="line"></span><br><span class="line"># DEBUG, INFO, WARNING, ERROR, CRITICAL can set. See https://docs.djangoproject.com/en/1.10/topics/logging/</span><br><span class="line"># 日志级别</span><br><span class="line">LOG_LEVEL: ERROR</span><br><span class="line"># LOG_DIR:</span><br><span class="line"></span><br><span class="line"># Session expiration setting, Default 24 hour, Also set expired on on browser close</span><br><span class="line"># 浏览器Session过期时间，默认24小时, 也可以设置浏览器关闭则过期</span><br><span class="line"># SESSION_COOKIE_AGE: 86400</span><br><span class="line">SESSION_EXPIRE_AT_BROWSER_CLOSE: true</span><br><span class="line"></span><br><span class="line"># Database setting, Support sqlite3, mysql, postgres ....</span><br><span class="line"># 数据库设置</span><br><span class="line"># See https://docs.djangoproject.com/en/1.10/ref/settings/#databases</span><br><span class="line"></span><br><span class="line"># SQLite setting:</span><br><span class="line"># 使用单文件sqlite数据库</span><br><span class="line"># DB_ENGINE: sqlite3</span><br><span class="line"># DB_NAME:</span><br><span class="line"></span><br><span class="line"># MySQL or postgres setting like:</span><br><span class="line"># 使用Mysql作为数据库</span><br><span class="line">DB_ENGINE: mysql</span><br><span class="line">DB_HOST: 127.0.0.1</span><br><span class="line">DB_PORT: 3306</span><br><span class="line">DB_USER: jumpserver</span><br><span class="line">DB_PASSWORD: rBi41SrDqlX4zsx9e1L0cqTP</span><br><span class="line">DB_NAME: jumpserver</span><br><span class="line"></span><br><span class="line"># When Django start it will bind this host and port</span><br><span class="line"># ./manage.py runserver 127.0.0.1:8080</span><br><span class="line"># 运行时绑定端口</span><br><span class="line">HTTP_BIND_HOST: 0.0.0.0</span><br><span class="line">HTTP_LISTEN_PORT: 8080</span><br><span class="line">WS_LISTEN_PORT: 8070</span><br><span class="line"></span><br><span class="line"># Use Redis as broker for celery and web socket</span><br><span class="line"># Redis配置</span><br><span class="line">REDIS_HOST: 127.0.0.1</span><br><span class="line">REDIS_PORT: 6379</span><br><span class="line">REDIS_PASSWORD: ZhYnLrodpmPncovxJTnRyiBs</span><br><span class="line"># REDIS_DB_CELERY: 3</span><br><span class="line"># REDIS_DB_CACHE: 4</span><br><span class="line"></span><br><span class="line"># Use OpenID authorization</span><br><span class="line"># 使用OpenID 来进行认证设置</span><br><span class="line"># BASE_SITE_URL: http://localhost:8080</span><br><span class="line"># AUTH_OPENID: false  # True or False</span><br><span class="line"># AUTH_OPENID_SERVER_URL: https://openid-auth-server.com/</span><br><span class="line"># AUTH_OPENID_REALM_NAME: realm-name</span><br><span class="line"># AUTH_OPENID_CLIENT_ID: client-id</span><br><span class="line"># AUTH_OPENID_CLIENT_SECRET: client-secret</span><br><span class="line"># AUTH_OPENID_IGNORE_SSL_VERIFICATION: True</span><br><span class="line"># AUTH_OPENID_SHARE_SESSION: True</span><br><span class="line"></span><br><span class="line"># Use Radius authorization</span><br><span class="line"># 使用Radius来认证</span><br><span class="line"># AUTH_RADIUS: false</span><br><span class="line"># RADIUS_SERVER: localhost</span><br><span class="line"># RADIUS_PORT: 1812</span><br><span class="line"># RADIUS_SECRET:</span><br><span class="line"></span><br><span class="line"># CAS 配置</span><br><span class="line"># AUTH_CAS&apos;: False,</span><br><span class="line"># CAS_SERVER_URL&apos;: &quot;http://host/cas/&quot;,</span><br><span class="line"># CAS_ROOT_PROXIED_AS&apos;: &apos;http://jumpserver-host:port&apos;,  </span><br><span class="line"># CAS_LOGOUT_COMPLETELY&apos;: True,</span><br><span class="line"># CAS_VERSION&apos;: 3,</span><br><span class="line"></span><br><span class="line"># LDAP/AD settings</span><br><span class="line"># LDAP 搜索分页数量</span><br><span class="line"># AUTH_LDAP_SEARCH_PAGED_SIZE: 1000</span><br><span class="line">#</span><br><span class="line"># 定时同步用户</span><br><span class="line"># 启用 / 禁用</span><br><span class="line"># AUTH_LDAP_SYNC_IS_PERIODIC: True</span><br><span class="line"># 同步间隔 (单位: 时) (优先）</span><br><span class="line"># AUTH_LDAP_SYNC_INTERVAL: 12</span><br><span class="line"># Crontab 表达式</span><br><span class="line"># AUTH_LDAP_SYNC_CRONTAB: * 6 * * *</span><br><span class="line">#</span><br><span class="line"># LDAP 用户登录时仅允许在用户列表中的用户执行 LDAP Server 认证</span><br><span class="line"># AUTH_LDAP_USER_LOGIN_ONLY_IN_USERS: False</span><br><span class="line">#</span><br><span class="line"># LDAP 认证时如果日志中出现以下信息将参数设置为 0 (详情参见：https://www.python-ldap.org/en/latest/faq.html)</span><br><span class="line"># In order to perform this operation a successful bind must be completed on the connection</span><br><span class="line"># AUTH_LDAP_OPTIONS_OPT_REFERRALS: -1</span><br><span class="line"></span><br><span class="line"># OTP settings</span><br><span class="line"># OTP/MFA 配置</span><br><span class="line"># OTP_VALID_WINDOW: 0</span><br><span class="line"># OTP_ISSUER_NAME: Jumpserver</span><br><span class="line"></span><br><span class="line"># Perm show single asset to ungrouped node</span><br><span class="line"># 是否把未授权节点资产放入到 未分组 节点中</span><br><span class="line"># PERM_SINGLE_ASSET_TO_UNGROUP_NODE: false</span><br><span class="line">#</span><br><span class="line"># 启用定时任务</span><br><span class="line"># PERIOD_TASK_ENABLE: True</span><br><span class="line">#</span><br><span class="line"># 启用二次复合认证配置</span><br><span class="line"># LOGIN_CONFIRM_ENABLE: False</span><br><span class="line">#</span><br><span class="line"># Windows 登录跳过手动输入密码</span><br><span class="line">WINDOWS_SKIP_ALL_MANUAL_PASSWORD: True</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动jumpserver</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jumpserver</span><br><span class="line">./jms start</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署koko组件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line"><span class="comment"># 下载koko的release压缩包</span></span><br><span class="line">wget https://github.com/jumpserver/koko/releases/download/1.5.8/koko-master-linux-amd64.tar.gz</span><br><span class="line">tar -xf koko-master-linux-amd64.tar.gz &amp;&amp; \  </span><br><span class="line">chown -R root:root kokodir &amp;&amp; \  </span><br><span class="line"><span class="built_in">cd</span> kokodir</span><br><span class="line"></span><br><span class="line">cp config_example.yml config.yml &amp;&amp; \  </span><br><span class="line">vim config.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 项目名称, 会用来向Jumpserver注册, 识别而已, 不能重复</span><br><span class="line"># NAME: &#123;&#123; Hostname &#125;&#125;</span><br><span class="line"></span><br><span class="line"># Jumpserver项目的url, api请求注册会使用</span><br><span class="line">CORE_HOST: http://127.0.0.1:8080</span><br><span class="line"></span><br><span class="line"># Bootstrap Token, 预共享秘钥, 用来注册coco使用的service account和terminal</span><br><span class="line"># 请和jumpserver 配置文件中保持一致，注册完成后可以删除</span><br><span class="line">BOOTSTRAP_TOKEN: zxffNymGjP79j6BN</span><br><span class="line"></span><br><span class="line"># 启动时绑定的ip, 默认 0.0.0.0</span><br><span class="line"># BIND_HOST: 0.0.0.0</span><br><span class="line"></span><br><span class="line"># 监听的SSH端口号, 默认2222</span><br><span class="line"># SSHD_PORT: 2222</span><br><span class="line"></span><br><span class="line"># 监听的HTTP/WS端口号，默认5000</span><br><span class="line"># HTTPD_PORT: 5000</span><br><span class="line"></span><br><span class="line"># 项目使用的ACCESS KEY, 默认会注册,并保存到 ACCESS_KEY_STORE中,</span><br><span class="line"># 如果有需求, 可以写到配置文件中, 格式 access_key_id:access_key_secret</span><br><span class="line"># ACCESS_KEY: null</span><br><span class="line"></span><br><span class="line"># ACCESS KEY 保存的地址, 默认注册后会保存到该文件中</span><br><span class="line"># ACCESS_KEY_FILE: data/keys/.access_key</span><br><span class="line"></span><br><span class="line"># 设置日志级别 [DEBUG, INFO, WARN, ERROR, FATAL, CRITICAL]</span><br><span class="line">LOG_LEVEL: ERROR</span><br><span class="line"></span><br><span class="line"># SSH连接超时时间 (default 15 seconds)</span><br><span class="line"># SSH_TIMEOUT: 15</span><br><span class="line"></span><br><span class="line"># 语言 [en,zh]</span><br><span class="line"># LANG: zh</span><br><span class="line"></span><br><span class="line"># SFTP的根目录, 可选 /tmp, Home其他自定义目录</span><br><span class="line"># SFTP_ROOT: /tmp</span><br><span class="line"></span><br><span class="line"># SFTP是否显示隐藏文件</span><br><span class="line"># SFTP_SHOW_HIDDEN_FILE: false</span><br><span class="line"></span><br><span class="line"># 是否复用和用户后端资产已建立的连接(用户不会复用其他用户的连接)</span><br><span class="line"># REUSE_CONNECTION: true</span><br><span class="line"></span><br><span class="line"># 资产加载策略, 可根据资产规模自行调整. 默认异步加载资产, 异步搜索分页; 如果为all, 则资产全部加载, 本地搜索分页.</span><br><span class="line"># ASSET_LOAD_POLICY:</span><br><span class="line"></span><br><span class="line"># zip压缩的最大额度 (单位: M)</span><br><span class="line"># ZIP_MAX_SIZE: 1024M</span><br><span class="line"></span><br><span class="line"># zip压缩存放的临时目录 /tmp</span><br><span class="line"># ZIP_TMP_PATH: /tmp</span><br><span class="line"></span><br><span class="line"># 向 SSH Client 连接发送心跳的时间间隔 (单位: 秒)，默认为30, 0则表示不发送</span><br><span class="line"># CLIENT_ALIVE_INTERVAL: 30</span><br><span class="line"></span><br><span class="line"># 向资产发送心跳包的重试次数，默认为3</span><br><span class="line"># RETRY_ALIVE_COUNT_MAX: 3</span><br><span class="line"></span><br><span class="line"># 会话共享使用的类型 [local, redis], 默认local</span><br><span class="line">SHARE_ROOM_TYPE: redis</span><br><span class="line"></span><br><span class="line"># Redis配置</span><br><span class="line">REDIS_HOST: 127.0.0.1</span><br><span class="line">REDIS_PORT: 6379</span><br><span class="line">REDIS_PASSWORD: ZhYnLrodpmPncovxJTnRyiBs</span><br><span class="line"># REDIS_CLUSTERS:</span><br><span class="line">REDIS_DB_ROOM: 6</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker部署koko</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name jms_koko -d \</span><br><span class="line">-p 2222:2222 -p 127.0.0.1:5000:5000 \</span><br><span class="line">-e CORE_HOST=http://&lt;Jumpserver_url&gt; \</span><br><span class="line">-e BOOTSTRAP_TOKEN=&lt;Jumpserver_BOOTSTRAP_TOKEN&gt; \</span><br><span class="line">-e LOG_LEVEL=ERROR \</span><br><span class="line">--restart=always \</span><br><span class="line">jumpserver/jms_koko:&lt;Tag&gt;</span><br><span class="line"><span class="comment"># &lt;Jumpserver_url&gt; 为 jumpserver 的 url 地址, &lt;Jumpserver_BOOTSTRAP_TOKEN&gt; 需要从 jumpserver/config.yml 里面获取, 保证一致, &lt;Tag&gt; 是版本</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://jumpserver.readthedocs.io/zh/master/index.html" target="_blank" rel="noopener">jumpsever官方文档</a></li>
<li><a href="https://blog.csdn.net/weixin_39269896/article/details/89486357" target="_blank" rel="noopener">gss报错解决网址</a></li>
<li><a href="https://blog.csdn.net/qq_20105831/article/details/89361472" target="_blank" rel="noopener">python-ldap报错解决网址</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL分区表使用</title>
    <url>/2020/04/15/mysql/mysql_partition_table/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>阿里yum-epel源替换</title>
    <url>/2020/04/06/linux/%E9%98%BF%E9%87%8Cyum-epel%E6%BA%90%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#阿里云-epel-源安装">阿里云 epel 源安装</a></li>
<li><a href="#阿里-yum-源">阿里 yum 源</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="阿里云-epel-源安装"><a href="#阿里云-epel-源安装" class="headerlink" title="阿里云 epel 源安装"></a>阿里云 epel 源安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 备份</span><br><span class="line">mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup</span><br><span class="line"></span><br><span class="line">mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup</span><br><span class="line"></span><br><span class="line">2. 下载</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line">3. 清除缓存</span><br><span class="line">yum clean all</span><br><span class="line"></span><br><span class="line">4. 创建缓存</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h1 id="阿里-yum-源"><a href="#阿里-yum-源" class="headerlink" title="阿里 yum 源"></a>阿里 yum 源</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line">2. 替换</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"></span><br><span class="line">3. 清除缓存</span><br><span class="line">yum clean all</span><br><span class="line"></span><br><span class="line">4. 创建缓存</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Ubuntu<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp -a /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line"></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"> </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基本操作</title>
    <url>/2020/04/05/mysql/mysql_base_operation/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#数据库表编码">数据库、表编码</a></li>
<li><a href="#索引操作">索引操作</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="数据库、表编码"><a href="#数据库、表编码" class="headerlink" title="数据库、表编码"></a>数据库、表编码</h1><ol>
<li><p>修改某一个库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据库中所有表被改动</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">database</span> db_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> charset_name <span class="keyword">collate</span> charset_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建库时指定</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> charset_name <span class="keyword">collate</span> charset_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改某个表</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把表默认的字符集和所有字符列（CHAR,VARCHAR,TEXT）改为新的字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_name <span class="keyword">convert</span> <span class="keyword">to</span> <span class="built_in">character</span> <span class="keyword">set</span> charset_name <span class="keyword">collate</span> charset_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只修改表的默认字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> charset_name <span class="keyword">collate</span> charset_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改某个列</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_name <span class="keyword">change</span> column_name column_name 类型（必须字符类型） <span class="built_in">character</span> <span class="keyword">set</span> charset_name <span class="keyword">collate</span> charset_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看字符集</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">database</span> db_name;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">columns</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h1><ol>
<li><p>create table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> TABLE_NAME</span><br><span class="line">  (</span><br><span class="line">    COLUMN_NAME <span class="keyword">type</span></span><br><span class="line">    <span class="keyword">index</span> index_name (COLUMN_NAME)</span><br><span class="line">  )<span class="keyword">engine</span>=xx <span class="keyword">default</span> <span class="keyword">charset</span>=xxx;</span><br></pre></td></tr></table></figure>
</li>
<li><p>create index</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> TABLE_NAME(COLUMN_NAME);（无法创建唯一索引）</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> TABLE_NAME;</span><br></pre></td></tr></table></figure>
</li>
<li><p>alter table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span>/fulltext/<span class="keyword">unique</span>/<span class="keyword">index</span>/ index_name (COLUMN_NAME);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Linux systemd 机制初探</title>
    <url>/2020/04/01/linux/linux_systemd/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#systemd-是啥">systemd 是啥？</a></li>
<li><a href="#为什么是用-systemd-作为开机启动进程">为什么是用 systemd 作为开机启动进程</a></li>
<li><a href="#systemd启动过程">systemd启动过程</a></li>
<li><a href="#systemd使用">systemd使用</a></li>
<li><a href="#systemd定义开机自启动程序">systemd定义开机自启动程序</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="systemd-是啥？"><a href="#systemd-是啥？" class="headerlink" title="systemd 是啥？"></a>systemd 是啥？</h1><ul>
<li><p>systemd 是 Linux 内核发起的第一个程序，并且它还扮演多种角色。它会启动系统服务、处理用户登录.</p>
</li>
<li><h2 id="unit-单元"><a href="#unit-单元" class="headerlink" title="unit 单元"></a>unit 单元</h2><ol>
<li><p>systemd的核心是一个叫单元 unit的概念，它是一些存有关于服务service（在运行在后台的程序）、设备、挂载点、和操作系统其他方面信息的配置文件。</p>
</li>
<li><p>在/usr/lib/systemd/system下有许多，server，其中包括要被运行的二进制文件（“ExecStart”那一行），相冲突的其他单元（即不能同时进入运行的单元），以及需要在本单元执行前进入运行的单元（“After”那一行）。一些单元有附加的依赖选项，例如“Requires”（必要的依赖）和“Wants”（可选的依赖）。</p>
<p><img src="http://study.jeffqi.cn/linux/systemd_service.jpg" alt="systemd_service"></p>
</li>
</ol>
</li>
<li><h2 id="target-目标"><a href="#target-目标" class="headerlink" title="target 目标"></a>target 目标</h2><ol>
<li><p>启动目标 target是一种将多个单元聚合在一起以致于将它们同时启动的方式。</p>
</li>
<li><p>一个服务会通过 WantedBy 选项让自己成为启动目标的依赖</p>
</li>
<li><p>文本模式的 multi-user.target 类似于源init启动的第3运行级，graphical.target 类似于第5运行级，reboot.target 类似于第6运行级，诸如此类。</p>
<p><img src="http://study.jeffqi.cn/linux/systemd_multi-user_target.jpg" alt="systemd_multi-user_target"></p>
</li>
</ol>
</li>
</ul>
<h1 id="为什么是用-systemd-作为开机启动进程"><a href="#为什么是用-systemd-作为开机启动进程" class="headerlink" title="为什么是用 systemd 作为开机启动进程"></a>为什么是用 systemd 作为开机启动进程</h1><ul>
<li><h2 id="init进程"><a href="#init进程" class="headerlink" title="init进程"></a>init进程</h2><ol>
<li><p>内核记载完成后会马上查找/sbin下的“init”程序并执行它。从这里开始init成为了Linux系统的父进程。init读取的第一个文件是/etc/inittab，通过它init会确定我们Linux操作系统的运行级别。它会从文件/etc/fstab里查找分区表信息然后做相应的挂载。然后init会启动/etc/init.d里指定的默认启动级别的所有服务/脚本。所有服务在这里通过init一个一个被初始化。关机过程差不多是相反的过程，首先init停止所有服务，最后阶段会卸载文件系统。</p>
</li>
<li><p>Linux系统的启动方式有点复杂，而且总是有需要优化的地方。传统的Linux系统启动过程主要由著名的init进程（也被称为SysV init启动系统）处理，而基于init的启动系统被认为有效率不足的问题，程序启动时串行化的，init每次只启动一个服务，所有服务/守护进程都在后台执行并由init来管理。</p>
</li>
</ol>
</li>
<li><h2 id="systemd进程"><a href="#systemd进程" class="headerlink" title="systemd进程"></a>systemd进程</h2><ol>
<li><p>systemd能够更快地启动，更简单地管理那些有依赖的服务程序，提供强大且安全的日志系统等。</p>
</li>
<li><p>主要是引入了并行启动的概念。它会为每个需要启动的守护进程建立一个套接字，这些套接字对于使用它们的进程来说是抽象的，这样它们可以允许不同守护进程之间进行交互。Systemd会创建新进程并为每个进程分配一个控制组（cgroup）。处于不同控制组的进程之间可以通过内核来互相通信。</p>
</li>
</ol>
</li>
<li><h2 id="systemd对于init的优化"><a href="#systemd对于init的优化" class="headerlink" title="systemd对于init的优化"></a>systemd对于init的优化</h2><ol>
<li>和init比起来引导过程简化了很多</li>
<li>Systemd支持并发引导过程从而可以更快启动</li>
<li>通过控制组来追踪进程，而不是PID</li>
<li>优化了处理引导过程和服务之间依赖的方式</li>
<li>支持系统快照和恢复</li>
<li>监控已启动的服务；也支持重启已崩溃服务</li>
<li>包含了systemd-login模块用于控制用户登录</li>
<li>支持加载和卸载组件</li>
<li>低内存使用痕迹以及任务调度能力</li>
<li>记录事件的Journald模块和记录系统日志的syslogd模块</li>
</ol>
</li>
</ul>
<h1 id="systemd启动过程"><a href="#systemd启动过程" class="headerlink" title="systemd启动过程"></a>systemd启动过程</h1><ol>
<li><p>BIOS加电自检</p>
</li>
<li><p>开始grub引导内核加入</p>
</li>
<li><p><strong>启动systemd进程</strong></p>
<ol>
<li><p>default.target：实际上default.target是指向graphical.target的软链接。 文件Graphical.target的实际位置是/usr/lib/systemd/system/graphical.target。在这个阶段，会启动multi-user.target</p>
<p><img src="http://study.jeffqi.cn/linux/systemd_graphical_target.jpg" alt="systemd_graphical_target"></p>
</li>
<li><p>multi-user.target：这个target将自己的子单元放在目录“/etc/systemd/system/multi-user.target.wants”里。这个target为多用户支持设定系统环境。非root用户会在这个阶段的引导过程中启用。防火墙相关的服务也会在这个阶段启动。”multi-user.target”会将控制权交给另一层“basic.target”。</p>
<p><img src="http://study.jeffqi.cn/linux/systemd_graphical_target.jpg" alt="systemd_multi-user_target"></p>
</li>
<li><p>basic.target：用于启动普通服务特别是图形管理服务。它通过/etc/systemd/system/basic.target.wants目录来决定哪些服务会被启动，basic.target之后将控制权交给sysinit.target。</p>
<p><img src="http://study.jeffqi.cn/linux/systemd_basic_target.jpg" alt="systemd_basic_target"></p>
</li>
<li><p>sysinit.target:启动重要的系统服务例如系统挂载，内存交换空间和设备，内核补充选项等等。sysinit.target在启动过程中会传递给local-fs.target。</p>
<p> <img src="http://study.jeffqi.cn/linux/systemd_sysinit_target.jpg" alt="systemd_sysinit_target"></p>
</li>
<li><p>local-fs.target，这个target单元不会启动用户相关的服务，它只处理底层核心服务。这个target会根据/etc/fstab和/etc/inittab来执行相关操作。</p>
<p> <img src="http://study.jeffqi.cn/linux/systemd_local-fs_target.jpg" alt="systemd_local-fs_target"></p>
</li>
</ol>
</li>
</ol>
<h1 id="systemd使用"><a href="#systemd使用" class="headerlink" title="systemd使用"></a>systemd使用</h1><ul>
<li><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>  systemctl 是与 Systemd 交互的主要工具</p>
<p>  启用与禁止服务：可以使用<strong>下面的命令</strong>：这种做法会为该单元创建一个符号链接，并将其放置在当前启动目标的 .wants 目录下，这些 .wants 目录在/etc/systemd/system 文件夹中。</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span>/<span class="built_in">disable</span> xxx.service</span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/linux/systemd_enable_disable_service_unite.jpg" alt="systemd_enable_disable_service_unite"></p>
<p>  服务运行与停止：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start/restart/stop xxx.service</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="timer定时器单元"><a href="#timer定时器单元" class="headerlink" title="timer定时器单元"></a>timer定时器单元</h2><p>  <strong>取代cron</strong>：在很大程度上，它能够完成 cron 的工作，而且可以说是以更灵活的方式（并带有更易读的语法）。cron 是一个以规定时间间隔执行任务的程序——例如清除临时文件，刷新缓存等。</p>
<p>  <img src="http://study.jeffqi.cn/linux/systemd_timer_unit.jpg" alt="systemd_timer_unit"></p>
</li>
<li><h2 id="journal日志文件"><a href="#journal日志文件" class="headerlink" title="journal日志文件"></a>journal日志文件</h2><p>  <strong>缺点</strong>：这是个<strong>二进制日志</strong>，因此您不能使用常规的命令行文本处理工具来解析它；<br>  <strong>优点</strong>：日志可以被更系统地组织，带有更多的元数据，因此可以更容易地根据可执行文件名和进程号等过滤出信息。</p>
<p>  查看日志：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">journalctl</span><br><span class="line"><span class="comment"># -b:至那一次启动以来的日志，默认为0最近一次启动以来，-1为上一次启动</span></span><br><span class="line"><span class="comment"># --since=”2020-04-24 16:38”:至那个时间点以来的日志</span></span><br><span class="line"><span class="comment"># -u mysql.service：某一个服务的日志</span></span><br><span class="line"><span class="comment"># _PID=890：某一个进程的日志</span></span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/linux/systemd_journalctl.jpg" alt="systemd_journalctl"></p>
</li>
</ul>
<h1 id="systemd定义开机自启动程序"><a href="#systemd定义开机自启动程序" class="headerlink" title="systemd定义开机自启动程序"></a>systemd定义开机自启动程序</h1><ul>
<li><h2 id="服务权限"><a href="#服务权限" class="headerlink" title="服务权限"></a>服务权限</h2><p>  systemd有系统和用户区分；系统（/user/lib/systemd/system/）、用户（/etc/lib/systemd/user/）。一般系统管理员手工创建的单元文件建议存放在/etc/systemd/system/目录下面。</p>
</li>
<li><h2 id="xxx-service-文件"><a href="#xxx-service-文件" class="headerlink" title="xxx.service 文件"></a>xxx.service 文件</h2><ol>
<li><p>实例nginx为例子</p>
<p><img src alt="systemd_service_start"></p>
</li>
<li><p>参数参考</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description : 服务的简单描述</span><br><span class="line">Documentation ： 服务文档</span><br><span class="line">Before、After:定义启动顺序。Before=xxx.service,代表本服务在xxx.service启动之前启动。After=xxx.service,代表本服务在xxx.service之后启动。</span><br><span class="line">Requires：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。</span><br><span class="line">Wants：推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=simple（默认值）：systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。</span><br><span class="line">Type=forking：systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 PIDFile=，以便systemd能够跟踪服务的主进程。</span><br><span class="line">Type=oneshot：这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 RemainAfterExit=yes 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。</span><br><span class="line">Type=notify：与 Type=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。</span><br><span class="line">Type=dbus：若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。</span><br><span class="line">Type=idle: systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和Type=simple 类似。</span><br><span class="line">PIDFile：pid文件路径</span><br><span class="line">ExecStart：指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。Type=oneshot允许指定多个希望顺序执行的用户自定义命令。</span><br><span class="line">ExecReload：指定单元停止时执行的命令或者脚本。</span><br><span class="line">ExecStop：指定单元停止时执行的命令或者脚本。</span><br><span class="line">PrivateTmp：True表示给服务分配独立的临时空间</span><br><span class="line">Restart：这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。</span><br><span class="line">RemainAfterExit：如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在Type=oneshot时需要被配置。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Install]</span><br><span class="line">Alias：为单元提供一个空间分离的附加名字。</span><br><span class="line">RequiredBy：单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。</span><br><span class="line">WantBy：单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。</span><br><span class="line">Also：指出和单元一起安装或者被协助的单元。</span><br><span class="line">DefaultInstance：实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加完成后可看看笔记前面systemctl使用方法</p>
</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://linux.cn/article-5457-1.html" target="_blank" rel="noopener">走进Linux之systemd启动过程</a></li>
<li><a href="https://linux.cn/article-6888-1.html" target="_blank" rel="noopener">systemd教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL组复制</title>
    <url>/2020/03/29/mysql/mysql_group_replication/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#group-replication组复制基础">group replication（组复制基础）</a></li>
<li><a href="#实验">实验</a><ul>
<li><a href="#配置文件">配置文件</a></li>
<li><a href="#创建用于复制的用户">创建用于复制的用户</a></li>
<li><a href="#重启服务检查组复制插件是否加载">重启服务检查组复制插件是否加载</a></li>
<li><a href="#自举组启动并检查">自举组启动并检查</a></li>
<li><a href="#其他节点加入">其他节点加入</a></li>
</ul>
</li>
<li><a href="#验证">验证</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="group-replication（组复制基础）"><a href="#group-replication（组复制基础）" class="headerlink" title="group replication（组复制基础）"></a>group replication（组复制基础）</h1><ul>
<li><h2 id="what-is-组复制"><a href="#what-is-组复制" class="headerlink" title="what is 组复制"></a>what is 组复制</h2><p>  组复制是一种可用于实施容错系统的技术。<strong>复制组是一组服务器，每个服务器都有自己的完整数据副本（无共享复制方案），并通过消息传递相互交互</strong>。</p>
<p>  MySQL组复制建立在这些属性和抽象之上，并在所有复制协议中实现<strong>多主机更新</strong>。<strong>一个复制组由多个服务器组成</strong>，该组中的每个服务器可以随时独立执行事务。但是，<strong>所有读写事务仅在获得组批准后才提交</strong>。换句话说，对于任何读写事务，该组都需要决定是否提交，因此提交操作不是来自原始服务器的单方面决定。<strong>只读事务不需要组内的协调并立即提交</strong>。</p>
<p>  当读写事务准备好在原始服务器上提交时，服务器自动广播写值（已更改的行）和相应的write set（已更新的行的唯一标识符）。<strong>事务是通过原子广播发送，因此该组中的所有服务器要么全部收到，要不都收不到</strong>。</p>
<p>  <img src="http://study.jeffqi.cn/mysql/group-replication-process.png" alt="group-replication-process"></p>
</li>
<li><h2 id="传统主从复制提交流程"><a href="#传统主从复制提交流程" class="headerlink" title="传统主从复制提交流程"></a>传统主从复制提交流程</h2><ul>
<li><p>异步复制<br><img src="http://study.jeffqi.cn/mysql/async-replication-process.png" alt="async-replication-process"></p>
</li>
<li><p>半同步复制<br><img src="http://study.jeffqi.cn/mysql/semisync-replication-process.png" alt="semisync-replication-process"></p>
</li>
</ul>
</li>
<li><h2 id="组复制有什么用"><a href="#组复制有什么用" class="headerlink" title="组复制有什么用"></a>组复制有什么用</h2><p>  通过组复制，可以通过将系统状态复制到一组服务器来创建具有冗余的容错系统。即使某些服务器随后发生故障，只要不是全部或大多数，该系统仍然可用。</p>
</li>
<li><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li><p>弹性复制：需要非常流畅的复制基础结构的环境，其中服务器的数量必须动态增加或减少，并且副作用要尽可能少。例如，用于云的数据库服务。</p>
</li>
<li><p>高度可用的分片：分片是实现写入横向扩展的一种流行方法。使用MySQL组复制来实现高度可用的分片，其中每个分片都映射到一个复制组。</p>
</li>
<li><p>主从复制的替代方法：在某些情况下，使用单个主服务器使其成为单个竞争点。在某些情况下，写给整个小组可能会更具扩展性。</p>
</li>
<li><p>自治系统：另外，您可以纯粹为复制协议中内置的自动化功能部署MySQL组复制。</p>
</li>
</ol>
</li>
<li><h2 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h2><ul>
<li><p>组复制的工作模式由参数 group_replication_single_primary_mode 来决定</p>
</li>
<li><p>on：单主模式</p>
</li>
<li><p>off：多主模式</p>
</li>
<li><p><strong>所有的成员的模式必须相同且组复制工作室不可修改；可以通过group_replication_switch_to_single_primary_mode()和 group_replication_switch_to_multi_primary_mode()函数来动态切换状态。</strong></p>
<p><img src="http://study.jeffqi.cn/mysql/group_replication_work_status.jpg" alt="group_replication_work_status"></p>
</li>
</ul>
</li>
</ul>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>mysql配置文件，master与slave不同在与server-id，和通信地址  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 组复制适用于innodb，所以使用其他的存储引擎可能会出现以外</span></span><br><span class="line">disabled_storage_engines=<span class="string">"MyISAM,BLACKHOLE,FEDERATED,ARCHIVE,MEMORY"</span></span><br><span class="line"></span><br><span class="line">server_id=x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本机配置，开启gtid</span></span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将二进制日志校验和关闭，不写入日志</span></span><br><span class="line">binlog_checksum=NONE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制日志格式设置，名称，格式</span></span><br><span class="line">log_bin=binlog</span><br><span class="line"><span class="built_in">log</span>-index=binlog.index</span><br><span class="line">binlog_format=ROW</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从服务器将应用的relay-log语句写入本地的二进制日志中</span></span><br><span class="line">log_slave_updates=ON</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地的中继日志</span></span><br><span class="line">relay-log=relay-log</span><br><span class="line">relay-log-index=relay-log.index</span><br><span class="line"></span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动自动添加group_replication.so插件，如果配置文件中没有，在启动时性需要手动安装</span></span><br><span class="line">plugin_load_add=<span class="string">'group_replication.so'</span>    <span class="comment"># 登入mysq&gt;&gt;&gt;INSTALL PLUGIN group_replication SONAME 'group_replication.so';</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指明当前服务器不是引导组，在第一次开启组的时候需要将这个配置设置为on，完成后需要恢复为off</span></span><br><span class="line">group_replication_bootstrap_group=off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组复制的uuid，全局唯一，可以使用select UUID() 生成的 uuid</span></span><br><span class="line">group_replication_group_name=<span class="string">"UUID"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以off指示插件在服务器启动时不自动启动操作。当你配置完成服务器后可以通过手工开启组服务器</span></span><br><span class="line">group_replication_start_on_boot=off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组复制内部通信使用的ip地址和端口，不可以与提供服务的端口冲突（port配置参数的端口）</span></span><br><span class="line">group_replication_local_address= <span class="string">"s1:33061"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 组复制种子成员的ip地址与端口</span></span><br><span class="line">group_replication_group_seeds= <span class="string">"s1:33061,s2:33061,s3:33061"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指明为每个事物收集 write set 并使用 XXHASH64 进行hash</span></span><br><span class="line">transaction_write_set_extraction=XXHASH64</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建用于复制的用户"><a href="#创建用于复制的用户" class="headerlink" title="创建用于复制的用户"></a>创建用于复制的用户</h2><ul>
<li>需要创建用于组复制的用户，并分配相应的权限，然后指向复制组  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> sql_log_bin=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'repl'</span>@<span class="string">'192.168.80.%'</span> <span class="keyword">identified</span> <span class="keyword">WITH</span> <span class="string">'mysql_native_password'</span> <span class="keyword">BY</span> <span class="string">'Hjqme525+'</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">replication</span> <span class="keyword">slave</span>, <span class="keyword">replication</span> <span class="keyword">client</span>, backup_admin <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'repl'</span>@<span class="string">'192.168.80.%'</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br><span class="line"><span class="keyword">set</span> sql_log_bin=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span></span><br><span class="line">master_user=<span class="string">'repl'</span>,</span><br><span class="line">master_password=<span class="string">'Hjqme525+'</span> <span class="keyword">for</span> channel <span class="string">'group_replication_recovery'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重启服务检查组复制插件是否加载"><a href="#重启服务检查组复制插件是否加载" class="headerlink" title="重启服务检查组复制插件是否加载"></a>重启服务检查组复制插件是否加载</h2><ul>
<li><p>通过过检查是否成功加载 group_replication 组复制插件；文章末尾有验证图；可在每个服务器服务启动后检查。</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看组复制插件</p>
</li>
</ul>
<h2 id="自举组启动并检查"><a href="#自举组启动并检查" class="headerlink" title="自举组启动并检查"></a>自举组启动并检查</h2><ul>
<li>group_replication_bootstrap_group 系统变量来引导组；自检组角色为 primary，其他节点为 secondary。验证图中有结果。  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只有自举组才需要暂时开启这一步，开启引导组时才需要</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> group_replication_bootstrap_group=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">start</span> group_replication;</span><br><span class="line"><span class="comment"># 开启后关闭</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> group_replication_bootstrap_group=<span class="keyword">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询是否加入到组中</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> performance_schema.replication_group_members;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="其他节点加入"><a href="#其他节点加入" class="headerlink" title="其他节点加入"></a>其他节点加入</h2><ul>
<li><p>配置文件需要修改server-id与group_replication_local_address</p>
</li>
<li><p>重启检查插件，创建组复制用户，分配权限，指向复制组</p>
</li>
<li><p>加入组中</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> group_replication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> performance_schema.replication_group_members;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><ul>
<li><p><strong>是否成功加载插件</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/group_replication_show_plugins.jpg" alt="group_replication_show_plugins"></p>
</li>
<li><p><strong>节点是否加入到组中，并查看其优先级</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/group_replication_select_replication_group_members.jpg" alt="group_replication_select_replication_group_members"></p>
</li>
<li><p><strong>主服务器操作</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/group_replication_node2_create_database_table.jpg" alt="group_replication_node2_create_database_table"><br>  <img src="http://study.jeffqi.cn/mysql/group_replication_master_show_binlog.jpg" alt="group_replication_master_show_binlog"></p>
</li>
<li><p><strong>从服务器操作验证</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/group_replication_slave_status.jpg" alt="group_replication_slave_status"><br>  <img src="http://study.jeffqi.cn/mysql/group_replication_show_databases.jpg" alt="group_replication_show_databases"><br>  <img src="http://study.jeffqi.cn/mysql/group_replication_select_table.jpg" alt="group_replication_select_table"><br>  <img src="http://study.jeffqi.cn/mysql/group_replication_slave_mysqlbinlog_relay_log.jpg" alt="group_replication_slave_mysqlbinlog_relay_log"><br>  <img src="http://study.jeffqi.cn/mysql/group_replication_slave_mysqlbinlog_relay_log_2.jpg" alt="group_replication_slave_mysqlbinlog_relay_log_2"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL GTID</title>
    <url>/2020/03/28/mysql/mysql_gtid/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#gtid">gtid</a></li>
<li><a href="#gtid集合">gtid集合</a></li>
<li><a href="#gtid主从自动定位">gtid主从自动定位</a></li>
<li><a href="#基于gtid的主从复制">基于gtid的主从复制</a></li>
<li><a href="#使用gtid的限制">使用gtid的限制</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="gtid"><a href="#gtid" class="headerlink" title="gtid"></a>gtid</h1><ul>
<li><p>全局事务标识符（GTID）是创建的唯一标识符，并且与在源服务器（主服务器）上提交的每个事务相关联。该标识符不仅对于它起源的服务器是唯一的，而且在给定复制拓扑中的所有服务器上也是唯一的。</p>
</li>
<li><p>GTID<strong>单调递增</strong>，生成的数字之间没有间隙。如果将客户端<strong>事务提交</strong>到主服务器上，则将为其<strong>分配一个新的GTID</strong>，前提是该事务已写入二进制日志中。事务失败也会保留GTID</p>
</li>
<li><p>GTID的自动跳过功能意味着在主服务器上提交的事务只能在从服务器上应用一次。</p>
</li>
<li><p>GTID格式</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">GTID = source_id:transaction_id</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="gtid集合"><a href="#gtid集合" class="headerlink" title="gtid集合"></a>gtid集合</h1><ul>
<li><p>GTID集是包括一个或多个单个GTID或一系列GTID的集</p>
</li>
<li><p>MySQL系统表 mysql.gtid_executed 用于保留MySQL服务器上应用的所有事务的已分配GTID，但存储在当前活动的二进制日志文件中的事务除外；该表记录和GTID的状态。保证GTID的值记录。使用 reset master 会清空该表</p>
<p>  <img src="http://study.jeffqi.cn/mysql/gtid_executed.jpg" alt="gtid_executed"></p>
</li>
</ul>
<h1 id="gtid主从自动定位"><a href="#gtid主从自动定位" class="headerlink" title="gtid主从自动定位"></a>gtid主从自动定位</h1><ul>
<li><p>在主从复制中可以通过gtid来进行日志的自动定位；无需再指定日志的偏移量</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">change</span> <span class="keyword">master</span> <span class="keyword">to</span></span><br><span class="line">  ...</span><br><span class="line">  master_auto_position</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/mysql/gtid_in_binlog.jpg" alt="gtid_in_binlog"></p>
</li>
</ul>
<h1 id="基于gtid的主从复制"><a href="#基于gtid的主从复制" class="headerlink" title="基于gtid的主从复制"></a>基于gtid的主从复制</h1><ol>
<li><p>同时开启只读模式，让从库追上主库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> @@GLOBAL.read_only = <span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭主从服务器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqladmin -uusername -p shutdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置文件启动</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">gtid_mode=on</span><br><span class="line">enforce_gtid_consistency=on</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置主从复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span></span><br><span class="line">  MASTER_HOST = host,</span><br><span class="line">  MASTER_PORT = port,</span><br><span class="line">  MASTER_USER = <span class="keyword">user</span>,</span><br><span class="line">  MASTER_PASSWORD = <span class="keyword">password</span>,</span><br><span class="line">  MASTER_AUTO_POSITION = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置从库只读，启动复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@GLOBAL.read_only=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳过某个事物</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> GTID_NEXT=<span class="string">'aaa-bbb-ccc-ddd:N'</span>;</span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">SET</span> GTID_NEXT=<span class="string">'AUTOMATIC'</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="使用gtid的限制"><a href="#使用gtid的限制" class="headerlink" title="使用gtid的限制"></a>使用gtid的限制</h1><ul>
<li><p><strong>涉及非事务性存储引擎的更新</strong>：在同一事务中对使用非事务性存储引擎的表的更新与对使用事务性存储引擎的表的更新混合在一起可能导致将多个GTID分配给同一事务。</p>
</li>
<li><p>CREATE TABLE … SELECT语句：CREATE TABLE … SELECT使用基于GTID的复制时，不允许使用这些语句</p>
</li>
<li><p>临时表：使用GTID（即，将系统变量设置为）时，事务，过程，函数和触发器内部不支持CREATE TEMPORARY TABLEand DROP TEMPORARY TABLE语句 。</p>
</li>
<li><p>跳过交易：sql_slave_skip_counter使用GTID时不支持。如果需要跳过事务，请改用master gtid_executed变量的值 。跳过空事务</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>从删库到跑路到恢复数据</title>
    <url>/2020/03/28/mysql/mysql_drop_data_repair/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#删数据情况">删数据情况</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="删数据情况"><a href="#删数据情况" class="headerlink" title="删数据情况"></a>删数据情况</h1><ol>
<li><p>使用 <strong>delete</strong> 语句误删数据行；</p>
</li>
<li><p>使用 <strong>drop table</strong> 或者 <strong>truncate table</strong> 语句误删数据表；</p>
</li>
<li><p>使用 <strong>drop database</strong> 语句误删数据库；</p>
</li>
<li><p>使用 <strong>rm</strong> 命令误删整个 MySQL 实例。</p>
<ul>
<li><h2 id="删除行数据"><a href="#删除行数据" class="headerlink" title="删除行数据"></a>删除行数据</h2><p>在进行dml操作后，如果意外的更新删除了错误的数据可以使用flashback工具进行恢复</p>
<p><a href="https://mariadb.com/kb/en/flashback/" target="_blank" rel="noopener">flashback工具</a></p>
<p><strong>当前仅在DML语句（INSERT，DELETE，UPDATE）上支持闪回</strong>。即将发布的MariaDB版本将通过将当前表复制或移动到保留和隐藏的数据库，然后在使用闪回时复制或移回来增加对DDL语句（DROP，TRUNCATE，ALTER)支持。</p>
<p><strong>flashback只适用于row格式日志和full记录</strong></p>
<pre><code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">binlog_format=row</span><br><span class="line">binlog_row_image=full</span><br></pre></td></tr></table></figure></code></pre><p><img src="http://study.jeffqi.cn/mysql/flashback_row_full.jpg" alt="flashback_row_full.jpg"></p>
<p><strong>工作机制</strong>：flash的实际工作由mysqlbinlog与–flashback一起完成。这将导致事件被转换：从INSERT到DELETE，从DELETE到INSERT，并且对于UPDATE，交换之前和之后的图像。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysqlbinlog /path/to/binlog -vv -d db_name -T table_name \</span><br><span class="line">--start-datetime <span class="string">'2020-02-03 17:00:00'</span> --flashback &gt; flash.sql</span><br><span class="line">mysql &lt; flash.sql</span><br></pre></td></tr></table></figure>

<p>避免数据的误操作，我们急需做的是预防；</p>
<pre><code>1.  sql_safe_updates 参数设置为 on；对于语句进行检查，需要添加where才能使用
2.  上线前对sql进行审计</code></pre></li>
<li><h2 id="误删表-库"><a href="#误删表-库" class="headerlink" title="误删表/库"></a>误删表/库</h2><p>使用全量备份，加增量日志；<strong>这个方案要求线上有定期的全量备份，并且实时备份 binlog</strong>。</p>
<ol>
<li>取最近一次全量备份，假设这个库是一天一备，上次备份是当天 0 点；</li>
<li>用备份恢复出一个临时库；从日志备份里面，取出凌晨 0 点之后的日志；</li>
<li>把这些日志，除了误删除数据的语句外，全部应用到临时库。</li>
</ol>
<p><img src="http://study.jeffqi.cn/mysql/data_repair_after_drop_tables_or_databases.png" alt="data_repair_after_drop_tables_or_databases"></p>
<ul>
<li><p>可以在使用 mysqlbinlog 命令时，加上一个–database 参数，用来指定误删表所在的库。避免在恢复数据时还要应用其他库日志的情况。</p>
</li>
<li><p>使用-stop-position与-start-position来跳过误操作；或者使用GTID方案</p>
</li>
<li><p><strong>加速恢复</strong>：在用备份恢复出临时实例之后，将这个临时实例设置成线上备库的从库；在 start slave 之前，先通过执行﻿﻿change replication filter replicate_do_table = (tbl_name) 命令，就可以让临时库只同步误操作的表；这样做也可以用上并行复制技术，来加速整个数据恢复过程。（需要注意可能备库上没有需要的增量日志需要从备库系统下载，然后添加日志信息到master.index中，让数据库能够识别）</p>
</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/data_repair_use_replecation.png" alt="data_repair_use_replecation.png"></p>
</li>
<li><h2 id="延迟复制备库"><a href="#延迟复制备库" class="headerlink" title="延迟复制备库"></a>延迟复制备库</h2><p>延迟复制的备库是一种特殊的备库，通过 CHANGE MASTER TO MASTER_DELAY = N 命令，可以指定这个备库持续保持跟主库有 N 秒的延迟。</p>
</li>
<li><h2 id="rm-删除数据"><a href="#rm-删除数据" class="headerlink" title="rm 删除数据"></a>rm 删除数据</h2><p>集群就是做一个高可用只要不是删除了集群这个数据库的信息HA就能够工作选出新的主库</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高可用方案</title>
    <url>/2020/03/27/linux/hight_access/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#用户可感知高可用方案">用户可感知高可用方案</a></li>
<li><a href="#对用户透明高可用方案">对用户透明高可用方案</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="用户可感知高可用方案"><a href="#用户可感知高可用方案" class="headerlink" title="用户可感知高可用方案"></a>用户可感知高可用方案</h1><ul>
<li>客户可感知的高可用，需要配合客户端使用；<strong>客户端自己去确认服务器的变更并切换访问的目标</strong>。如果感知到主服务器挂掉，客户端自己来切换到备份服务器上。这样对于服务器来说是有风险的，不能很好地隐藏</li>
</ul>
<h1 id="对用户透明高可用方案"><a href="#对用户透明高可用方案" class="headerlink" title="对用户透明高可用方案"></a>对用户透明高可用方案</h1><ul>
<li>对用户透明的高可用，是服务器端自己来进行切换；用户不需要知道这个切换过程。主要方式有两种：<strong>1. 客户端访问域名访问主机，监控主机下线后，将域名分配给备用服务器</strong>。这需要一定的时间成本；<strong>2. 客户端访问ip地址访问服务器，监控到主机下线后通过虚拟ip地址漂移，将vip给备用服务器使用，让备用服务器来对外提供服务</strong>。这样更加及时；后者如keepalive双机热备</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="http://tech.it168.com/a2018/0830/5012/000005012656.shtml" target="_blank" rel="noopener">高可用方案实现</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL存储引擎</title>
    <url>/2020/03/27/mysql/MySQL_storage_engine/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#myisam引擎">myisam引擎</a></li>
<li><a href="#innodb引擎">innodb引擎</a></li>
<li><a href="#myisam与innodb对比">myisam与innodb对比</a><ul>
<li><a href="#事务性">事务性</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="myisam引擎"><a href="#myisam引擎" class="headerlink" title="myisam引擎"></a>myisam引擎</h1><h1 id="innodb引擎"><a href="#innodb引擎" class="headerlink" title="innodb引擎"></a>innodb引擎</h1><h1 id="myisam与innodb对比"><a href="#myisam与innodb对比" class="headerlink" title="myisam与innodb对比"></a>myisam与innodb对比</h1><h2 id="事务性"><a href="#事务性" class="headerlink" title="事务性"></a>事务性</h2><ul>
<li><p><strong>事务</strong>：MyISAM不支持事务，InnoDB是事务类型的存储引擎</p>
</li>
<li><p><strong>锁机制</strong>：MyISAM只支持<strong>表级锁</strong>，BDB支持页级锁和表级锁默认为<strong>页级锁</strong>，而InnoDB支持行级锁和表级锁默认为<strong>行级锁</strong></p>
<ul>
<li>innodb锁加载索引上，<a href="http://www.jeffqi.cn/2020/02/12/mysql/MySQL_lock/" target="_blank" rel="noopener">加锁规则</a>；</li>
</ul>
</li>
<li><p><strong>外键</strong>：MyISAM引擎不支持外键，InnoDB支持外键</p>
</li>
<li><p>MyISAM引擎的表在大量高并发的读写下会经常出现表损坏的情况；相比于innodb来说更加脆弱</p>
<ul>
<li>修复：Mysql自带的myisamchk工具： myisamchk -r tablename  或者 myisamchk -o tablename（比前者更保险） 对表进行修复</li>
</ul>
</li>
<li><p>对于count函数的支持，myisam有单独的计数，比innodb更快</p>
</li>
<li><p>myisam支持fulltext全文索引，innodb无</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP性能</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_9/%E5%9B%BE%E8%A7%A3HTTP_9/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#基于http-的功能追加协议">基于HTTP 的功能追加协议</a><ul>
<li><a href="#http瓶颈">http瓶颈</a></li>
<li><a href="#解决方法">解决方法</a><ul>
<li><a href="#ajax">Ajax</a></li>
<li><a href="#comet">Comet</a></li>
<li><a href="#spdy">SPDY</a></li>
</ul>
</li>
<li><a href="#全双工通信的-websocket">全双工通信的 WebSocket</a><!-- TOC END -->
<a id="more"></a>
<h1 id="基于HTTP-的功能追加协议"><a href="#基于HTTP-的功能追加协议" class="headerlink" title="基于HTTP 的功能追加协议"></a>基于HTTP 的功能追加协议</h1></li>
</ul>
</li>
</ul>
<h2 id="http瓶颈"><a href="#http瓶颈" class="headerlink" title="http瓶颈"></a>http瓶颈</h2><ul>
<li>原因<ol>
<li>一条连接上只可发送一个请求</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令。</li>
<li>请求/ 响应首部未经压缩就发送。首部信息越多延迟越大。</li>
<li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多。</li>
<li>可任意选择数据压缩格式。非强制压缩发送。<br><img src="/2020/03/27/network/图解HTTP_9/图解HTTP_9/9.1.png" alt="http"></li>
</ol>
</li>
</ul>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><ul>
<li>局部Web 页面替换加载的异步通信手段<br><img src="/2020/03/27/network/图解HTTP_9/图解HTTP_9/9.2.png" alt="Ajax"></li>
</ul>
<h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><ul>
<li>通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能</li>
<li>Comet 会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应<br><img src="/2020/03/27/network/图解HTTP_9/图解HTTP_9/9.3.png" alt="Comet"></li>
</ul>
<h3 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h3><ul>
<li><p>以会话层的形式加入，控制对数据的流动<br><img src="/2020/03/27/network/图解HTTP_9/图解HTTP_9/9.4.png" alt="SPDY"></p>
</li>
<li><p>设计</p>
<ol>
<li>多路复用流：通过单一的TCP 连接，可以无限制处理多个HTTP 请求</li>
<li>设置优先级</li>
<li>压缩HTTP首部</li>
<li>推送与服务器提示功能：支持服务器主动向客户端推送数据的功能；服务器可以主动提示客户端请求所需的资源</li>
</ol>
</li>
</ul>
<h2 id="全双工通信的-WebSocket"><a href="#全双工通信的-WebSocket" class="headerlink" title="全双工通信的 WebSocket"></a>全双工通信的 WebSocket</h2><ul>
<li>Web 浏览器与Web 服务器之间全双工通信标准<ol>
<li>推送功能</li>
<li>减少通信量：一直保持连接状态</li>
</ol>
</li>
<li>使用http首部中的upgrade首部字段实现连接<ol>
<li>握手请求</li>
<li>握手响应</li>
</ol>
</li>
<li>通信过程<br><img src="/2020/03/27/network/图解HTTP_9/图解HTTP_9/9.5.png" alt="WebSocket通信"></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP认证</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_8/%E5%9B%BE%E8%A7%A3HTTP_8/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#确认访问用户身份的认证">确认访问用户身份的认证</a><ul>
<li><a href="#http认证方式">http认证方式</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="确认访问用户身份的认证"><a href="#确认访问用户身份的认证" class="headerlink" title="确认访问用户身份的认证"></a>确认访问用户身份的认证</h1><ul>
<li>计算机不能判断使用者的具体身份，需要认证使用</li>
</ul>
<h2 id="http认证方式"><a href="#http认证方式" class="headerlink" title="http认证方式"></a>http认证方式</h2><ol>
<li>BASIC认证（基本认证）</li>
</ol>
<ul>
<li>认证过程<br><img src="/2020/03/27/network/图解HTTP_8/图解HTTP_8/8.1.png" alt="basic"></li>
<li>非加密处理</li>
</ul>
<ol start="2">
<li>DIGEST 认证（摘要认证）</li>
</ol>
<ul>
<li>认证过程<br><img src="/2020/03/27/network/图解HTTP_8/图解HTTP_8/8.2.png" alt="digest"></li>
<li>质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式</li>
</ul>
<ol start="3">
<li>SSL 客户端认证</li>
</ol>
<ul>
<li>借由HTTPS 的客户端证书完成认证的方式</li>
<li>认证过程<ol>
<li>接收到需要认证资源的请求，服务器会发送Certificate Request 报文，要求客户端提供客户端证书</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以Client Certificate 报文方式发送给服务器</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始HTTPS 加密通信</li>
</ol>
</li>
<li>认证采用双因素认证<ul>
<li>采用证书认证和表单认证相结合</li>
<li>第一个认证因素的SSL 客户端证书用来认证客户端计算机，另一个认证因素的密码则用来确定这是用户本人的行为</li>
</ul>
</li>
</ul>
<ol start="4">
<li>FormBase 认证（基于表单认证）</li>
</ol>
<ul>
<li>认证过程<br><img src="/2020/03/27/network/图解HTTP_8/图解HTTP_8/8.3.png" alt="session"><ol>
<li>客户端把用户ID 和密码等登录信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器</li>
<li>服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端</li>
<li>客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS学习</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_7/%E5%9B%BE%E8%A7%A3HTTP_7/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#确保web-安全的https">确保Web 安全的HTTPS</a><ul>
<li><a href="#http缺点">HTTP缺点</a><ul>
<li><a href="#使用明文通信">使用明文通信</a></li>
<li><a href="#不验证通信方的身份就可能遭遇伪装">不验证通信方的身份就可能遭遇伪装</a></li>
<li><a href="#无法证明报文完整性">无法证明报文完整性</a></li>
</ul>
</li>
<li><a href="#https">HTTPS</a><ul>
<li><a href="#https-是身披ssl-外壳的http">HTTPS 是身披SSL 外壳的HTTP</a></li>
<li><a href="#https采用混合加密机制">HTTPS采用混合加密机制</a></li>
<li><a href="#证书">证书</a></li>
<li><a href="#ssl通信慢">SSL通信慢</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="确保Web-安全的HTTPS"><a href="#确保Web-安全的HTTPS" class="headerlink" title="确保Web 安全的HTTPS"></a>确保Web 安全的HTTPS</h1><h2 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h2><ul>
<li>使用明文通信</li>
<li>不验证通信方身份</li>
<li>无法证明报文完整性</li>
</ul>
<h3 id="使用明文通信"><a href="#使用明文通信" class="headerlink" title="使用明文通信"></a>使用明文通信</h3><ul>
<li>HTTP 本身不具备加密的功能，在互联网上传输容易找到窃听</li>
<li>加密处理防止窃听<ol>
<li>通信的加密<ul>
<li>通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP 的通信内容</li>
<li>SSL 建立安全通信线路之后，就可以在这条线路上进行HTTP通信</li>
</ul>
</li>
<li>内容加密<ul>
<li>对传输的内容进行加密</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="不验证通信方的身份就可能遭遇伪装"><a href="#不验证通信方的身份就可能遭遇伪装" class="headerlink" title="不验证通信方的身份就可能遭遇伪装"></a>不验证通信方的身份就可能遭遇伪装</h3><ul>
<li>HTTP任何人都可以访问<ul>
<li>无法确定请求发送至目标的Web 服务器是否是按真实意图返回响应的那台服务器</li>
<li>无法确定客户端就是真实需要返回响应的客户端</li>
<li>无法确认通信的对方的访问权限</li>
<li>无法判定请求来之哪里</li>
<li>容易遭到DoS、DDos攻击</li>
</ul>
</li>
<li>通过查看对方证书来确认</li>
</ul>
<h3 id="无法证明报文完整性"><a href="#无法证明报文完整性" class="headerlink" title="无法证明报文完整性"></a>无法证明报文完整性</h3><ul>
<li>无法确认报文是否被篡改</li>
<li>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><ul>
<li>使用SSL或TSL进行加密认证通信</li>
</ul>
<h3 id="HTTPS-是身披SSL-外壳的HTTP"><a href="#HTTPS-是身披SSL-外壳的HTTP" class="headerlink" title="HTTPS 是身披SSL 外壳的HTTP"></a>HTTPS 是身披SSL 外壳的HTTP</h3><ul>
<li>使用SSL 时，则演变成先和SSL 通信，再由SSL 和TCP 通信</li>
</ul>
<h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><ul>
<li>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</li>
</ul>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><ul>
<li>由可信第三方机构颁发的可信任证明</li>
<li>HTTPS通信<br><img src="/2020/03/27/network/图解HTTP_7/图解HTTP_7/7.9.png" alt="HTTPS通信"><br><img src="/2020/03/27/network/图解HTTP_7/图解HTTP_7/7.10.png" alt="HTTPS通信"></li>
</ul>
<h3 id="SSL通信慢"><a href="#SSL通信慢" class="headerlink" title="SSL通信慢"></a>SSL通信慢</h3><ul>
<li>加密与解密需要占用CPU和其他硬件资源</li>
<li>SSL通信部分会消耗网络资源，增加延迟</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP首部响应字段</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_6/%E5%9B%BE%E8%A7%A3HTTP_6/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#响应首部字段">响应首部字段</a><ul>
<li><a href="#accept-ranges">Accept-Ranges</a></li>
<li><a href="#age">Age</a></li>
<li><a href="#etage">ETage</a></li>
<li><a href="#location">Location</a></li>
<li><a href="#proxy-authenticate">Proxy-Authenticate</a></li>
<li><a href="#retry-after">Retry-After</a></li>
<li><a href="#server">Server</a></li>
<li><a href="#vary">Vary</a></li>
<li><a href="#www-authenticate">WWW-Authenticate</a></li>
</ul>
</li>
<li><a href="#实体首部字段">实体首部字段</a><ul>
<li><a href="#allow">Allow</a></li>
<li><a href="#content-encoding">Content-Encoding</a></li>
<li><a href="#content-language">Content-Language</a></li>
<li><a href="#content-length">Content-Length</a></li>
<li><a href="#content-location">Content-Location</a></li>
<li><a href="#content-md5">Content-MD5</a></li>
<li><a href="#content-range">Content-Range</a></li>
<li><a href="#content-type">Content-Type</a></li>
<li><a href="#expires">Expires</a></li>
<li><a href="#last-modified">Last-Modified</a></li>
</ul>
</li>
<li><a href="#为cookie-服务的首部字段">为Cookie 服务的首部字段</a><ul>
<li><a href="#set-cookie">Set-Cookie</a></li>
<li><a href="#cookie">Cookie</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h1><ul>
<li>由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息</li>
</ul>
<h2 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h2><ul>
<li>告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源<ol>
<li>可处理范围请求时指定其为bytes</li>
<li>不能处理则指定其为none</li>
</ol>
</li>
</ul>
<h2 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h2><ul>
<li>告知客户端，源服务器在多久前创建了响应<ol>
<li>创建该响应的服务器是缓存服务器，Age 值是指缓存后的响应再次发起认证到认证完成的时间值</li>
</ol>
</li>
</ul>
<h2 id="ETage"><a href="#ETage" class="headerlink" title="ETage"></a>ETage</h2><ul>
<li>告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式<ol>
<li>当资源更新时，ETag 值也需要更新</li>
<li>强ETag 值和弱Tag 值<ul>
<li>强ETag：细微的变化都会改变其值</li>
<li>弱ETag：只有资源发生了根本改变，产生差异时才会改变ETag 值。字段值最开始处附加W/</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><ul>
<li>将响应接收方引导至某个与请求URI 位置不同的资源</li>
</ul>
<h2 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h2><ul>
<li>把由代理服务器所要求的认证信息发送给客户端</li>
</ul>
<h2 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h2><ul>
<li>告知客户端应该在多久之后再次发送请求</li>
</ul>
<h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><ul>
<li>告知客户端当前服务器上安装的HTTP 服务器应用程序的信息</li>
</ul>
<h2 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h2><ul>
<li>代理服务器接收到带有Vary 首部字段指定获取资源的请求时，如果使用的Accept-Language字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为121响应返回</li>
</ul>
<h2 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h2><ul>
<li>用于HTTP 访问认证<ol>
<li>告知客户端适用于访问请求URI 所指定资源的认证方案（Basic 或是Digest）和带参数提示的质询（challenge）</li>
</ol>
</li>
</ul>
<h1 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h1><ul>
<li>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息</li>
</ul>
<h2 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h2><ul>
<li>通知客户端能够支持Request-URI 指定资源的所有HTTP 方法</li>
</ul>
<h2 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h2><ul>
<li>告知客户端服务器对实体的主体部分选用的内容编码方式</li>
</ul>
<h2 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h2><ul>
<li>告知客户端，实体主体使用的自然语言</li>
</ul>
<h2 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h2><ul>
<li>实体主体部分的大小</li>
</ul>
<h2 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h2><ul>
<li>给出与报文主体部分相对应的URI<ol>
<li>当返回的页面内容与实际请求的对象不同时，首部字段Content-Location内会写明URI</li>
</ol>
</li>
</ul>
<h2 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h2><ul>
<li>检查报文主体在传输过程中是否保持完整，以及确认传输到达</li>
</ul>
<h2 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h2><ul>
<li>告知客户端作为响应返回的实体的哪个部分符合范围请求</li>
</ul>
<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h2><ul>
<li>说明了实体主体内对象的媒体类型</li>
</ul>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><ul>
<li>将资源失效的日期告知客户端</li>
</ul>
<h2 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h2><ul>
<li>指明资源最终修改的时间</li>
</ul>
<h1 id="为Cookie-服务的首部字段"><a href="#为Cookie-服务的首部字段" class="headerlink" title="为Cookie 服务的首部字段"></a>为Cookie 服务的首部字段</h1><h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h2><ul>
<li>当服务器准备开始管理客户端的状态时，会事先告知各种信息<ul>
<li>属性<ol>
<li>expires：指定浏览器可发送Cookie 的有效期</li>
<li>path：用于限制指定Cookie 的发送范围的文件目录</li>
<li>domain：通过Cookie 的domain 属性指定的域名可做到与结尾匹配一致</li>
<li>secure：限制Web 页面仅在HTTPS 安全连接时，才可以发送Cookie</li>
<li>HttpOnly：使JavaScript 脚本无法获得Cookie。防止XSS跨站脚本攻击对cookie的窃取</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><ul>
<li>告知服务器，当客户端想获得HTTP 状态管理支持时，就会在请求中包含从服务器接收到的Cookie</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP请求首部字段</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_5/%E5%9B%BE%E8%A7%A3HTTP_5/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#请求首部字段">请求首部字段</a><ul>
<li><a href="#accept">Accept</a></li>
<li><a href="#accept-charset">Accept-Charset</a></li>
<li><a href="#accept-encoding">Accept-Encoding</a></li>
<li><a href="#accept-language">Accept-Language</a></li>
<li><a href="#authorization">Authorization</a></li>
<li><a href="#proxy-authorization">Proxy-Authorization</a></li>
<li><a href="#expect">Expect</a></li>
<li><a href="#from">From</a></li>
<li><a href="#host">Host</a></li>
<li><a href="#if-match">If-Match</a></li>
<li><a href="#if-none_match">If-None_Match</a></li>
<li><a href="#if-modified-since">If-Modified-Since</a></li>
<li><a href="#if-unmodified-since">If-Unmodified-Since</a></li>
<li><a href="#if-range">If-Range</a></li>
<li><a href="#max-forwards">Max-Forwards</a></li>
<li><a href="#range">Range</a></li>
<li><a href="#refere">Refere</a></li>
<li><a href="#te">TE</a></li>
<li><a href="#user-agent">User-Agent</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h1><ul>
<li>从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容</li>
</ul>
<h2 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h2><ul>
<li>通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级<ol>
<li>使用type/subtype 这种形式，一次指定多种媒体类型</li>
<li>使用q= 来额外表示权重值权重值q 的范围是0~1（可精确到小数点后3 位），且1 为最大值</li>
<li>首先返回权重值最高的媒体类型</li>
</ol>
</li>
</ul>
<h2 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h2><ul>
<li>通知服务器用户代理支持的字符集及字符集的相对优先顺序</li>
</ul>
<h2 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h2><ul>
<li>告知服务器用户代理支持的内容编码及内容编码的优先级顺序<ol>
<li>同accept一样，可有权重</li>
</ol>
</li>
</ul>
<h2 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h2><ul>
<li>告知服务器用户代理能够处理的自然语言集（指中文或英文等）<ol>
<li>有权重</li>
</ol>
</li>
</ul>
<h2 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h2><ul>
<li>告知服务器，用户代理的认证信息（证书值）<ol>
<li>客户端与服务器</li>
</ol>
</li>
</ul>
<h2 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h2><ul>
<li>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息<ol>
<li>客户端与代理服务器</li>
</ol>
</li>
</ul>
<h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><ul>
<li>告知服务器，期望出现的某种特定行为</li>
</ul>
<h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><ul>
<li>告知服务器，期望出现的某种特定行为</li>
</ul>
<h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><ul>
<li>告知服务器，请求的资源所处的互联网主机名和端口号<ol>
<li>唯一一个必须被包含在请求内的首部字段</li>
</ol>
</li>
</ul>
<h2 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h2><ul>
<li>服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求<ol>
<li>ETag：实体标记是与特定资源关联的确定值。资源更新变化后ETag随着改变</li>
<li>服务器会比对If-Match 的字段值和资源的ETag 值，仅当两者一致时，才会执行请求</li>
<li>可以使用星号(*)指定If-Match 的字段值。针对这种情况，服务器将会忽略ETag 的值，只要资源存在就处理请求</li>
</ol>
</li>
</ul>
<h2 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None_Match"></a>If-None_Match</h2><ul>
<li>资源不存在时返回响应，通常用来获取最新的资源</li>
</ul>
<h2 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h2><ul>
<li>如果在If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求</li>
</ul>
<h2 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h2><ul>
<li>告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求</li>
</ul>
<h2 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h2><ul>
<li>告知服务器若指定的IfRange字段值（ETag 值或者时间）和请求资源的ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源</li>
</ul>
<h2 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h2><ul>
<li>以十进制整数形式指定可经过的服务器最大数目</li>
</ul>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><ul>
<li>只需获取部分资源的范围请求<ol>
<li>处理请求后返回范围资源响应</li>
<li>无法处理时，返回全部资源响应</li>
</ol>
</li>
</ul>
<h2 id="Refere"><a href="#Refere" class="headerlink" title="Refere"></a>Refere</h2><ul>
<li>告知服务器请求的原始资源的URI</li>
</ul>
<h2 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h2><ul>
<li>告知服务器客户端能够处理响应的传输编码方式及相对优先级<ol>
<li>用于传输编码</li>
<li>指定伴随trailer 字段的分块传输编码的方式<ul>
<li>需要将trailers赋值给该字段</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h2><ul>
<li>将创建请求的浏览器和用户代理名称等信息传达给服务器</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP首部学习</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_4/%E5%9B%BE%E8%A7%A3HTTP/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#http首部">HTTP首部</a><ul>
<li><a href="#http报文首部">HTTP报文首部</a><ul>
<li><a href="#请求报文">请求报文</a></li>
<li><a href="#响应报文">响应报文</a></li>
</ul>
</li>
<li><a href="#http首部字段">HTTP首部字段</a><ul>
<li><a href="#4类http首部字段类型">4类HTTP首部字段类型</a></li>
<li><a href="#非http11首部字段">非HTTP/1.1首部字段</a></li>
</ul>
</li>
<li><a href="#通用首部字段">通用首部字段</a><ul>
<li><a href="#cache-control">Cache-control</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h1><h2 id="HTTP报文首部"><a href="#HTTP报文首部" class="headerlink" title="HTTP报文首部"></a>HTTP报文首部</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><ol>
<li>组成：方法、URI、HTTP 版本、HTTP 首部字段等</li>
</ol>
<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><ol>
<li>组成：HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段</li>
</ol>
<h2 id="HTTP首部字段"><a href="#HTTP首部字段" class="headerlink" title="HTTP首部字段"></a>HTTP首部字段</h2><h3 id="4类HTTP首部字段类型"><a href="#4类HTTP首部字段类型" class="headerlink" title="4类HTTP首部字段类型"></a>4类HTTP首部字段类型</h3><ol>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ol>
<h3 id="非HTTP-1-1首部字段"><a href="#非HTTP-1-1首部字段" class="headerlink" title="非HTTP/1.1首部字段"></a>非HTTP/1.1首部字段</h3><ol>
<li>端到端首部（End-to-end Header）<ul>
<li>首部会转发给请求/ 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定必须被转发</li>
</ul>
</li>
<li>逐跳首部（Hop-by-hop Header）<ul>
<li>首部只对单次转发有效，会因通过缓存或代理而不再转发</li>
<li>使用hop-by-hop 首部，需提供Connection 首部字段</li>
</ul>
</li>
</ol>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h3><ul>
<li><p>作用：通过指定首部字段Cache-Control 的指令，操作缓存的工作</p>
</li>
<li><p>缓存指令：</p>
<ol>
<li>public<ul>
<li>当指定使用public 指令时，则明确表明其他用户也可利用缓存</li>
</ul>
</li>
<li>private<ul>
<li>当指定private 指令后，响应只以特定的用户作为对象</li>
</ul>
</li>
<li>no-cache<ul>
<li>防止从缓存中返回过期的资源<ol>
<li>客户端将不会接收缓存过的响应。需要将请求转发给源服务器</li>
<li>服务器返回响应包含no-cache指令，则缓存服务器不能对资源进行缓存</li>
</ol>
</li>
<li>no-chche=location<ol>
<li>字段被指定参数值则客户端不能缓存响应报文。无参数值的首部字段可以使用缓存。只能在响应指令中指定该参数</li>
</ol>
</li>
</ul>
</li>
<li>no-store<ul>
<li>暗示请求（和对应的响应）或响应中包含机密信息</li>
<li>no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认后处理资源；no-store才是不进行缓存</li>
<li>该指令规定缓存不能在本地存储请求或响应的任一部分</li>
</ul>
</li>
<li>s-maxage和max-age<ul>
<li>客户端：允许返回过期一定时间的缓存</li>
<li>服务端：一定时间内缓存服务器自己处理缓存，不用向源服务器确认</li>
<li>不同：smaxage指令只适用于供多位用户使用的公共缓存服务器</li>
</ul>
</li>
<li>min-fresh<ul>
<li>要求缓存服务器返回至少还未过指定时间的缓存资源。返回的资源较新</li>
</ul>
</li>
<li>max-stale<ul>
<li>过期的资源还能被接收</li>
</ul>
</li>
<li>only-if-cache<ul>
<li>客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回；否则返回504 gateway timeout状态码</li>
</ul>
</li>
<li>must-revalidate<ul>
<li>必须再次确认返回的响应缓存的有效性</li>
</ul>
</li>
<li>proxy-revalidate<ul>
<li>缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性</li>
</ul>
</li>
<li>no-transform<ul>
<li>缓存都不能改变实体主体的媒体类型</li>
</ul>
</li>
<li>cache-control扩展<ul>
<li>Cache-Control 首部字段本身没有community 这个指令。借助extension tokens 实现了该指令的添加</li>
<li>extension tokens 仅对能理解它的缓存服务器来说是有意义的</li>
</ul>
</li>
</ol>
</li>
<li><p>Connection</p>
<ul>
<li>管理不在转发给代理的首部字段</li>
<li>管理持久连接<ol>
<li>指定Connection 首部字段的值为Keep-Alive</li>
</ol>
</li>
</ul>
</li>
<li><p>Date</p>
<ul>
<li>报文创建时间</li>
</ul>
</li>
<li><p>Pragma</p>
<ul>
<li>客户端会要求所有的中间服务器不返回缓存的资源</li>
<li>属于通用首部字段，但只用在客户端发送的请求中</li>
</ul>
</li>
<li><p>Trailer</p>
<ul>
<li>事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1 版本分块传输编码时</li>
</ul>
</li>
<li><p>Transfer-Encoding</p>
<ul>
<li>定了传输报文主体时采用的编码方式</li>
<li>HTTP/1.1 的传输编码方式仅对分块传输编码有效</li>
</ul>
</li>
<li><p>Upgrand</p>
<ul>
<li>检测HTTP协议及其他协议是否可以使用更高的协议通信</li>
</ul>
</li>
<li><p>Via</p>
<ul>
<li>记录报文的传输路径</li>
</ul>
</li>
<li><p>Warning</p>
<ul>
<li>告知用户一些与缓存相关的问题警告</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_3/%E5%9B%BE%E8%A7%A3HTTP_3/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#返回结果的http-状态码">返回结果的HTTP 状态码</a><ul>
<li><a href="#2xx-成功">2XX 成功</a></li>
<li><a href="#3xx-重定向">3XX 重定向</a></li>
<li><a href="#4xx-客户端错误">4XX 客户端错误</a></li>
<li><a href="#5xx-服务器错误">5XX 服务器错误</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="返回结果的HTTP-状态码"><a href="#返回结果的HTTP-状态码" class="headerlink" title="返回结果的HTTP 状态码"></a>返回结果的HTTP 状态码</h1><ul>
<li>HTTP 状态码负责表示客户端HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li>2XX 的响应结果表明请求被正常处理了<ol>
<li>200 OK<ul>
<li>表示从客户端发来的请求在服务器端被正常处理</li>
</ul>
</li>
<li>204 No Content<ul>
<li>代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分</li>
</ul>
</li>
<li>206 Partial Content<ul>
<li>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求</li>
<li>响应报文中包含由Content-Range 指定范围的实体内容</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求<ol>
<li>301 Moved Permanently（永久重定向）<ul>
<li>表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI</li>
</ul>
</li>
<li>302 Found（零时重定向）<ul>
<li>表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI 访问</li>
</ul>
</li>
<li>303 See Other<ul>
<li>表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源</li>
<li>303 状态码明确表示客户端应当采用GET 方法获取资源</li>
</ul>
</li>
<li>304 Not Modified<ul>
<li>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况</li>
</ul>
</li>
<li>307 Temporary Redirect（临时重定向）<ul>
<li>该状态码与302 Found 有着相同的含义</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li>4XX 的响应结果表明客户端是发生错误的原因所在<ol>
<li>401 Bad Request<ul>
<li>表示请求报文中存在语法错误</li>
</ul>
</li>
<li>401 Unauthorized<ul>
<li>该状态码表示发送的请求需要有通过HTTP认证</li>
</ul>
</li>
<li>403 Forbidden<ul>
<li>表明对请求资源的访问被服务器拒绝了</li>
</ul>
</li>
<li>404 Not Found<ul>
<li>标识服务器上无法找到请求的资源</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li>5XX 的响应结果表明服务器本身发生错误<ol>
<li>500 Internal Server Error<ul>
<li>服务器在执行时发生错误</li>
</ul>
</li>
<li>503 Service Unavailable<ul>
<li>服务器暂时处于超负载或正在进行停机维护</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP报文简介</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_2/%E5%9B%BE%E8%A7%A3HTTP_2/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#http报文内的http信息">HTTP报文内的HTTP信息</a><ul>
<li><a href="#http报文">HTTP报文</a></li>
<li><a href="#http报文结构">HTTP报文结构</a></li>
<li><a href="#编码提升传输速率">编码提升传输速率</a></li>
<li><a href="#分割发送的分块传输编码">分割发送的分块传输编码</a></li>
<li><a href="#发送多种数据的多部分对象集合">发送多种数据的多部分对象集合</a></li>
<li><a href="#获取部分内容的范围请求">获取部分内容的范围请求</a></li>
<li><a href="#内容协商返回最合适内容">内容协商返回最合适内容</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h1><ul>
<li>HTTP通信过程：从客户端发往服务端的请求以及从服务器端返回客服端的响应</li>
</ul>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><ol>
<li>分类：<ul>
<li>请求报文：客服端向服务端</li>
<li>响应报文：服务端向客服端</li>
</ul>
</li>
</ol>
<h2 id="HTTP报文结构"><a href="#HTTP报文结构" class="headerlink" title="HTTP报文结构"></a>HTTP报文结构</h2><ol>
<li>报文首部<ul>
<li>请求行或状态行</li>
<li>首部字段<ul>
<li>请求首部、响应首部、通用首部、实体首部、（可能还有Cookie等）</li>
</ul>
</li>
</ul>
</li>
<li>空行（CR + LF）</li>
<li>报文主体（不一定存在）</li>
</ol>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><ul>
<li>传输过程中通过编码提升传输速率，可能消耗更多CPU资源</li>
<li>报文主体和实体主体的差异<ol>
<li>报文：HTTP 通信中的基本单位</li>
<li>实体：请求或响应的有效载荷，由实体首部和实体主体构成</li>
</ol>
</li>
<li>压缩传输的内容编码<ol>
<li>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</li>
</ol>
</li>
</ul>
<h2 id="分割发送的分块传输编码"><a href="#分割发送的分块传输编码" class="headerlink" title="分割发送的分块传输编码"></a>分割发送的分块传输编码</h2><ul>
<li>通过将数据分割成多块进行传输，让浏览器逐步显示页面</li>
</ul>
<h2 id="发送多种数据的多部分对象集合"><a href="#发送多种数据的多部分对象集合" class="headerlink" title="发送多种数据的多部分对象集合"></a>发送多种数据的多部分对象集合</h2><ol>
<li>解释：一次发送可以有不同的数据类型</li>
<li>对部分对象集合包含的对象：<ul>
<li>multipart/form-data（表单）</li>
<li>multipart/byteranges（响应报文包含多个范围）</li>
</ul>
</li>
<li>使用多部分对象集合时，需要在首部字段里加上Content-type<ul>
<li>boundary 字符串来划分多部分对象集合指明的各类实体</li>
<li>起始和结尾都加入“–”标记开始和结尾</li>
<li><strong>多部分对象集合的每个部分类型中，都可以含有首部字段</strong></li>
<li><strong>可以在某个部分中嵌套使用多部分对象集合</strong></li>
</ul>
</li>
</ol>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><ul>
<li>指定范围发送的请求叫做范围请求</li>
<li>执行范围请求时，会用到首部字段Range 来指定资源的byte范围</li>
</ul>
<h2 id="内容协商返回最合适内容"><a href="#内容协商返回最合适内容" class="headerlink" title="内容协商返回最合适内容"></a>内容协商返回最合适内容</h2><ul>
<li>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源</li>
<li>三种类型<ol>
<li>服务端驱动协商</li>
<li>客户端启动协商</li>
<li>透明协商</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Web内容技术</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_10/%E5%9B%BE%E8%A7%A3HTTP_10/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#构建web内容的技术">构建Web内容的技术</a><ul>
<li><a href="#html">HTML</a></li>
<li><a href="#设计应用css">设计应用CSS</a></li>
<li><a href="#动态html">动态HTML</a></li>
<li><a href="#dom">DOM</a></li>
<li><a href="#web应用">Web应用</a><ul>
<li><a href="#cgi">CGI</a></li>
<li><a href="#servlet">Servlet</a></li>
</ul>
</li>
<li><a href="#数据发布的格式及语言">数据发布的格式及语言</a><ul>
<li><a href="#xml">XML</a></li>
<li><a href="#json">JSON</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="构建Web内容的技术"><a href="#构建Web内容的技术" class="headerlink" title="构建Web内容的技术"></a>构建Web内容的技术</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul>
<li>为了发送Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在HTML 文档内的这种特殊字符串叫做HTML 标签（Tag）</li>
</ul>
<h2 id="设计应用CSS"><a href="#设计应用CSS" class="headerlink" title="设计应用CSS"></a>设计应用CSS</h2><ul>
<li>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML内的各种元素，属于样式表标准之一</li>
<li>CSS的理念就是让文档的结构和设计分离，达到解耦的目的</li>
</ul>
<h2 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h2><ul>
<li>通过调用客户端脚本语言JavaScript，实现对HTML 的Web 页面的动态改造</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li>用以操作HTML 文档和XML 文档的API（Application Programming Interface，应用编程接口）</li>
</ul>
<h2 id="Web应用"><a href="#Web应用" class="headerlink" title="Web应用"></a>Web应用</h2><ul>
<li>通过Web 功能提供的应用程序</li>
</ul>
<h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><ul>
<li>Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制<br><img src="/2020/03/27/network/图解HTTP_10/图解HTTP_10/10.1.png" alt="CGI"></li>
</ul>
<h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul>
<li>一种能在服务器上创建动态内容的程序</li>
<li>CGI，由于每次接到请求，程序都要跟着启动一次;而Servlet 运行在与Web 服务器相同的进程中，因此受到的负载较小<br><img src="/2020/03/27/network/图解HTTP_10/图解HTTP_10/10.2.png" alt="Servlet"></li>
</ul>
<h2 id="数据发布的格式及语言"><a href="#数据发布的格式及语言" class="headerlink" title="数据发布的格式及语言"></a>数据发布的格式及语言</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul>
<li>按应用目标进行扩展的通用标记语言</li>
<li>XML和HTML一样，使用标签构成树形结构，并且可自定义扩展标签</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul>
<li>以JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>Web网络安全</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_11/%E5%9B%BE%E8%A7%A3HTTP_11/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#web网络攻击">Web网络攻击</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="Web网络攻击"><a href="#Web网络攻击" class="headerlink" title="Web网络攻击"></a>Web网络攻击</h1>]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP简介</title>
    <url>/2020/03/27/network/%E5%9B%BE%E8%A7%A3HTTP_1/%E5%9B%BE%E8%A7%A3HTTP_1/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#简单的http协议">简单的HTTP协议</a><ul>
<li><a href="#http-协议用于客户端和服务器端之间的通信">HTTP 协议用于客户端和服务器端之间的通信</a></li>
<li><a href="#通过请求和响应的交换达成通信">通过请求和响应的交换达成通信</a></li>
<li><a href="#http-是不保存状态的协议">HTTP 是不保存状态的协议</a></li>
<li><a href="#请求uri-定位资源">请求URI 定位资源</a></li>
<li><a href="#告知服务器意图的http-方法">告知服务器意图的HTTP 方法</a></li>
<li><a href="#持久连接">持久连接</a></li>
<li><a href="#管线化">管线化</a></li>
<li><a href="#使用cookie-的状态管理">使用Cookie 的状态管理</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="简单的HTTP协议"><a href="#简单的HTTP协议" class="headerlink" title="简单的HTTP协议"></a>简单的HTTP协议</h1><h2 id="HTTP-协议用于客户端和服务器端之间的通信"><a href="#HTTP-协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP 协议用于客户端和服务器端之间的通信"></a>HTTP 协议用于客户端和服务器端之间的通信</h2><ol>
<li>应用HTTP 协议时，必定是一端担任客户端角色，另一端担<br>任服务器端角色</li>
</ol>
<h2 id="通过请求和响应的交换达成通信"><a href="#通过请求和响应的交换达成通信" class="headerlink" title="通过请求和响应的交换达成通信"></a>通过请求和响应的交换达成通信</h2><ol>
<li>请求必定由客户端发出，而服务器端回复响应</li>
<li>请求报文<ol>
<li>是由请求方法、请求URI、协议版本、可选的请求首部字段<br>和内容实体构成</li>
</ol>
</li>
<li>响应报头<ol>
<li>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代<br>码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主<br>体构成</li>
</ol>
</li>
</ol>
<h2 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h2><ol>
<li>HTTP 是一种不保存状态，即无状态（stateless）协议；协议对于发送过的请求或响应都不做持久化处理</li>
</ol>
<h2 id="请求URI-定位资源"><a href="#请求URI-定位资源" class="headerlink" title="请求URI 定位资源"></a>请求URI 定位资源</h2><ol>
<li>客户端请求访问资源而发送请求时，URI 需要将作为请求报文中的<br>请求URI 包含在内</li>
</ol>
<h2 id="告知服务器意图的HTTP-方法"><a href="#告知服务器意图的HTTP-方法" class="headerlink" title="告知服务器意图的HTTP 方法"></a>告知服务器意图的HTTP 方法</h2><ol>
<li>GET ：获取资源<ol>
<li>GET 方法用来请求访问已被URI 识别的资源</li>
<li>如果请求的资源是文本，那就保<br>持原样返回；如果是像CGI（Common Gateway Interface，通用网关接<br>口）那样的程序，则返回经过执行后的输出结果</li>
</ol>
</li>
<li>POST：传输实体主体<ol>
<li>POST 方法用来传输实体的主体</li>
<li>GET 方法也可以传输实体的主体，但一般不用GET 方法进行传输，而是用POST 方法</li>
<li>POST 的功能与GET 很相似，但POST 的主要目的并不是获取响应的主体内容</li>
</ol>
</li>
<li>PUT：传输文件<ol>
<li>PUT 方法用来传输文件。就像FTP 协议的文件上传一样，要求在请<br>求报文的主体中包含文件内容，然后保存到请求URI 指定的位置</li>
</ol>
</li>
<li>HEAD：获得报文首部<ol>
<li>HEAD 方法和GET 方法一样，只是不返回报文主体部分。用于确认<br>URI 的有效性及资源更新的日期时间等</li>
</ol>
</li>
<li>DELETE：删除文件<ol>
<li>DELETE 方法用来删除文件，是与PUT 相反的方法。DELETE 方法按<br>请求URI 删除指定的资源</li>
</ol>
</li>
<li>OPTIONS：询问支持的方法<ol>
<li>OPTIONS 方法用来查询针对请求URI 指定的资源支持的方法</li>
</ol>
</li>
<li>TRACE：追踪路径<ol>
<li>TRACE 方法是让Web 服务器端将之前的请求通信环回给客户端的方<br>法</li>
</ol>
</li>
<li>CONNECT：要求用隧道协议连接代理<ol>
<li>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协<br>议进行TCP 通信</li>
<li>主要使用SSL（Secure Sockets Layer，安全套接<br>层）和TLS（Transport Layer Security，传输层安全）协议把通信内容<br>加密后经网络隧道传输</li>
</ol>
</li>
</ol>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><ol>
<li>HTTP 协议的初始版本中，每进行一次HTTP 通信就要断开一次TCP<br>连接</li>
<li>HTTP/1.1 和一部分的HTTP/1.0 想出了<br>持久连接（HTTP Persistent Connections，也称为HTTP keep-alive 或<br>HTTP connection reuse）的方法。持久连接的特点是，只要任意一端<br>没有明确提出断开连接，则保持TCP 连接状态<ol>
<li>持久连接旨在建立1 次TCP 连接后进行多次请求和响应的交<br>互</li>
<li>减少了TCP 连接的重复建立和断开所造成的额<br>外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使<br>HTTP 请求和响应能够更早地结束，这样Web 页面的显示速度也就相<br>应提高</li>
</ol>
</li>
</ol>
<h2 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h2><ol>
<li>同时并行发送多个请求。不等待响应，直接发送下一个请求</li>
<li>管线化技术则比持久连接还要快。请求数越多，时间差就越明显</li>
</ol>
<h2 id="使用Cookie-的状态管理"><a href="#使用Cookie-的状态管理" class="headerlink" title="使用Cookie 的状态管理"></a>使用Cookie 的状态管理</h2><ul>
<li>Cookie 技术通过在请求和响应报文中写入Cookie 信<br>息来控制客户端的状态<ol>
<li>Cookie 会根据从服务器端发送的响应报文内的一个叫做Set-Cookie 的<br>首部字段信息，通知客户端保存Cookie</li>
<li>客户端再往该服务器<br>发送请求时，客户端会自动在请求报文中加入Cookie 值后发送出<br>去</li>
<li>服务器端发现客户端发送过来的Cookie 后，会去检查究竟是从哪一<br>个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前<br>的状态信息</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>替换PIP国内下载源</title>
    <url>/2020/03/27/python/python_pip_change_source/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#pipy国内镜像">pipy国内镜像</a></li>
<li><a href="#临时替换">临时替换</a></li>
<li><a href="#永久替换">永久替换</a><!-- TOC END -->
<a id="more"></a>
<h1 id="pipy国内镜像"><a href="#pipy国内镜像" class="headerlink" title="pipy国内镜像"></a>pipy国内镜像</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://pypi.douban.com/ 豆瓣</span><br><span class="line">http://pypi.hustunique.com/ 华中理工大学</span><br><span class="line">http://pypi.sdutlinux.org/ 山东理工大学</span><br><span class="line">http://pypi.mirrors.ustc.edu.cn/ 中国科学技术大学</span><br><span class="line">http://mirrors.aliyun.com/pypi/simple/ 阿里云</span><br><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/ 清华大学。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="临时替换"><a href="#临时替换" class="headerlink" title="临时替换"></a>临时替换</h1><ul>
<li>使用 -i 参数添加临时下载源  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install package -i source_url</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="永久替换"><a href="#永久替换" class="headerlink" title="永久替换"></a>永久替换</h1><ul>
<li><p>修改配置文件</p>
</li>
<li><h2 id="linux主机"><a href="#linux主机" class="headerlink" title="linux主机"></a>linux主机</h2><p>  创建 ~/.pip/pip.conf 文件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim ~/.pip/pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url = source_url   (https://pypi.tuna.tsinghua.edu.cn/simple（清华源）)</span><br></pre></td></tr></table></figure>
</li>
<li><h2 id="windows主机"><a href="#windows主机" class="headerlink" title="windows主机"></a>windows主机</h2><p>  user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini<br>  %appdata%搜索</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = source_url   (https://pypi.tuna.tsinghua.edu.cn/simple（清华源）)</span><br><span class="line">trusted-host = pypi.tuna.tsinghua.edu.cn</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL笔记网站记录</title>
    <url>/2020/03/26/mysql/database-network-note/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>

<ul>
<li>mysql碎片优化：<a href="https://mp.weixin.qq.com/s/VfxVKnfglzsBLD4-Z69zWQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/VfxVKnfglzsBLD4-Z69zWQ</a></li>
<li>mysql semi-sync半同步复制：<a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1433074</a></li>
<li>mysql高可用MHA搭建：<a href="https://www.cnblogs.com/gomysql/p/3675429.html" target="_blank" rel="noopener">https://www.cnblogs.com/gomysql/p/3675429.html</a></li>
<li>mysql高可用MHA搭建：<a href="https://www.cnblogs.com/struggle-1216/p/11939168.html" target="_blank" rel="noopener">https://www.cnblogs.com/struggle-1216/p/11939168.html</a></li>
<li>mycat搭建：<a href="https://www.jianshu.com/p/f02a48226222" target="_blank" rel="noopener">https://www.jianshu.com/p/f02a48226222</a></li>
<li>maxscale搭建：<a href="https://www.jianshu.com/p/70d94a8f6491" target="_blank" rel="noopener">https://www.jianshu.com/p/70d94a8f6491</a></li>
<li>深度探索MySQL主从复制原理：<a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50597960</a></li>
<li>mysql8复制-半同步复制：<a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1433074</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>网络笔记记录</title>
    <url>/2020/03/26/network/network_netwrotk_note/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>

<ul>
<li>STP：<a href="https://blog.csdn.net/qq_34104227/article/details/81982689" target="_blank" rel="noopener">https://blog.csdn.net/qq_34104227/article/details/81982689</a></li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL Join 知识点</title>
    <url>/2020/03/25/mysql/mysql_join/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#join语句">join语句</a></li>
<li><a href="#join连接算法">join连接算法</a><ul>
<li><a href="#nlj">NLJ</a></li>
<li><a href="#simple-nested-loop-join">Simple Nested-Loop Join</a></li>
<li><a href="#bnl">BNL</a></li>
</ul>
</li>
<li><a href="#join小结">join小结</a></li>
<li><a href="#join优化">join优化</a><ul>
<li><a href="#multi-range-read-mrr算法">Multi-Range Read （MRR算法）</a></li>
<li><a href="#batched-key-accessbka算法">Batched Key Access（BKA算法）</a></li>
<li><a href="#对于bnl的优化">对于BNL的优化</a></li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="join语句"><a href="#join语句" class="headerlink" title="join语句"></a>join语句</h1><ul>
<li><p>使用join语句可以将不同的表按照设置的条件进行连接操作，通过一次查询操作可以得到更多的信息</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLE_NAME t1 <span class="keyword">JOIN</span>(<span class="keyword">straight_join</span>) TABLE_NAME t2 <span class="keyword">ON</span> CONDITION;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>straight_join 让 MySQL 使用固定的连接方式执行查询，这样优化器只会按照我们指定的方式去 join。在这个语句里，t1 是驱动表，t2 是被驱动表。</p>
<p><img src="http://study.jeffqi.cn/mysql/sql_join.jpg" alt="sql_join"></p>
</li>
</ul>
</li>
</ul>
<h1 id="join连接算法"><a href="#join连接算法" class="headerlink" title="join连接算法"></a>join连接算法</h1><ul>
<li>Index Nested-Loop Join（NLJ）</li>
<li>Simple Nested-Loop Join（基本不会使用了，性能太差）</li>
<li>Block Nested-Loop Join（BNL）</li>
</ul>
<h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><ul>
<li><strong>运行过程</strong>：是先遍历表 t1，然后根据从表 t1 中取出的每行数据中的 a 值，去表 t2 中查找满足条件的记录。在形式上，这个过程就跟我们写程序时的嵌套查询类似，<strong>并且可以用上被驱动表的索引</strong><br>  <img src="http://study.jeffqi.cn/mysql/NLJ.jpg" alt="NLJ"></li>
</ul>
<h2 id="Simple-Nested-Loop-Join"><a href="#Simple-Nested-Loop-Join" class="headerlink" title="Simple Nested-Loop Join"></a>Simple Nested-Loop Join</h2><ul>
<li>直接将驱动表和被驱动表一一连接在判断条件</li>
</ul>
<h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><ul>
<li><p><strong>运行流程</strong>：先将驱动表数据读入到join_buffer中，扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。<br>  <img src="http://study.jeffqi.cn/mysql/BNL.jpg" alt="BNL"></p>
</li>
<li><p><strong>join_buffer由join_buffer_size决定，如果数据太大，就需要分多次操作装入，复用join_buffer</strong></p>
</li>
</ul>
<h1 id="join小结"><a href="#join小结" class="headerlink" title="join小结"></a>join小结</h1><ul>
<li>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</li>
</ul>
<h1 id="join优化"><a href="#join优化" class="headerlink" title="join优化"></a>join优化</h1><h2 id="Multi-Range-Read-（MRR算法）"><a href="#Multi-Range-Read-（MRR算法）" class="headerlink" title="Multi-Range Read （MRR算法）"></a>Multi-Range Read （MRR算法）</h2><ul>
<li><p>MRR 的全称是 Multi-Range Read Optimization，是优化器<strong>将随机IO转化为顺序IO</strong>以降低查询过程中 IO 开销的一种手段，提高素具库的性能。</p>
</li>
<li><p>大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</p>
</li>
<li><p>random io and seq io</p>
<p>  <img src="http://study.jeffqi.cn/mysql/seq_and_random_io.jpg" alt="seq_and_random_io"></p>
</li>
<li><p><strong>运行流程</strong>：根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;将 read_rnd_buffer 中的 id 进行递增排序；排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</p>
<p>  <img src="http://study.jeffqi.cn/mysql/mrr_process.jpg" alt="mrr_process"></p>
</li>
<li><p><strong>未使用MRR时读取数据</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/no-mrr-access-pattern.png" alt="no_mrr_access"></p>
</li>
<li><p><strong>使用MRR时读取数据</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/mrr-access-pattern.png" alt="mrr_access"></p>
</li>
</ul>
<h2 id="Batched-Key-Access（BKA算法）"><a href="#Batched-Key-Access（BKA算法）" class="headerlink" title="Batched Key Access（BKA算法）"></a>Batched Key Access（BKA算法）</h2><ul>
<li><p>BKA算法是对join的优化，利用到了join_buffer，进而利用MRR的特性对于被驱动表上的索引的利用</p>
</li>
<li><p><strong>工作流程</strong></p>
<ol>
<li><p>BKA使用join buffer保存由join的第一个操作产生的符合条件的数据，<strong>这个数据是顺序读到join_buffer中的</strong></p>
</li>
<li><p>然后BKA算法构建key来访问被连接的表，并批量使用MRR接口提交keys到数据库存储引擎去查找查找。（通过对join_buffer中的驱动表的数据，按照被驱动表尚可利用的索引进行排序，调用MRR接口进行顺序读，提高join性能）</p>
</li>
<li><p>提交keys之后，MRR使用最佳的方式来获取行并反馈给BKA</p>
</li>
</ol>
</li>
<li><p><strong>BKA使用join buffer size来确定buffer的大小，buffer越大，访问被join的表/内部表就越顺序。</strong></p>
</li>
<li><p>未使用BKA算法</p>
<p>  <img src="http://study.jeffqi.cn/mysql/key-sorting-regular-nl-join.png" alt="key_sort_regular_nlj"></p>
</li>
<li><p>使用BKA算法</p>
<p>  <img src="http://study.jeffqi.cn/mysql/key-sorting-join.png" alt="key_sort_join"></p>
</li>
<li><p>mysql中BKA的启动</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> optimizer_switch=<span class="string">'mrr=on,mrr_cost_based=off,batched_key_access=on'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BKA流程</strong></p>
<p>  <img src="http://study.jeffqi.cn/mysql/BKA_process.png" alt="bka_process"></p>
</li>
</ul>
<h2 id="对于BNL的优化"><a href="#对于BNL的优化" class="headerlink" title="对于BNL的优化"></a>对于BNL的优化</h2><ul>
<li><p><strong>BNL导致的性能问题</strong></p>
<ol>
<li>如果一个使用 BNL 算法的 join 语句，多次扫描一个冷表，而且这个语句执行时间超过 1 秒，就会在再次扫描冷表的时候，把冷表的数据页移到 LRU 链表头部。</li>
<li>如果这个冷表的数据量过大，因为mysql的LRU算法，会导致热点数据被淘汰，导致内存命中率下降。只能通过后面的查询进行恢复内存命中率，这是一个持续的影响（详解需要了解mysql的LRU算法）</li>
<li>数据表过大，会给系统io造成较大的压力。这个是暂时的join完成后就结束了</li>
<li><strong>为了减少这个影响，可以调大join_buffer_size的大小减少扫描的次数</strong></li>
</ol>
</li>
<li><p>BNL优化</p>
<ol>
<li>在被驱动表上创建索引，使其能够使用到MRR优化</li>
<li>如果是部分数据，可以对其创建内存零时表，然后创建索引列，使用MRR优化</li>
</ol>
</li>
<li><p>Hash-join优化</p>
<ol>
<li>join_buffer维护的一个无需数组，这时性能低的原因之一；如果维护一个hash表，那么扫描对比的次数就会大大减少</li>
<li>目前mysql没有实现hash-join，可以通过将数据交给后端处理<ol>
<li>select * from t1;取得表 t1 的全部 1000 行数据，在业务端存入一个 hash 结构，比如 C++ 里的 set、PHP 的数组这样的数据结构。</li>
<li>select * from t2 where b&gt;=1 and b&lt;=2000; 获取表 t2 中满足条件的 2000 行数据。</li>
<li>把这 2000 行数据，一行一行地取到业务端，到 hash 结构的数据表中寻找匹配的数据。满足匹配的条件的这行数据，就作为结果集的一行。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/chenpingzhao/p/6720531.html" target="_blank" rel="noopener">ICP、MRR、BKA特性</a></li>
<li><a href="https://time.geekbang.org/column/article/80147" target="_blank" rel="noopener">极客时间JOIN优化</a></li>
<li><a href="https://time.geekbang.org/column/article/79700" target="_blank" rel="noopener">极客时间JOIN语句</a></li>
<li><a href="https://mariadb.com/kb/en/multi-range-read-optimization/#case-3-key-sorting-for-batched-key-access" target="_blank" rel="noopener">mariadb MRR</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>CPU性能排查实验案例</title>
    <url>/2020/03/24/linux/cpu%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#cpu使用率高居不下如何排查">cpu使用率高居不下，如何排查</a><ul>
<li><a href="#查看cpu使用率">查看cpu使用率</a></li>
<li><a href="#排查进程中占用cpu的函数">排查进程中占用cpu的函数</a></li>
</ul>
</li>
<li><a href="#cpu高占用却看不到高cpu引用">cpu高占用，却看不到高cpu引用</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="cpu使用率高居不下，如何排查"><a href="#cpu使用率高居不下，如何排查" class="headerlink" title="cpu使用率高居不下，如何排查"></a>cpu使用率高居不下，如何排查</h1><ul>
<li><p>linux操作系统是一个多任务的操作系统，通过划分时间片给进程来运行。</p>
</li>
<li><p>为了维护 CPU 时间，Linux 通过事先定义的节拍率（内核中表示为 HZ），<strong>触发时间中断</strong>，并使用全局变量 Jiffies <strong>记录了开机以来的节拍数</strong>。每发生一次时间中断，Jiffies 的值就加 1。</p>
</li>
<li><p>节拍率 HZ 是<strong>内核的可配选项</strong>，可以设置为 100、250、1000等。通过查看/boot/config 内核选项来查看它的配置值</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="string">'CONFIG_HZ='</span> /boot/config</span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/linux/cat_proc_stat.jpg" alt="cat_proc_stat"></p>
</li>
<li><p>HZ决定每秒发生中断的次数；节拍率 HZ 是内核选项内核还提供了一个用户空间节拍率 USER_HZ，它总是固定为 100</p>
</li>
<li><p>CPU使用率：CPU 使用率，就是除了空闲时间（idle）外的其他时间占总 CPU 时间的百分比</p>
<p>  <img src="http://study.jeffqi.cn/linux/cpu_use_level.png" alt="cpu_use_level"></p>
</li>
<li><p>一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率</p>
<p>  <img src="http://study.jeffqi.cn/linux/cpu_timely_use_level.png" alt="cpu_timely_use_level"></p>
</li>
<li><p>/proc/[pid]/stat 文件中有每个进程的具体信息</p>
</li>
</ul>
<h2 id="查看cpu使用率"><a href="#查看cpu使用率" class="headerlink" title="查看cpu使用率"></a>查看cpu使用率</h2><ul>
<li><p>top：显示了系统总体的 CPU 和内存使用情况，以及各个进程的资源使用情况。<br>  <img src="http://study.jeffqi.cn/linux/top_see_source.jpg" alt="top_see_source"></p>
</li>
<li><p>ps：只显示了每个进程的资源使用情况<br>  <img src="http://study.jeffqi.cn/linux/ps_aux_see_source.jpg" alt="ps_aux_see_source"></p>
</li>
<li><p>pidstat：查看进程的使用资源情况<br>  <img src="http://study.jeffqi.cn/linux/pidstat_see_source.jpg" alt="pidstat_see_source"></p>
</li>
<li><p>通过做这这些工具找出占用CPU较高的进程</p>
</li>
</ul>
<h2 id="排查进程中占用cpu的函数"><a href="#排查进程中占用cpu的函数" class="headerlink" title="排查进程中占用cpu的函数"></a>排查进程中占用cpu的函数</h2><ul>
<li><h3 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h3><p>  GDB 在调试程序错误方面很强大，但是在调试时<strong>会中断程序</strong>对业务有损</p>
</li>
<li><h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a><strong>perf</strong></h3><p>  内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。</p>
</li>
<li><p><strong>perf top</strong>：显示占用 CPU 时钟最多的函数或者指令，因此可以用来<strong>查找热点函数</strong><br><img src="http://study.jeffqi.cn/linux/perf_top.jpg" alt="perf_top"></p>
<ul>
<li>第一行包含三个数据，分别是采样数（Samples）、事件类型（event）和事件总数量（Event count）</li>
<li>第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。</li>
<li>第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。</li>
<li>第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</li>
<li>最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。</li>
</ul>
</li>
<li><p><strong>perf record 与 perf report</strong>：perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。<br><img src="http://study.jeffqi.cn/linux/perf_record_perf_report.jpg" alt="per_record_per_report"></p>
</li>
<li><p><strong>使用perf top和perf record时配合使用 -g 参数，可以获取调用关系</strong><br>  <img src="http://study.jeffqi.cn/linux/per_top_g.jpg" alt="per_top_g"></p>
</li>
</ul>
<h1 id="cpu高占用，却看不到高cpu引用"><a href="#cpu高占用，却看不到高cpu引用" class="headerlink" title="cpu高占用，却看不到高cpu引用"></a>cpu高占用，却看不到高cpu引用</h1><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://time.geekbang.org/column/article/70476" target="_blank" rel="noopener">CPU占用率搞</a></li>
<li><a href="https://time.geekbang.org/column/article/70822" target="_blank" rel="noopener">CPU占用率高，却找不高CPU应用</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL数据备份</title>
    <url>/2020/03/23/mysql/MySQL%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#备份与恢复类型">备份与恢复类型</a><ul>
<li><a href="#热备份联机备份">热备份（联机备份）</a></li>
<li><a href="#冷备份脱机备份">冷备份（脱机备份）</a></li>
<li><a href="#远程备份与本地备份">远程备份与本地备份</a></li>
<li><a href="#快照备份">快照备份</a></li>
<li><a href="#全量备份与增量备份">全量备份与增量备份</a></li>
<li><a href="#物理备份">物理备份</a></li>
<li><a href="#逻辑备份">逻辑备份</a></li>
</ul>
</li>
<li><a href="#备份工具方法">备份工具方法</a><ul>
<li><a href="#mysqldump备份与还原数据">mysqldump备份与还原数据</a></li>
<li><a href="#复制文件进行备份myisam引擎">复制文件进行备份（myisam引擎）</a></li>
<li><a href="#创建文本数据备份">创建文本数据备份</a></li>
<li><a href="#二进制日志增量备份">二进制日志增量备份</a></li>
</ul>
</li>
<li><a href="#开源热备工具">开源热备工具</a><ul>
<li><a href="#percona-xtrabakup">percona xtrabakup</a></li>
</ul>
</li>
<li><a href="#备份与恢复">备份与恢复</a><ul>
<li><a href="#备份策略">备份策略</a></li>
<li><a href="#数据恢复">数据恢复</a></li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="备份与恢复类型"><a href="#备份与恢复类型" class="headerlink" title="备份与恢复类型"></a>备份与恢复类型</h1><h2 id="热备份（联机备份）"><a href="#热备份（联机备份）" class="headerlink" title="热备份（联机备份）"></a>热备份（联机备份）</h2><ul>
<li><p>备份 <strong>对其他客户端的干扰较小</strong>，其他客户端可以在备份期间连接到MySQL服务器，并且可以根据其需要执行的操作来访问数据。</p>
</li>
<li><p><strong>必须注意施加适当的锁定</strong>，以免发生会损害备份完整性的数据修改。</p>
</li>
</ul>
<h2 id="冷备份（脱机备份）"><a href="#冷备份（脱机备份）" class="headerlink" title="冷备份（脱机备份）"></a>冷备份（脱机备份）</h2><ul>
<li><p>将服务器关机，将数据复制到从服务器上。主服务器重启时会产生一个新的二进制日志文件。change master to 这个二进制日志文件。<strong>明显的缺点，关机期间服务不可用</strong>。</p>
</li>
<li><p>复制过程简单，数据不会受影响。但是客户端无法使用。</p>
</li>
</ul>
<h2 id="远程备份与本地备份"><a href="#远程备份与本地备份" class="headerlink" title="远程备份与本地备份"></a>远程备份与本地备份</h2><ul>
<li><p>mysqldump 可以连接到<strong>本地或远程服务器</strong>。对于SQL输出（CREATE和 INSERT语句），备份拿出来的<strong>数据文件可以在本地或远程主机上</strong>。</p>
</li>
<li><p>select … into outfile可以<strong>连接到本地或远程服务器</strong>，但<strong>生成的备份文件只能在服务器上</strong>。</p>
</li>
<li><p>物理备份方法<strong>通常在MySQL服务器主机上</strong>，以便使服务器脱机，尽管复制文件的目的地可能是远程的。</p>
</li>
</ul>
<h2 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h2><ul>
<li><strong>基于某一个时间点对数据的逻辑备份</strong>。MySQL本身不提供获取文件系统快照的功能。它可以通过Veritas，LVM或ZFS等第三方解决方案获得。</li>
</ul>
<h2 id="全量备份与增量备份"><a href="#全量备份与增量备份" class="headerlink" title="全量备份与增量备份"></a>全量备份与增量备份</h2><ul>
<li><p>完全备份包括在给定时间点由MySQL服务器管理的所有数据。</p>
</li>
<li><p>增量备份包括在给定时间段（从一个时间点到另一个时间点）内对数据所做的更改。</p>
</li>
<li><p>MySQL有执行完全备份的方法有多重。通过启用服务器的二进制日志（服务器用于记录数据更改），可以进行增量备份。</p>
</li>
</ul>
<h2 id="物理备份"><a href="#物理备份" class="headerlink" title="物理备份"></a>物理备份</h2><ul>
<li><p>物理备份 <strong>由存储数据库内容的目录和文件的原始副本组成</strong>。这种类型的备份适用于 <strong>大型的重要数据库</strong>，这些数据库在出现问题时需要快速恢复。</p>
</li>
<li><h2 id="物理备份特点"><a href="#物理备份特点" class="headerlink" title="物理备份特点"></a>物理备份特点</h2><ul>
<li><p>备份由数据库目录和文件的精确副本组成。通常，这是全部或部分MySQL数据目录的副本。</p>
</li>
<li><p>物理备份方法比逻辑备份方法快，因为它们仅涉及文件复制而不进行转换。</p>
</li>
<li><p>输出比逻辑备份更紧凑。</p>
</li>
<li><p>备份和还原的 <strong>粒度范围从整个数据目录级别到单个文件级别</strong>。是否有表级别粒度，具体取决于存储引擎。例如， InnoDB每个表可以位于单独的文件中，或与其他InnoDB表共享文件存储 ；例如，每个 MyISAM表唯一地对应于一组文件。</p>
</li>
<li><p>除了数据库之外，备份 <strong>还可以包括任何相关文件，例如日志或配置文件</strong>。</p>
</li>
<li><p>备份只能移植到具有相同或相似硬件特性的其他计算机上。</p>
</li>
<li><p><strong>备份工具</strong> 包括对于企业版mysql的innodb引擎或者其他表的 <strong>mysqlbackup</strong>，或者是对于备份myisam表的 <strong>系统命令(cp、scp、tar)</strong>。</p>
</li>
</ul>
</li>
<li><h2 id="还原物理备份数据"><a href="#还原物理备份数据" class="headerlink" title="还原物理备份数据"></a>还原物理备份数据</h2><ul>
<li>mysqlbackup工具还原</li>
<li>ndb_restore还原 NDB表。</li>
<li>可以使用文件系统命令将在文件系统级别复制的文件复制回其原始位置。</li>
</ul>
</li>
</ul>
<h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><ul>
<li><p>逻辑备份保存表示为 <strong>逻辑数据库结构</strong>（CREATE DATABASE， CREATE TABLE语句）和 <strong>内容</strong>（INSERT语句或定界文本文件）的信息。这种类型的备份适用于 <strong>少量数据</strong>，您可以在其中编辑数据值或表结构，或在其他计算机体系结构上重新创建数据。</p>
</li>
<li><h2 id="逻辑备份特点"><a href="#逻辑备份特点" class="headerlink" title="逻辑备份特点"></a>逻辑备份特点</h2><ul>
<li><p>通过查询MySQL服务器以获得数据库结构和内容信息来完成备份。</p>
</li>
<li><p>备份比物理方法慢，因为服务器必须访问数据库信息并将其转换为逻辑格式。如果输出是在客户端编写的，则服务器还必须将其发送到备份程序。</p>
</li>
<li><p>备份产生的文件比较大</p>
</li>
<li><p>备份和还原粒度在服务器级别（所有数据库），数据库级别（特定数据库中的所有表）或表级别可用。无论存储引擎如何，都是如此。<strong>相比于物理备份更加细粒度</strong></p>
</li>
<li><p><strong>备份无日志等其他文件，至于数据库数据有关的数据才会保留</strong>。</p>
</li>
<li><p>可移植性更高</p>
</li>
<li><p>在物理机运行时可备份。</p>
</li>
<li><p><strong>备份工具</strong> 包括 <strong>mysqldump</strong> 和 select … into outfile。<strong>适用于任何存储引擎</strong></p>
</li>
</ul>
</li>
</ul>
<h1 id="备份工具方法"><a href="#备份工具方法" class="headerlink" title="备份工具方法"></a>备份工具方法</h1><h2 id="mysqldump备份与还原数据"><a href="#mysqldump备份与还原数据" class="headerlink" title="mysqldump备份与还原数据"></a>mysqldump备份与还原数据</h2><ul>
<li><p>mysqldump创建数据库副本可以使您以一种格式捕获数据库中的所有数据，该格式可以将信息导入到MySQL Server的另一个实例中</p>
</li>
<li><p>由于信息的格式为SQL语句，因此在需要紧急访问数据时，可以轻松地将该文件分发并应用于正在运行的服务器。但是，如果数据集的大小很大，则mysqldump可能不切实际。</p>
</li>
<li><p><strong>使用mysqldump时，应在开始转储过程之前停止从属服务器上的复制，以确保转储包含一致的数据集</strong></p>
</li>
</ul>
<ol>
<li><p>备份单/多库保留建库语句</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p <span class="comment">--databases database_1_name [database_2_name] &gt; /some/path/to/save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份单库是可以忽略 --databases 参数，备份文件不会携带 create database 或者 use 语句。所以在使用该文件恢复数据是需要先 create database 和 use db_name</span></span><br><span class="line">mysqldump -uroot -p database_1_name &gt; /some/path/to/save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以备份一库多表</span></span><br><span class="line">mysqldump -uroot -p database_1_name table_1_name table_2_name &gt; /some/path/to/save</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份全库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p <span class="comment">--all-databases &gt; /some/path/to/save</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="http://study.jeffqi.cn/mysql/mysqldump_with_gtid.jpg" alt="mysqldump_with_gtid"></p>
<p><img src="http://study.jeffqi.cn/mysql/mysqldump_without_gtid.jpg" alt="mysqldump_without_gtid"></p>
<ol start="3">
<li>还原数据库<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 外部命令行</span></span><br><span class="line">mysql -uroot -p &lt; /file/to/return</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部命令</span></span><br><span class="line">source /file/to/return</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="复制文件进行备份（myisam引擎）"><a href="#复制文件进行备份（myisam引擎）" class="headerlink" title="复制文件进行备份（myisam引擎）"></a>复制文件进行备份（myisam引擎）</h2><ul>
<li>可以通过复制表文件（*.MYD，*.MYI文件和关联 *.sdi文件）来备份MyISAM表。要获得一致的备份，请停止服务器或锁定并刷新相关表。  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">TABLES</span> tbl_list <span class="keyword">WITH</span> <span class="keyword">READ</span> <span class="keyword">LOCK</span>; <span class="comment"># 锁表</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="创建文本数据备份"><a href="#创建文本数据备份" class="headerlink" title="创建文本数据备份"></a>创建文本数据备份</h2><ul>
<li><p>要创建包含表数据的文本文件，来对数据进行备份。</p>
</li>
<li><p><strong>此方法适用于任何类型的数据文件，但仅保存表数据，而不保存表结构。</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">'/path/to/save/file'</span> <span class="keyword">FROM</span> tbl_name</span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/mysql/select_into_outfile.jpg" alt="select_into_outfile"></p>
</li>
<li><p>恢复数据</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load data命令</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">infile</span> <span class="string">'/path/for/file/to/return'</span> <span class="keyword">into</span> <span class="keyword">table</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysqlimport</span></span><br><span class="line">mysqlimport -u root -p <span class="comment">--local table_name /path/for/file/to/return</span></span><br></pre></td></tr></table></figure>

<p>  <img src="http://study.jeffqi.cn/mysql/load_data_infile_into_table.jpg" alt="load_data_infile_into_table"></p>
</li>
</ul>
<h2 id="二进制日志增量备份"><a href="#二进制日志增量备份" class="headerlink" title="二进制日志增量备份"></a>二进制日志增量备份</h2><ul>
<li><p>二进制日志文件为您提供了将更改复制到数据库的信息，这些更改是在执行备份之后进行的。</p>
</li>
<li><p>开启二进制日志</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">log_bin=/path/to/save/binlog</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>查看二进制日志文件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog /binary/log</span><br><span class="line">mysqlbinlog <span class="comment">--base64-output=decode-rows --verbose /binary/log/path</span></span><br></pre></td></tr></table></figure>

<ul>
<li>at：可以理解为事务的执行点</li>
</ul>
</li>
<li><p>选择还原点还原</p>
<ol>
<li><p>基于时间点恢复：使用 –start-datetime和 –stop-datetime 选项来指定时间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--stop-datetime="2005-04-20 9:59:59"  /var/log/mysql/bin.123456 | mysql -u root -p</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>基于位点的恢复：使用 –start-position 和 –stop-position 选项可用于指定日志位置。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--stop-position=368312 /var/log/mysql/bin.123456 | mysql -u root -p</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="开源热备工具"><a href="#开源热备工具" class="headerlink" title="开源热备工具"></a>开源热备工具</h1><h2 id="percona-xtrabakup"><a href="#percona-xtrabakup" class="headerlink" title="percona xtrabakup"></a>percona xtrabakup</h2><ul>
<li><h3 id="xtrabackup"><a href="#xtrabackup" class="headerlink" title="xtrabackup"></a>xtrabackup</h3><p>  <strong>工作机制</strong>：xtrabackup的工作基于<strong>innodb存储引擎的崩溃恢复功能力</strong>进行的。复制完数据库的数据之后，通过崩溃恢复的功能来进行数据的恢复。保持数据的一致性。崩溃护肤功能基于innodb的内置的redo-log日志。<strong>在恢复数据时对于已经提交的事务直接重做应用；未提交的事务进行回滚</strong>。相比于mysqldump等工具来说，xtrabackup工具是<strong>物理备份</strong>，对于数据直接拷贝。同时对系统的影响较小，基本不会阻塞线上的业务的运行。</p>
<p>  <strong>工作流程</strong>：</p>
<pre><code>1.  启动xtra进程开启一个子进程对redo-log进行持续复制。如果redo-log发生了改动，也会进行复制操作。

2.  启动另一个子进程，对innodb存储引擎的数据库的数据和日志进行复制

3.  复制完所有innodb/xtradb数据和日志后，对所有myisam和其他非innodb表执行锁定操作（LOCK BINLOG FOR BACKUP）；进行数据的复制（此阶段数据库短暂不可写）

4.  非事务表复制完成后，会停止复制线程，记录日志的坐标。同时停止redo-log日志的复制。

5.  对于上锁的数据进行解锁

6.  完成复制</code></pre><p>  <strong>恢复数据</strong>：</p>
<pre><code>1.  首先读取配置文件 my.cnf 检查相应的文件是否存在

2.  之后会首先复制恢复非事务表和数据

3.  恢复innodb表和数据

4.  最后是二进制日志

5.  需要修改文件的权限归属等信息</code></pre><p>  <img src="http://study.jeffqi.cn/mysql/xtrabackup-process.png" alt="xtrabakup_process"></p>
</li>
<li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>安装rpm包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm</span><br><span class="line"><span class="comment"># 也可以从官网下载rpm的安装包进行直接安装</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启用存储库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">percona-release <span class="built_in">enable</span>-only tools release</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装xtrabackup</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install percona-xtrabackup-80</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载xtrbackup</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum remove percona-xtrabackup</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3>  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup \</span><br><span class="line">--user=user_name \</span><br><span class="line">--password=password \</span><br><span class="line">--host=host_ip \</span><br><span class="line">--port=port_number \</span><br><span class="line">--socket=/path/to/socker \</span><br><span class="line">--backup \</span><br><span class="line">--target-dir=/data/bkps/</span><br></pre></td></tr></table></figure>

<p>  <strong>创建备份用户，分配必要权限</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">'bkpuser'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">with</span> <span class="string">'mysql_native_password'</span> <span class="keyword">by</span> <span class="string">'Hjqme525+'</span>;</span><br><span class="line"><span class="keyword">grant</span> reload,<span class="keyword">lock</span> <span class="keyword">tables</span>,backup_admin,<span class="keyword">replication</span> <span class="keyword">client</span>,<span class="keyword">create</span> \</span><br><span class="line"><span class="keyword">tablespace</span>,process,super,<span class="keyword">create</span>,<span class="keyword">insert</span>, <span class="keyword">select</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'bkpuser'</span>@<span class="string">'%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="全量备份"><a href="#全量备份" class="headerlink" title="全量备份"></a>全量备份</h4><p>  <strong>创建全量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup \</span><br><span class="line">--host=xxx.xxx.xxx.xxx --user=bkpuser --port=3306 --password \</span><br><span class="line">--target-dir=/tmp/xtrabackup.test</span><br></pre></td></tr></table></figure>

<p>  <strong>准备备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --target-dir=/tmp/xtrabackup.test</span><br></pre></td></tr></table></figure>

<p>  <strong>恢复备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/mysql/data/dir   <span class="comment"># --move-back：删除备份数据</span></span><br></pre></td></tr></table></figure>

<p>  –copy-back参数与–move-back参数的区别：<strong>copyback在复制完数据后，会保存当前的文件，而moveback在复制完成后会删除备份文件</strong></p>
<p>  <strong>重启数据库</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod -R mysql:mysql /mysql/data/dir</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="增量备份（基于全量备份）"><a href="#增量备份（基于全量备份）" class="headerlink" title="增量备份（基于全量备份）"></a>增量备份（基于全量备份）</h4><p>  <strong>创建全量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup \</span><br><span class="line">--host=xxx.xxx.xxx.xxx --user=bkpuser --port=3306 --password \</span><br><span class="line">--target-dir=/root/data2.data</span><br></pre></td></tr></table></figure>

<p>  <strong>基于全量备份的增量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup --host=192.168.80.128 --user=root --password \</span><br><span class="line">--target-dir=/root/data2.increment.data \</span><br><span class="line">--incremental-basedir=/root/data2.data/</span><br></pre></td></tr></table></figure>

<p>  <strong>增量备份时需要指定基础的文件</strong></p>
<p>  <strong>插入</strong></p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> xtratest2()</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> i <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">declare</span> a <span class="built_in">int</span>;</span><br><span class="line">    <span class="keyword">set</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">set</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=<span class="number">10000</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">insert</span> <span class="keyword">into</span> d3.t1(<span class="keyword">id</span>,a) <span class="keyword">values</span> (i,a);</span><br><span class="line">        <span class="keyword">set</span> i=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">set</span> a=a+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    //</span><br><span class="line">  delimiter ;</span><br><span class="line">  <span class="keyword">call</span> xtratest2();</span><br></pre></td></tr></table></figure>

<p>  <strong>基于增量备份的增量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup --host=192.168.80.128 --user=root --password \</span><br><span class="line">--target-dir=/root/data2.increment2.data \</span><br><span class="line">--incremental-basedir=/root/data2.increment.data/</span><br></pre></td></tr></table></figure>

<p>  <strong>准备全量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --apply-log-only --target-dir=/root/dada2.data/</span><br></pre></td></tr></table></figure>

<p>  <strong>对于需要恢复增量备份的数据，其全量备份还原时需要添加 –apply-log-only 参数，否则后续增量备份不可用</strong></p>
<p>  <strong>恢复增量备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --apply-log-only --target-dir=/root/data2.data/ \</span><br><span class="line">--incremental-dir=/root/data2.increment.data/</span><br></pre></td></tr></table></figure>

  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --prepare --apply-log-only --target-dir=/root/data2.data/ \</span><br><span class="line">--incremental-dir=/root/data2.increment2.data/</span><br></pre></td></tr></table></figure>

<p>  <strong>一个增量备份文件只恢复一次不要重复恢复</strong></p>
<p>  <strong>恢复备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --copy-back --target-dir=/root/dada2.data/</span><br><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="压缩备份"><a href="#压缩备份" class="headerlink" title="压缩备份"></a>压缩备份</h4><p>  <strong>压缩备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">xtrabackup --backup --host=192.168.80.128 --user=root --password \</span><br><span class="line">--compress --compress-threads=2 \</span><br><span class="line">--target-dir=/root/data3.data</span><br></pre></td></tr></table></figure>

<p>  <strong>解压备份</strong></p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install qpress-11-1.el7.x86_64    <span class="comment"># 注意安装qpress软件，可以通过安装rpm来找到相应的软件</span></span><br><span class="line">xtrabackup --decompress --target-dir=/root/data3.data/</span><br></pre></td></tr></table></figure>

<p>  <strong>准备备份</strong></p>
<p>  <strong>恢复备份</strong></p>
</li>
</ul>
<h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><h2 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h2><ul>
<li>对于数据需要有周期性的备份操作。这里针对 mysqldump 展开。</li>
</ul>
<ol>
<li><p>可以每天在业务低峰期对于数据进行一次定时任务进行全量备份</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="comment">--all-databases --single-transaction &gt; /some/place/to/save/file</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先会对于全库进行锁表操作（flash tables with read lock）。一旦或得到这个锁就会读取二进制日志坐标，并释放这个锁。如果因为有长事务更新，可能会不能获得到锁，会暂停备份，直到长事务结束。之后，转储将变为无锁状态，并且不会干扰对表的读写。</p>
</li>
<li><p>–single-transaction 参数使用一致的读取并保证mysqldump看到的数据 不会更改。</p>
</li>
</ul>
</li>
<li><p>全库备份是必须的，但是备份出来的文件比较大，不方便，同时也会占用性能，需要花费较长时间。所以一般采用长时间的全库备份，加上短期的增量备份。需要的额外代价是，在恢复数据时，需要使用全库备份文件和增量备份文件来恢复。</p>
</li>
<li><p>增量备份通过二进制日志来进行。需要告知服务器开启二进制日志。在全量备份时刷新二进制日志。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction --flush-logs --master-data=2 --all-databases &gt; /some/place/to/save/file</span></span><br></pre></td></tr></table></figure>

<ul>
<li>–flush-logs 选项导致服务器刷新其日志。–master-data选项使 mysqldump将二进制日志信息写入其输出。</li>
</ul>
</li>
</ol>
<h2 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h2><ol>
<li><p>首先使用全量备份文件进行恢复数据</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p &lt; /file/to/return</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用增量binlog恢复</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog binglog_1_name [binlog_2_name] | mysql -uroot -p</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/linuxk/p/9372990.html" target="_blank" rel="noopener">xtrabakup备份入门</a></li>
<li><a href="https://www.percona.com/doc/percona-xtrabackup/8.0/index.html" target="_blank" rel="noopener">percona-xtrabakup-documents</a></li>
<li><a href="https://www.percona.com/doc/percona-xtrabackup/2.4/howtos/recipes_ibkx_stream.html" target="_blank" rel="noopener">xtrabakup流处理</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqldump.html" target="_blank" rel="noopener">mysqldump文档</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/mysqlbinlog.html" target="_blank" rel="noopener">mysqlbinlog文档</a></li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/backup-and-recovery.html" target="_blank" rel="noopener">mysql数据备份</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>mysql主从复制</title>
    <url>/2020/03/23/mysql/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#啥是主从复制">啥是主从复制？</a></li>
<li><a href="#主从复制有什么用">主从复制有什么用？</a></li>
<li><a href="#主从模式">主从模式</a><ul>
<li><a href="#一主一从一主多从">一主一从、一主多从</a></li>
<li><a href="#多主一从">多主一从</a></li>
<li><a href="#双主模式">双主模式</a></li>
<li><a href="#级联复制">级联复制</a></li>
</ul>
</li>
<li><a href="#mysql主从复制原理">mysql主从复制原理</a><ul>
<li><a href="#复制流程">复制流程</a></li>
</ul>
</li>
<li><a href="#mysql复制模式">mysql复制模式</a></li>
<li><a href="#性能提升">性能提升</a><ul>
<li><a href="#支持发送二进制日志事件和接收ack的异步化">支持发送二进制日志事件和接收ACK的异步化</a></li>
<li><a href="#控制主库接收确认反馈从库的数量">控制主库接收确认反馈从库的数量</a></li>
</ul>
</li>
<li><a href="#日志格式">日志格式</a><ul>
<li><a href="#binlog记录格式">binlog记录格式</a></li>
</ul>
</li>
<li><a href="#基于gtid复制实现的工作原理">基于GTID复制实现的工作原理</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="啥是主从复制？"><a href="#啥是主从复制？" class="headerlink" title="啥是主从复制？"></a>啥是主从复制？</h1><ul>
<li>主从复制就就是将主服务器上的数据，复制到一个或多个从服务器上；mysql默认采用异步复制，从节点可以复制主节点上的指定的数据库；</li>
</ul>
<h1 id="主从复制有什么用？"><a href="#主从复制有什么用？" class="headerlink" title="主从复制有什么用？"></a>主从复制有什么用？</h1><ul>
<li><p><strong>提供读写分离的能力</strong>：从服务器可以分代主库的读请求的压力，让主库更专注于数据的更新和写操作，有更好的写性能；</p>
</li>
<li><p><strong>数据备份</strong>：从库上拥有主库的完整的二进制日志，应用后可拥有和主库几乎相等的数据；在主库某些不可抗力的影响后，依旧能够保证真个数据库数据的完整性；方便切换</p>
</li>
<li><p><strong>高可用</strong>：主从复制是高可用的基础；可以使用多个节点来避免单点故障</p>
</li>
<li><p><strong>架构扩展</strong>：可以随着业务的增加，可以通过增加节点来提高适应能力。分担压力，将压力负载到多态服务器上</p>
</li>
</ul>
<h1 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h1><h2 id="一主一从、一主多从"><a href="#一主一从、一主多从" class="headerlink" title="一主一从、一主多从"></a>一主一从、一主多从</h2><ul>
<li>一主一到多从模式可以提升整个数据库的读能力，分代主库的压力</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/1_m_1_s.jpg" alt="1-m-1-s"><br><img src="http://study.jeffqi.cn/mysql/1_m_mulits_s.jpg" alt="1-m-mulits-s"></p>
<h2 id="多主一从"><a href="#多主一从" class="headerlink" title="多主一从"></a>多主一从</h2><ul>
<li>将多个主库的数据存储到一台存储性能好的服务器中</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/mulits_m_1_s.jpg" alt="mulits-m-1-s"></p>
<h2 id="双主模式"><a href="#双主模式" class="headerlink" title="双主模式"></a>双主模式</h2><ul>
<li>两台服务器互为主从，任意一个master修改后都会将数据日志复制到对方去；避免循环复制，从服务器在应用日志后，写日志时将日志的server-id改为应用日志的server-id，这样发送回去的时候主服务器就能够识别</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/double_m.jpg" alt="double-m"></p>
<h2 id="级联复制"><a href="#级联复制" class="headerlink" title="级联复制"></a>级联复制</h2><ul>
<li>部分slave的数据同步不连接主节点，而是连接从节点。因为如果主节点有太多的从节点，就会损耗一部分性能用于replication，那么我们可以让3~5个从节点连接主节点，其它从节点作为二级或者三级与从节点连接，这样不仅可以缓解主节点的压力，并且对数据一致性没有负面影响</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/m-s-s.jpg" alt="m-s-s"></p>
<h1 id="mysql主从复制原理"><a href="#mysql主从复制原理" class="headerlink" title="mysql主从复制原理"></a>mysql主从复制原理</h1><ul>
<li><p>mysql主从复制中有三个线程<strong>dump thread（master）、io thread（slave）、sql thread（slave）</strong></p>
</li>
<li><p><strong>dump thread</strong>：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，在发动给从节点之后，锁会被释放。</p>
</li>
<li><p><strong>io thread</strong>：从节点上用来想主服务器请求日志，接收从主服务器发送的binlog，并更新到本地的relay-log中。</p>
</li>
<li><p><strong>sql thread</strong>：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</p>
</li>
<li><p>当主节点有多个从节点时，主节点会为每一个当前连接的从节点建一个binary log dump 进程，而每个从节点都有自己的I/O进程，SQL进程。从节点用两个线程将从主库拉取更新和执行分成独立的任务，这样在执行同步数据任务的时候，不会降低读操作的性能。</p>
</li>
</ul>
<h2 id="复制流程"><a href="#复制流程" class="headerlink" title="复制流程"></a>复制流程</h2><ul>
<li><p>从节点上的I/O 进程连接主节点，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容；</p>
</li>
<li><p>主节点接收到来自从节点的I/O请求后，通过负责复制的I/O进程根据请求信息读取指定日志指定位置之后的日志信息，返回给从节点。返回信息中除了日志所包含的信息之外，还包括本次返回的信息的bin-log file 的以及bin-log position；从节点的I/O进程接收到内容后，将接收到的日志内容更新到本机的relay log中，并将读取到的binary log文件名和位置保存到master-info 文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log 的哪个位置开始往后的日志内容，请发给我”；</p>
</li>
<li><p>Slave 的 SQL线程检测到relay-log 中新增加了内容后，会将relay-log的内容解析成在祝节点上实际执行过的操作，并在本数据库中执行。</p>
</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/mysql_replication_processes.png" alt="mysql-replication_processes"></p>
<h1 id="mysql复制模式"><a href="#mysql复制模式" class="headerlink" title="mysql复制模式"></a>mysql复制模式</h1><ul>
<li><p>异步复制<br><img src="http://study.jeffqi.cn/mysql/mysql_async_repl.jpg" alt="mysql_async_repl"></p>
</li>
<li><p>同步复制<br><img src="http://study.jeffqi.cn/mysql/mysql_%28semi%29_sync.jpg" alt="mysql_(semi)\_repl"></p>
</li>
<li><p>半同步复制</p>
</li>
<li><h2 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h2><p>  主节点不会主动推送二进制日志到从服务器，需要从服务器发起请求；主服务器的事务完成提交后立即返回结果给客户端，需要等待从服务器的确认。</p>
<ul>
<li><p><strong>优点</strong>：数据库吞吐量大，性能好</p>
</li>
<li><p><strong>缺点</strong>：因为不需要其他数据库的确认，可能在master宕机后，造成数据的丢失；从服务器也不能及时的更新数据</p>
</li>
</ul>
</li>
<li><h2 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h2><p>  当主库提交事务时，<strong>所有从库</strong>也将在主库返回执行事务的会话之前<strong>提交事务</strong>。这样能够保证数据的一致性和完整性</p>
<ul>
<li><p><strong>有点</strong>：数据库数据有备份，完整性好</p>
</li>
<li><p><strong>缺点</strong>：需要等待从库确认，主动推送日志，会有性能消耗；事务的过程边长</p>
</li>
</ul>
</li>
<li><h2 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h2><p>  介于异步和完全同步复制之间。主库仅等待<strong>至少一个从库接收并记录事件</strong>。它不会等待所有从库确认收到，并且<strong>从库只需要确认接收</strong>，而不是事件已在从库完全执行和提交。</p>
<ul>
<li><p><strong>优点</strong>：至少有一个从库确认了二进制日志，保证了数据的完整性；同时不需要等待所有从库的确认，响应速度更快</p>
</li>
<li><p><strong>缺点</strong>：因为需要等待至少一个从库，所以有性能消耗；同时如果读写分离的读操作落在不是确认了日志的服务器上，会出现延迟更新的问题</p>
</li>
</ul>
</li>
</ul>
<h1 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h1><h2 id="支持发送二进制日志事件和接收ACK的异步化"><a href="#支持发送二进制日志事件和接收ACK的异步化" class="headerlink" title="支持发送二进制日志事件和接收ACK的异步化"></a>支持发送二进制日志事件和接收ACK的异步化</h2><ul>
<li>旧版本的半同步复制受限于Binlog Dump线程，原因是该线程承担了两份不同且又十分频繁的任务：传送二进制日志事件给从库 ；接收从库的ACK反馈信息。这两个任务是串行的，Binlog Dump线程必须等待从库返回之后才会传送下一个事件。Binlog Dump线程已然成为整个半同步复制性能的瓶颈。</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/old_repl_ack.png" alt="old_repl_ack"></p>
<ul>
<li>在5.7.4版本的半同步复制框架中，独立出一个Ack Receiver线程 ，专门用于接收从库返回的ACK请求，这将之前Binlog Dump线程的发送和接收工作分为了两个线程来处理。这样主库上有两个线程独立工作，可以同时发送二进制日志事件到从库，和接收从库的ACK信息</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/new_repl_ack.png" alt="new_repl_ack"></p>
<ul>
<li><p>Ack Receiver线程在主库启用半同步复制时创建，并在主库禁用半同步复制时销毁。它是自动创建和销毁的，因此不受用户控制</p>
</li>
<li><p>在MySQL 5.7.17之前，这个Ack Receiver线程采用了<strong>select机制来监听</strong>从库返回的结果，然而select机制监控的文件句柄只能是0-1024，当超过1024时，用户在MySQL的错误日志中或许会收到类似如下的报错，更有甚者会导致MySQL发生宕机。</p>
</li>
<li><p>MySQL 5.7.17版本开始，官方修复了这个bug，开始使用<strong>poll机制来替换原来的select机制</strong>，从而可以避免上面的问题。其实poll调用本质上和select没有区别，只是在I/O句柄数理论上没有上限</p>
</li>
</ul>
<h2 id="控制主库接收确认反馈从库的数量"><a href="#控制主库接收确认反馈从库的数量" class="headerlink" title="控制主库接收确认反馈从库的数量"></a>控制主库接收确认反馈从库的数量</h2><ul>
<li><p>MySQL 5.7新增了rpl_semi_sync_master_wait_for_slave_count系统变量，可以用来控制主库接收多少个从库写事务成功反馈，给高可用架构切换提供了灵活性。当该变量值为2时，主库需等待两个从库的ACK。</p>
</li>
<li><p>当然啦，数字越大越安全咯；因为更接近全同步复制了（手动滑稽）</p>
</li>
</ul>
<h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><ul>
<li>statment</li>
<li>row</li>
<li>mix</li>
</ul>
<h2 id="binlog记录格式"><a href="#binlog记录格式" class="headerlink" title="binlog记录格式"></a>binlog记录格式</h2><ul>
<li><h3 id="statment格式"><a href="#statment格式" class="headerlink" title="statment格式"></a>statment格式</h3><p>  该模式记录每一条sql语句，对于所有的增删改语句进行记录。日志文件较小，节约了io。但是在一些极端情况下会照成数据的不一致；</p>
</li>
<li><h3 id="row格式"><a href="#row格式" class="headerlink" title="row格式"></a>row格式</h3><p>   Row-based Relication(RBR)是mysql master将SQL语句分解为基于Row更改的语句并记录在bin log中，也就是只记录哪条数据被修改了，修改成什么样；恢复数据是比较方便，不会出现不一致的问题；缺点是日志文件过大也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更；也不能通过bin log解析获取执行过的sql语句，只能看到发生的data变更</p>
</li>
<li><h3 id="mix格式"><a href="#mix格式" class="headerlink" title="mix格式"></a>mix格式</h3><p>  是以上两种模式的混合，对于一般的复制使用STATEMENT模式保存到binlog，对于STATEMENT模式无法复制的操作则使用ROW模式来保存，MySQL会根据执行的SQL语句选择日志保存方式</p>
</li>
</ul>
<h1 id="基于GTID复制实现的工作原理"><a href="#基于GTID复制实现的工作原理" class="headerlink" title="基于GTID复制实现的工作原理"></a>基于GTID复制实现的工作原理</h1><ul>
<li><p>在传统的复制里面，当发生故障，需要主从切换，需要找到binlog和pos点，然后将主节点指向新的主节点，相对来说比较麻烦，也容易出错；使用GTID进行复制不需要其他的操作；MySQL会通过内部机制GTID自动找点同步。</p>
</li>
<li><p><strong>工作流程</strong></p>
<ol>
<li>主节点更新数据时，会在事务前产生GTID，一起记录到binlog日志中。</li>
<li>从节点的I/O线程将变更的bin log，写入到本地的relay log中。</li>
<li>SQL线程从relay log中获取GTID，然后对比本地binlog是否有记录（所以MySQL从节点必须要开启binary log）。</li>
<li>如果有记录，说明该GTID的事务已经执行，从节点会忽略。</li>
<li>如果没有记录，从节点就会从relay log中执行该GTID的事务，并记录到bin log。</li>
<li>在解析过程中会判断是否有主键，如果没有就用二级索引，如果有就用全部扫描。（<strong>没明白</strong>）</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/50597960" target="_blank" rel="noopener">深度探索MySQL主从复制原理</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1433074" target="_blank" rel="noopener">mysql8复制-半同步复制</a></li>
<li><a href="https://wxy0327.blog.csdn.net/article/details/90081518" target="_blank" rel="noopener">mysql8复制-半同步复制配置</a></li>
<li><a href="https://time.geekbang.org/column/article/76446" target="_blank" rel="noopener">MySQL是怎么保证主备一致的？(极客时间)</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>初始CDN</title>
    <url>/2020/03/22/linux/CDN/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#cdn">CDN</a></li>
<li><a href="#cdn是个what">CDN是个what？</a><ul>
<li><a href="#cdn工作流程">CDN工作流程</a></li>
</ul>
</li>
<li><a href="#cdn相关技术">CDN相关技术</a><ul>
<li><a href="#负载均衡技术">负载均衡技术</a></li>
<li><a href="#动态内容分发与复制技术">动态内容分发与复制技术</a></li>
<li><a href="#缓存技术">缓存技术</a></li>
</ul>
</li>
<li><a href="#cdn的应用场景">CDN的应用场景</a></li>
<li><a href="#cdn的不足">CDN的不足</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><ul>
<li><p>随着互联网的发展，用户在使用网络时对网站的浏览速度和效果愈加重视，但由于网民数量激增，网络访问路径过长，从而使用户的访问质量受到严重影响。特别是当用户与网站之间的链路被突发的大流量数据拥塞时，对于异地互联网用户急速增加的地区来说，访问质量不良更是一个急待解决的问题。<strong>如何才能让各地的用户都能够进行高质量的访问，并尽量减少由此而产生的费用和网站管理压力呢？</strong></p>
</li>
<li><p>今天的角儿登场了：CDN（Content Delivery Network）内容发布网络变应运而生。</p>
</li>
</ul>
<h1 id="CDN是个what？"><a href="#CDN是个what？" class="headerlink" title="CDN是个what？"></a>CDN是个what？</h1><ul>
<li>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可 以就近取得所需的内容，提高用户访问网站的响应速度。</li>
</ul>
<p><img src="http://study.jeffqi.cn/linux/cdn_zone_servers.jpg" alt="cdn_zone_servers"></p>
<ul>
<li>解决由于网络带宽小、用户访问量大、网点分布不均等问题，提高用户访 问网站的响应速度</li>
</ul>
<h2 id="CDN工作流程"><a href="#CDN工作流程" class="headerlink" title="CDN工作流程"></a>CDN工作流程</h2><ol>
<li>用户访问加入CDN服务的网站时，首先通过DNS重定向技术，找到距离用户最近的CDN节点，同时是用户指向该节点；</li>
<li>当用户的请求到达该节点的时候，CDN的服务器（节点上的高速缓存）负责将用户请求的内容提供给用户；</li>
<li><h2 id="具体流程："><a href="#具体流程：" class="headerlink" title="具体流程："></a>具体流程：</h2> 用户在自己的浏览器中输入要访问的网站的域名，浏览器向本地DNS请求对该域名的解析，本地DNS将请求发到网站的主DNS，主DNS根据一系列的策略确 定当时最适当的CDN节点，并将解析的结果（IP地址）发给用户，用户向给定的CDN节点请求相应网站的内容。</li>
</ol>
<h1 id="CDN相关技术"><a href="#CDN相关技术" class="headerlink" title="CDN相关技术"></a>CDN相关技术</h1><ul>
<li>CDN的实现需要依赖多种网络技术的支持，其中<strong>负载均衡技术、动态内容分发与复制技术、缓存技术</strong>是比较主要的几个</li>
</ul>
<h2 id="负载均衡技术"><a href="#负载均衡技术" class="headerlink" title="负载均衡技术"></a>负载均衡技术</h2><ul>
<li><p>网络中的负载均衡就是将流量尽可能的分配到不同的线路节点上，以此来减轻某些节点的负载，提高网络流量，同时提升网络服务质量</p>
</li>
<li><p>在 CDN中，负载均衡又分为<strong>服务器负载均衡</strong>和<strong>服务器整体负载均衡</strong>(也有的称为服务器全局负载均衡)</p>
</li>
<li><p><strong>服务器负载均衡</strong>：是指能够在性能不同的服务器之间进行任务分配，既能保证性能差的服务器不成为系统的瓶颈，又能保证性能高的服务器的资源得到充分利用</p>
</li>
<li><p><strong>服务器整体负载均衡</strong>：是指允许Web网络托管商、门户站点和企业 根据地理位置分配内容和服务；<strong>通过使用多站点内容和服务来提高容错性和可用性，防止因本地网或区域网络中断、断电或自然灾害而导致的故障</strong>。在CDN的方案中服务器整体负载均衡将发挥重要作用，其性能高低将直接影响整个CDN的性能。</p>
</li>
</ul>
<h2 id="动态内容分发与复制技术"><a href="#动态内容分发与复制技术" class="headerlink" title="动态内容分发与复制技术"></a>动态内容分发与复制技术</h2><ul>
<li><p>网站访问服务质量的好坏取决于多方面因素，包括网络带宽、服务器性能、网络状况是否良好等等。一般来说，主要是服务器与客户的距离会影响网站服务质量。距离过远就会导致，路由器的转发带来的网路延迟。</p>
</li>
<li><p>一个有效的方法就是利用内容分发与复制技术，<strong>将占网站主体的大部分静态网页、图像和流媒体数据分发复制到各地的加速节点上</strong>。用户访问时就能够直接从加速节点直接获取，而不需要再从远端的服务器上拉去，加速网络的访问质量</p>
</li>
</ul>
<h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><ul>
<li>Web缓存服务通过几种方式来改善用户的响应时间，如<strong>代理缓存服务、透明代理缓存服务、使用重定向服务的透明代理缓存服务</strong>等。通过Web缓存服务，用户访问网页时可以将广域网的流量降至最低，直接走最近的缓存服务器；用户直接访问服务商的缓存内容就可以了，而无需访问真是的服务器</li>
</ul>
<h1 id="CDN的应用场景"><a href="#CDN的应用场景" class="headerlink" title="CDN的应用场景"></a>CDN的应用场景</h1><ul>
<li><p>CDN的核心作用是<strong>提高网络的访问速度</strong>，那么其用户也就是<strong>访问量很大的网站</strong>，例如ICP 、ISP、大型企业、电子商务网站和政府网站等</p>
</li>
<li><p>使用CDN是公司或者其他部门不再需要投资昂贵的服务器和流量的问题。而只关心内容的更新。这样可以保证用户能够去做自己的新业务，同时也能保证其业务的质量。</p>
</li>
</ul>
<h1 id="CDN的不足"><a href="#CDN的不足" class="headerlink" title="CDN的不足"></a>CDN的不足</h1><ul>
<li><p>CDN也有自己的天然的缺点那就是————实时性；由于需要远距离保持同步所以还是会存在延迟</p>
</li>
<li><p><strong>解决方案</strong>：在网络 内容发生变化时将新的网络内容从服务器端直接传送到缓存器，或者当对网络内容的访问增加时将数据源服务器的网络内容尽可能实时地复制到缓存服务器.</p>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/seanxyh/archive/2013/04/16/3023499.html" target="_blank" rel="noopener">搞定CDN</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>python笔记网站记录</title>
    <url>/2020/03/22/python/python-network-note/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>

<ul>
<li><a href="https://www.jianshu.com/p/1e375fb40506" target="_blank" rel="noopener">python垃圾回收算法</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">python与ruby垃圾回收</a></li>
<li><a href="https://www.jianshu.com/p/dcc4c1af63c7" target="_blank" rel="noopener">python迭代器生成器</a></li>
<li><a href="https://www.jianshu.com/p/fb1d4dc8e367" target="_blank" rel="noopener">python内存管理机制</a></li>
<li><a href="https://www.cnblogs.com/hanmk/p/9215387.html" target="_blank" rel="noopener">pymysql基本使用</a></li>
<li><a href="https://pyecharts.org/#/zh-cn/quickstart" target="_blank" rel="noopener">pyecharts文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>网络IO模型</title>
    <url>/2020/03/22/linux/netowrk-io-module/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#五类网络io模型">五类网络IO模型</a></li>
<li><a href="#io-多路复用之selectpollepoll">I/O 多路复用之select、poll、epoll</a></li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="五类网络IO模型"><a href="#五类网络IO模型" class="headerlink" title="五类网络IO模型"></a>五类网络IO模型</h1><ul>
<li><h4 id="阻塞io："><a href="#阻塞io：" class="headerlink" title="阻塞io："></a><strong>阻塞io</strong>：</h4><p>  当进程发起调用后，系统没有将资源准备好，进程就会一直等待系统回复信号，等待系统将数据从硬件设备拷贝到内核空间，然后拷贝数据到用户空间，完成后系统才会返回信号；进程继续执行；此期间，该进程一直被挂起，不能做任何事情</p>
<p>  <img src="http://study.jeffqi.cn/linux/blocking_io.png" alt="blocking_io"></p>
</li>
<li><h4 id="非阻塞io："><a href="#非阻塞io：" class="headerlink" title="非阻塞io："></a><strong>非阻塞io</strong>：</h4><p>  当系统发起调用后，系统没有将资源准备好，但是会立即回复error，进程收到后知道数据没有准备好，于是会不断的询问，但是系统不会被阻塞，资源准备好后会将资源拷贝到用户空间；但会造成cpu空轮询，造成资源浪费；这时候一个进程可以处理多个连接请求；</p>
<p>  <img src="http://study.jeffqi.cn/linux/unblocking_io.png" alt="unblocking_io"></p>
</li>
<li><h4 id="io多路复用："><a href="#io多路复用：" class="headerlink" title="io多路复用："></a><strong>io多路复用</strong>：</h4><p>  进程发起调用后，会将一个fd注册过到select/poll中进程会阻塞在这个调用上；但是这一个进程可以同时处理多个连接请求，只需要经fd注册到select/poll中；不同于空轮询；io多路复用中内核会监控每一个fd的准备状态，任何一个准备好后，select/poll就会立即返回；然后轮询注册的fd，找到准备好的哪一个，然后将资源复制到用户空间；这样做避免了空轮询，但是每次都需要遍历所有的fd，找到准备好的fd，开销较大；而epoll就能避免遍历，当有fd准备好后，会直接返回这一个fd，进程直接就能知道是那个fd准备好时间复杂度为O(1)；节省了资源</p>
<p>  <img src="http://study.jeffqi.cn/linux/io_multiplexing.png" alt="io_multiplexing"></p>
</li>
<li><h4 id="信号io："><a href="#信号io：" class="headerlink" title="信号io："></a><strong>信号io</strong>：</h4><p>  调用后，系统立刻放回，不会阻塞进程；在资源准备好后，发送信号通知进程回调，将数据拷贝到用户空间</p>
</li>
<li><h4 id="异步io："><a href="#异步io：" class="headerlink" title="异步io："></a><strong>异步io</strong>：</h4><p>  发起调用后，立即返回，当资源拷贝到内核空间后，发送信号告诉进程资源已经在用户空间可以使用了</p>
<p>  <img src="http://study.jeffqi.cn/linux/async_io.png" alt="async_io"></p>
</li>
</ul>
<h1 id="I-O-多路复用之select、poll、epoll"><a href="#I-O-多路复用之select、poll、epoll" class="headerlink" title="I/O 多路复用之select、poll、epoll"></a>I/O 多路复用之select、poll、epoll</h1><ul>
<li><h3 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h3><p>  select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds；调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>有点：跨平台</li>
<li>监听的数量有限1024个</li>
</ol>
</li>
<li><h3 id="poll："><a href="#poll：" class="headerlink" title="poll："></a>poll：</h3><p>  不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor \*/</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch \*/</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed \*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a>epoll:</h3><p>  epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<ol>
<li><p>三个接口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</span><br><span class="line"><span class="comment">// - epfd：是epoll_create()的返回值。</span></span><br><span class="line"><span class="comment">// - op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL,修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</span></span><br><span class="line"><span class="comment">// - fd：是需要监听的fd（文件描述符）</span></span><br><span class="line"><span class="comment">// - epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</span></span><br><span class="line">      <span class="comment">// EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span></span><br><span class="line">      <span class="comment">// EPOLLOUT：表示对应的文件描述符可以写；</span></span><br><span class="line">      <span class="comment">// EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span></span><br><span class="line">      <span class="comment">// EPOLLERR：表示对应的文件描述符发生错误；</span></span><br><span class="line">      <span class="comment">// EPOLLHUP：表示对应的文件描述符被挂断；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">// 等待epfd上的io事件，最多返回maxevents个事件。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工作模式</p>
<ol>
<li><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
</li>
<li><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序 必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://blog.csdn.net/muyuyuzhong/article/details/83538860" target="_blank" rel="noopener">linux网络IO模型</a></li>
<li><a href="https://www.cnblogs.com/wlwl/p/10291397.html" target="_blank" rel="noopener">Linux五大网络IO模型图解</a></li>
<li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>redis基础学习</title>
    <url>/2020/03/22/redis/redis_base/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#redis基础">redis基础</a></li>
<li><a href="#数据类型">数据类型</a><ul>
<li><a href="#string类型">string类型</a></li>
<li><a href="#hash类型">hash类型</a></li>
<li><a href="#list类型">list类型</a></li>
<li><a href="#set类型">set类型</a></li>
<li><a href="#sort-set">sort set</a></li>
<li><a href="#高级用法">高级用法</a></li>
</ul>
</li>
<li><a href="#事务">事务</a></li>
<li><a href="#持久化">持久化</a></li>
<li><a href="#redis集群">redis集群</a><ul>
<li><a href="#主从模式">主从模式</a></li>
<li><a href="#sentinel模式哨兵模式">Sentinel模式（哨兵模式）</a></li>
<li><a href="#cluster模式">cluster模式</a></li>
</ul>
</li>
<li><a href="#redis失效机制与淘汰策略">redis失效机制与淘汰策略</a><ul>
<li><a href="#被动删除">被动删除</a></li>
<li><a href="#主动删除">主动删除</a></li>
<li><a href="#淘汰策略">淘汰策略</a></li>
<li><a href="#lru淘汰ttl淘汰与随机淘汰">lru淘汰、ttl淘汰与随机淘汰</a></li>
</ul>
</li>
<li><a href="#缓存相关">缓存相关</a><ul>
<li><a href="#缓存穿透">缓存穿透</a></li>
</ul>
</li>
<li><a href="#参考文案">参考文案</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="redis基础"><a href="#redis基础" class="headerlink" title="redis基础"></a>redis基础</h1><ul>
<li>基础学习</li>
</ul>
<p><img src="http://study.jeffqi.cn/mysql/redis_base_knowledge.jpg" alt="redis_base_knowledge"></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h2><p>String 类型是 Redis 中最常使用的类型，内部的实现是通过 SDS（Simple Dynamic String ）来存储的；类似python中内存池机制，预先申请一块内存来频繁创建释对象</p>
<p>这是最简单的类型，就是普通的 set 和 get，做简单的 KV 缓存</p>
<p><strong>string适用范围较广</strong></p>
<ul>
<li><p>缓存功能：String字符串是最常用的数据类型，不仅仅是Redis，各个语言都是最基本类型，因此，利用Redis作为缓存，配合其它数据库作为存储层，利用Redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p>
</li>
<li><p>计数器：许多系统都会使用Redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p>
</li>
<li><p>共享用户Session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存Cookie，但是可以利用Redis将用户的Session集中管理，在这种模式只需要保证Redis的高可用，每次用户Session的更新和获取都可以快速完成。大大提高效率。</p>
</li>
</ul>
<h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>这个是类似 Map 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在 Redis 里，然后每次读写缓存的时候，可以就操作 Hash 里的某个字段。</p>
<p>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p>
<h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p>List 是有序列表，可以玩儿出很多花样。</p>
<p>比如可以通过 List 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>
<p>比如可以通过 lrange 命令，读取某个闭区间内的元素，可以基于 List 实现分页查询，这个是很棒的一个功能，基于 Redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>
<p>比如可以搞个简单的消息队列，从 List 头怼进去，从 List 屁股那里弄出来。</p>
<p>List本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p>
<ul>
<li><p><strong>消息队列</strong>：<br>Redis的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p>
</li>
<li><p><strong>文章列表或者数据分页展示</strong>：<br>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用Redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率</p>
</li>
</ul>
<h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p><strong>Set 是无序集合，会自动去重的那种。</strong></p>
<p>直接基于 Set 将系统里需要去重的数据扔进去，自动就给去重了；如果你的某个系统部署在多台机器上呢？得基于Redis进行全局的 Set 去重。</p>
<p>可以基于 Set 玩儿<strong>交集、并集、差集</strong>的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁</p>
<p>对比很快，操作也简单</p>
<h2 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h2><p>Sorted set 是排序的 Set，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>
<p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而Sorted set可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择Sorted set数据结构作为选择方案。</p>
<ul>
<li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>
</li>
<li><p><strong>带权重</strong> 的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
<th>特性</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>String(字符串)</td>
<td>二进制安全</td>
<td>可以包含任何数据，比如jpg图片或者序列化的对象，一个键最大能存储512M</td>
<td></td>
</tr>
<tr>
<td>Hash(字典)</td>
<td>键值对集合，即编程语言中的Map类型</td>
<td>适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td>存储、读取、修改用户属性</td>
</tr>
<tr>
<td>List(列表)</td>
<td>链表(双向链表)</td>
<td>增删快，提供了操作某一段元素的API</td>
<td>1，最新消息排行等功能(比如朋友圈的时间线) 2，消息队列</td>
</tr>
<tr>
<td>Set(集合)</td>
<td>哈希表实现，元素不重复</td>
<td>1，添加、删除，查找的复杂度都是O(1) 2，为集合提供了求交集、并集、差集等操作</td>
<td>1，共同好友 2，利用唯一性，统计访问网站的所有独立ip 3，好用推荐时，根据tag求交集，大于某个阈值就可以推荐</td>
</tr>
<tr>
<td>Sorted Set(有序集合)</td>
<td>将Set中的元素增加一个权重参数score，元素按score有序排列</td>
<td>数据插入集合时，已经进行天然排序</td>
<td>1，排行榜 2，带权重的消息队列</td>
</tr>
</tbody></table>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><ul>
<li><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>位图是支持按 bit 位来存储信息，可以用来实现 布隆过滤器（BloomFilter）</p>
</li>
<li><h3 id="hyperLogLog"><a href="#hyperLogLog" class="headerlink" title="hyperLogLog"></a>hyperLogLog</h3><p>不精确的去重计数功能，比较适合用来做大规模数据的去重统计</p>
</li>
<li><h3 id="geospatial"><a href="#geospatial" class="headerlink" title="geospatial"></a>geospatial</h3><p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p>
</li>
</ul>
<p>这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你有点东西。</p>
<ul>
<li><h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3>功能是订阅发布功能，可以用作简单的消息队列。</li>
</ul>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis 提供了 RDB 和 AOF 两种持久化方式，RDB 是把<strong>内存中的数据集以快照形式写入磁盘</strong>，实际操作是通过 fork 子进程执行，采用二进制压缩存储；AOF 是<strong>以文本日志的形式记录 Redis 处理的每一个写入或删除操作</strong>。</p>
<ul>
<li><h2 id="rdb"><a href="#rdb" class="headerlink" title="rdb"></a>rdb</h2><ul>
<li><p><strong>工作原理及过程</strong>：RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，<strong>先将数据集写入临时文件，写入成功后，再替换之前的文件</strong>，用二进制压缩存储。RDB是Redis默认的持久化方式，会在对应的目录下生产一个dump.rdb文件，重启会通过加载dump.rdb文件恢复数据。</p>
</li>
<li><p>优点：</p>
<ol>
<li>只有一个文件dump.rdb，方便持久化；</li>
<li>容灾性好，一个文件可以保存到安全的磁盘；</li>
<li>性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化（使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能) ；</li>
<li>如果数据集偏大，RDB的启动效率会比AOF更高。</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li>数据安全性低。（RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不是特别严格的时候）</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
</li>
</ul>
</li>
<li><h2 id="aof"><a href="#aof" class="headerlink" title="aof"></a>aof</h2><ul>
<li><p><strong>工作原理及过程</strong>：AOF持久化是以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，文件中可以看到详细的操作记录。她的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个写操作，并追加到文件中。<strong>Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</strong></p>
</li>
<li><p>优点：</p>
<ol>
<li><p>数据安全性更高，AOF持久化可以配置appendfsync属性，其中always，每一次操作做都记录到日志中</p>
</li>
<li><p>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</p>
</li>
<li><p>AOF机制的rewrite模式。(AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>AOF文件较大，数据集大是效率低；启动时顺序执行日志，速度没有RDB快</p>
</li>
<li><p>同步策略不同，运行的效率也会慢于RDB</p>
</li>
</ol>
</li>
</ul>
</li>
<li><h2 id="redis启动加载过程"><a href="#redis启动加载过程" class="headerlink" title="redis启动加载过程"></a>redis启动加载过程</h2><ol>
<li><p>初始化全局服务器配置</p>
</li>
<li><p>加载配置文件（如果指定了配置文件，否则使用默认配置）</p>
</li>
<li><p>初始化服务器</p>
</li>
<li><p>加载数据库</p>
</li>
<li><p>网络监听</p>
</li>
</ol>
</li>
<li><h3 id="初始化服务器配置"><a href="#初始化服务器配置" class="headerlink" title="初始化服务器配置"></a>初始化服务器配置</h3><p>  初始化全局服务器配置通过initServerConfig()函数完成，主要是初始化server变量</p>
<ol>
<li>网络监听相关，如绑定地址，TCP端口等</li>
<li>虚拟内存相关，如swap文件、page大小等</li>
<li>保存机制，多长时间内有多少次更新才进行保存</li>
<li>复制相关，如是否是slave，master地址、端口</li>
<li>Hash相关设置</li>
<li>初始化命令表</li>
</ol>
</li>
<li><h3 id="加载配置文件"><a href="#加载配置文件" class="headerlink" title="加载配置文件"></a>加载配置文件</h3><p>  如果指定了配置文件，Redis使用loadServerConfig()函数加载配置文件，使用标准I/O库打开配置文件，循环读取每一行然后覆盖上一步进行的默认配置。</p>
<p>  <strong>如果不指定配置文件。redis不会使用默认配置文件的配置，而是使用上面初始化的参数皮遏制</strong></p>
</li>
<li><h3 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h3><p>  初始化服务器的工作在initServer()函数中，主要是完成前面未完成的工作，继续对server变量初始化</p>
</li>
<li><h3 id="加载数据库"><a href="#加载数据库" class="headerlink" title="加载数据库"></a>加载数据库</h3><p>  在完成了上面的所有的初始化工作之后，Redis开始加载数据到内存中，<strong>如果启用了appendonly了，则Redis从appendfile加载数据，否则就从dbfile加载数据</strong>。</p>
<ol>
<li><p>appendonly：在加载数据的时候只要重新执行一遍aof中的命令即可</p>
</li>
<li><p>dbfile：从数据库文件中加载数据到内存</p>
<ol>
<li>处理SELECT命令，即选择数据库</li>
<li>读取key</li>
<li>读取value</li>
<li>检测key是否过期</li>
<li>添加新的对象到哈希表</li>
<li>设置过期时间（如果需要）</li>
<li>如果开启了VM，处理swap操作</li>
</ol>
<p>加载流程图</p>
<p><img src="http://study.jeffqi.cn/linux/redis_reload_data.png" alt="redis_reload_data"></p>
</li>
</ol>
</li>
<li><h3 id="网络监听"><a href="#网络监听" class="headerlink" title="网络监听"></a>网络监听</h3><p>  在完成了初始化配置和数据加载后，Redis启动监听。</p>
</li>
</ul>
<h1 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h1><ul>
<li><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ol>
<li>主从模式</li>
<li>Sentinel模式</li>
<li>cluster模式</li>
</ol>
</li>
</ul>
<h2 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h2><ul>
<li><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>  当slave启动后，主动向master发送sync命令。master接受到SYNC命令后在后台保存快照并缓存在保存快照这段时间执行的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接受到快照文件和命令后加载快照文件和缓存的执行命令。</p>
</li>
<li><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>主数据库可以进行读写操作，当读写操作导致数据变化是自动同步到从数据库</li>
<li>从数据库只读，接受同步的数据</li>
<li>一个master可以拥有多个slave，一个slave只属于一个master</li>
<li>slave挂了不影响其他slave的读和master的读写，重启后自动同步数据</li>
<li><strong>master挂了，不影响slave的读，但redis不可以再写，不会重新进行master的选举</strong></li>
</ul>
</li>
<li><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>若master挂了，则redis无法对外提供写服务</li>
</ul>
</li>
</ul>
<h2 id="Sentinel模式（哨兵模式）"><a href="#Sentinel模式（哨兵模式）" class="headerlink" title="Sentinel模式（哨兵模式）"></a>Sentinel模式（哨兵模式）</h2><ul>
<li><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><ol>
<li>每个sentinel每秒钟发送一次ping命令个master、slave、sentinel，如果距离最后一次实例回复ping命令的时间操作预先设置的down-after-milliseconds就标记实例为主观下线</li>
<li>如果一个master被标记为主管下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线</li>
<li>如果有足够多的数量（设置的数值）的sentinel确认master进入主观下线，则这台master进入客观下线</li>
<li>sentinel默认每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令。当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次</li>
<li>如果没有足够多的sentinel同意master下线，；如果master重新上线向sentinel回复ping命令，master的主观下线状态就会被移除</li>
</ol>
</li>
<li><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>sentinel模式简历在主从模式之上</li>
<li>sentinel通过选举出一个新的redis实例作为master，通知其他节点修改配置，指向新的master</li>
<li>原master重新上线只能作为slave</li>
<li>需要保证master高可用</li>
</ul>
</li>
<li><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>当数据量过大，一台master无法存放，主从模式和sentinel模式都不能满足要求</li>
</ul>
</li>
</ul>
<h2 id="cluster模式"><a href="#cluster模式" class="headerlink" title="cluster模式"></a>cluster模式</h2><p>cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。</p>
<p>cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。</p>
<p>Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。</p>
<p>使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。</p>
<ul>
<li><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>多个redis实例之间网络互通，数据共享</li>
<li>所有节点都是一主一到多从，</li>
<li>支持在线扩展节点，删除节点</li>
<li>任意master节点可读写</li>
</ul>
</li>
</ul>
<h1 id="redis失效机制与淘汰策略"><a href="#redis失效机制与淘汰策略" class="headerlink" title="redis失效机制与淘汰策略"></a>redis失效机制与淘汰策略</h1><h2 id="被动删除"><a href="#被动删除" class="headerlink" title="被动删除"></a>被动删除</h2><ul>
<li>读写一个已过期的key，会触发删除操作，直接删除这个过期的key</li>
<li><h3 id="优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查"><a href="#优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查" class="headerlink" title="优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查"></a>优点：被动删除对cpu比较友好，不需要消耗cpu资源来主动检查</h3></li>
<li><h3 id="缺点：内存中可能存在较多的过期的key，导致资源浪费"><a href="#缺点：内存中可能存在较多的过期的key，导致资源浪费" class="headerlink" title="缺点：内存中可能存在较多的过期的key，导致资源浪费"></a>缺点：内存中可能存在较多的过期的key，导致资源浪费</h3></li>
</ul>
<h2 id="主动删除"><a href="#主动删除" class="headerlink" title="主动删除"></a>主动删除</h2><p>被动删除会导致一些冷数据的长时间停留，所以需要使用主动删除来解决这些冷数据的key</p>
<ul>
<li><h3 id="工作流程："><a href="#工作流程：" class="headerlink" title="工作流程："></a>工作流程：</h3><p>  redis周期性执行这个清除计划，默认100ms。每次循环随机抽取20个key进行检查，如果少于25%的可以是过期的key，则清除这些冷数据key，然后停止执行任务。否则会当前一轮的检查结束后，会开启下一轮的检查。这个任务的执行时间超过了一定时间，就会被终止，防止消耗过多cpu</p>
</li>
<li><h3 id="优点：对于冷数据的key能够及时的清理，防止占用过多内存"><a href="#优点：对于冷数据的key能够及时的清理，防止占用过多内存" class="headerlink" title="优点：对于冷数据的key能够及时的清理，防止占用过多内存"></a>优点：对于冷数据的key能够及时的清理，防止占用过多内存</h3></li>
<li><h3 id="缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检"><a href="#缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检" class="headerlink" title="缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检"></a>缺点：与被动删除相反，主动删除对cpu不友好，需要进行主动检</h3></li>
</ul>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>如果失效的key没有被访问，也未被主动删除随机选中，可能就会永久存在</p>
<p>所以redis中有一个maxmemory配置，即redis最大能使用的内存，当redis的使用内存达到这个值，会根据配置的淘汰策略，对redis的key进行淘汰。</p>
<ul>
<li><h3 id="六种淘汰策略"><a href="#六种淘汰策略" class="headerlink" title="六种淘汰策略"></a>六种淘汰策略</h3></li>
</ul>
<ol>
<li><p><strong>vlatile-lru</strong>:从设置过期时间的数据集（server.db[i].expires）中挑选出最近最少使用的数据淘汰。没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。</p>
</li>
<li><p><strong>vlatile-ttl</strong>:除了淘汰机制采用LRU，策略基本上与volatile-lru相似，从设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。</p>
</li>
<li><p><strong>vlatile-random</strong>:从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。当内存达到限制无法写入非过期时间的数据集时，可以通过该淘汰策略在主键空间中随机移除某个key。</p>
</li>
<li><p><strong>allkeys-lru</strong>:从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合。</p>
</li>
<li><p><strong>allkeys-random</strong>:从数据集(server.db[i].dict）中选择任意数据淘汰。</p>
</li>
<li><p><strong>no-enviction</strong>:禁止驱逐数据，也就是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失，这也是系统默认的一种淘汰策略。</p>
</li>
</ol>
<h2 id="lru淘汰、ttl淘汰与随机淘汰"><a href="#lru淘汰、ttl淘汰与随机淘汰" class="headerlink" title="lru淘汰、ttl淘汰与随机淘汰"></a>lru淘汰、ttl淘汰与随机淘汰</h2><ul>
<li><h3 id="lru淘汰"><a href="#lru淘汰" class="headerlink" title="lru淘汰"></a>lru淘汰</h3><p>  LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>  在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除</p>
<p>  在服务器配置中保存了 lru 计数器 server.lrulock，会定时（redis 定时程序 serverCorn()）更新，server.lrulock 的值是根据 server.unixtime 计算出来进行排序的，然后选择最近使用时间最久的数据进行删除</p>
</li>
<li><h3 id="ttl淘汰"><a href="#ttl淘汰" class="headerlink" title="ttl淘汰"></a>ttl淘汰</h3><p>  Redis 数据集数据结构中保存了键值对过期时间的表，即 redisDb.expires。与 LRU 数据淘汰机制类似，TTL 数据淘汰机制中会先从过期时间的表中随机挑选几个键值对，取出其中 ttl 最大的键值对淘汰。同样，TTL淘汰策略并不是面向所有过期时间的表中最快过期的键值对，而只是随机挑选的几个键值对。</p>
</li>
<li><h3 id="随机淘汰"><a href="#随机淘汰" class="headerlink" title="随机淘汰"></a>随机淘汰</h3><p>  在随机淘汰的场景下获取待删除的键值对，随机找hash桶再次hash指定位置的dictEntry即可。</p>
</li>
</ul>
<h1 id="缓存相关"><a href="#缓存相关" class="headerlink" title="缓存相关"></a>缓存相关</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><ul>
<li><p><strong>缓存穿透</strong>：如果我们查询一个不存在的数据，则会造成一直读取数据库，如果有人恶意攻击，则会造成数据库压力过大，甚至压垮服务器，这就是所谓的缓存穿透。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试</li>
<li>如果查询出的数据为空，也放入redis缓存，只是缓存时间设置短一些</li>
</ol>
</li>
<li><p><strong>缓存雪崩</strong>：redis缓存放入大量key，然后某个时间点缓存集中过期失效。此刻就会造成大量的请求过来都会去同时查询数据库，而不走redis缓存，数据库压力陡增，在秒杀，双11等场景下，很容易压垮服务器。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期.</li>
</ol>
</li>
<li><p><strong>缓存击穿</strong>：在某些特殊节点,一个热点数据被频繁访问,在失效的瞬间就会有大量的请求进来,导致部分越过缓存去读取数据库。</p>
</li>
<li><p>解决方案：</p>
<ol>
<li>双重校验（Dubbo Check）类似线程安全的懒汉单例模式实现，保证只会有一个线程去访问数据库。</li>
</ol>
</li>
</ul>
<h1 id="参考文案"><a href="#参考文案" class="headerlink" title="参考文案"></a>参考文案</h1><ul>
<li><a href="https://www.jianshu.com/p/b1b4eeccc140" target="_blank" rel="noopener">redis淘汰机制</a></li>
<li><a href="https://www.cnblogs.com/vieta/p/11192137.html" target="_blank" rel="noopener">redis配置</a></li>
<li><a href="https://www.cnblogs.com/happydreamzjl/p/11322937.html" target="_blank" rel="noopener">redis哨兵机制</a></li>
<li><a href="https://www.cnblogs.com/llaq/p/9470055.html" target="_blank" rel="noopener">redis缓存</a></li>
<li><a href="https://blog.csdn.net/hezhiqiang1314/article/details/69396887" target="_blank" rel="noopener">redis重写原理</a></li>
<li><a href="https://www.cnblogs.com/cuijl/p/7992433.html" target="_blank" rel="noopener">redis启动流程</a></li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>python内存管理机制</title>
    <url>/2020/03/21/python/python%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<ul>
<li><a href="#内存管理和垃圾回收机制">内存管理和垃圾回收机制</a><ul>
<li><a href="#内存管理">内存管理</a></li>
<li><a href="#垃圾回收机制">垃圾回收机制</a><ul>
<li><a href="#引用计数">引用计数</a></li>
<li><a href="#标记清除">标记清除</a></li>
<li><a href="#分代回收">分代回收</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->

</li>
</ul><h1 id="内存管理和垃圾回收机制"><a href="#内存管理和垃圾回收机制" class="headerlink" title="内存管理和垃圾回收机制"></a>内存管理和垃圾回收机制</h1><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol>
<li><p>Python 中一切皆对象，对象又可以分为可变对象和不可变对象。二者可以通过原地修改，如果修改后地址不变，则是可变对象，否则为不可变对象，地址信息可以通过id()进行查看</p>
<p><img src="http://study.jeffqi.cn/python/python_changeable_and_unchangeable_object.jpg" alt="python可变对象与不可变对象"></p>
</li>
<li><p>python有内存池机制，pymalloc机制来对内存进行申请和释放内存；当创建小的对象是，如果频繁使用c中的new/malloc会导致大量内存碎片，导致效率下降；所有python中使用内存池机制来解决这个问题；内存池先申请一块内存空间，然后分割成等大小的块数；有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<strong>Pymalloc会在内存池中申请空间，一般是少于256kb，如果是大的对象，则直接调用 new/malloc 来申请新的内存空间</strong></p>
</li>
</ol><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><ul>
<li>Python 采用 GC 作为自动内存管理机制，GC要做的有2件事，<strong>一是找到内存中无用的垃圾对象资源，二是清除找到的这些垃圾对象，释放内存给其他对象使用</strong></li>
<li>引用计数</li>
<li>标记清除</li>
<li>分代回收</li>
<li>引用计数为主，其余两种为辅助回收机制</li>
</ul>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><ol>
<li><p>查看源码，每一个对象，在源码里就是一个结构体表示，都会有一个计数字段.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">  <span class="keyword">int</span> ob_refcnt;    <span class="comment">//计数</span></span><br><span class="line">  struct_typeobject \*ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。</p>
</li>
</ol>
<ul>
<li>优点<ol>
<li>简单</li>
<li>实时性强，能够实时的无用的对象的内存进行释放</li>
</ol>
</li>
<li>缺点<ol>
<li>需要维护一个计数，占用额外的空间</li>
<li>循环引用：两个对象相互引用，且没有任何外部引用</li>
</ol>
</li>
</ul>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><ol>
<li>为了解决循环引用带来的可能导致内存泄露的问题</li>
<li><strong>第一阶段是标记阶段</strong>，GC会把所有的 活动对象 打上标记</li>
<li><strong>第二阶段是清除阶段</strong>，把那些没有标记的对象 非活动对象 进行回收</li>
<li>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。<br><img src="http://study.jeffqi.cn/python/mark-gc.jpg" alt="标记清除"></li>
<li>如上图中，1、2、3是可到达的，而4、5就是不可到达的需要被清理掉</li>
<li>标记清除主要是用来处理python中的容器对象如list、dict等；Python使用一个双向链表将这些容器对象组织起来</li>
<li>清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象</li>
</ol>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><ol>
<li>在python中没创建一个对象，就将对象放到一个链表中，如果有引用计数就加一；从而构成一个双向链表；这个链表就是零代链表；<br><img src="http://study.jeffqi.cn/python/gc-generator-1.png" alt="分代回收1"><br><img src="http://study.jeffqi.cn/python/gc-generator-2.png" alt="分代回收2"></li>
<li>检测循环引用：python会遍历零代链表，给每个计数减一，将计数为零的对象的内存释放掉；活着的对象进入下一代链表（一代链表）<br><img src="http://study.jeffqi.cn/python/gc-generator-3.png" alt="分代回收3"><br><img src="http://study.jeffqi.cn/python/gc-generator-4.png" alt="分代回收4"></li>
<li>弱代假说：在零代链表中的对象python默认会认为他们会很快更新，比如创建了一个临时对象；而经过一次筛选后的对象，python会认为他们会被经常使用到；同理在二代链表中也是如此；由于循环引用，导致分配计数和释放计数的比值越来越大，当到达一个阈值后，会触发收集器执行清理操作，对所有对象引用计数减一然后回收为零的对象，添加非零对象到下一代链表中；在下一代链表中也存在这一个阈值，不过python会认为下一代的使用时间更久，所以这个阈值会更大。</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.jianshu.com/p/fb1d4dc8e367" target="_blank" rel="noopener">https://www.jianshu.com/p/fb1d4dc8e367</a></li>
<li><a href="https://www.jianshu.com/p/1e375fb40506" target="_blank" rel="noopener">https://www.jianshu.com/p/1e375fb40506</a></li>
<li><a href="http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby" target="_blank" rel="noopener">http://patshaughnessy.net/2013/10/30/generational-gc-in-python-and-ruby</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构基础</title>
    <url>/2020/03/20/python/datastruct/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#八大数据结构">八大数据结构</a><ul>
<li><a href="#数组链表队列栈树图堆散列表">数组、链表、队列、栈、树、图、堆、散列表</a></li>
<li><a href="#数组">数组</a></li>
<li><a href="#栈">栈</a></li>
<li><a href="#队列">队列</a></li>
<li><a href="#链表">链表</a></li>
<li><a href="#树">树</a></li>
<li><a href="#散列表">散列表</a></li>
<li><a href="#堆">堆</a></li>
<li><a href="#图">图</a></li>
</ul>
</li>
<li><a href="#基础算法">基础算法</a><ul>
<li><a href="#冒泡排序">冒泡排序</a></li>
<li><a href="#插入排序">插入排序</a></li>
<li><a href="#选择排序">选择排序</a></li>
<li><a href="#归并排序">归并排序</a></li>
<li><a href="#快速排序">快速排序</a></li>
<li><a href="#扩展排序">扩展排序</a></li>
<li><a href="#二分查找">二分查找</a></li>
<li><a href="#树的遍历">树的遍历</a></li>
<li><a href="#单链表翻转">单链表翻转</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="八大数据结构"><a href="#八大数据结构" class="headerlink" title="八大数据结构"></a>八大数据结构</h1><h2 id="数组、链表、队列、栈、树、图、堆、散列表"><a href="#数组、链表、队列、栈、树、图、堆、散列表" class="headerlink" title="数组、链表、队列、栈、树、图、堆、散列表"></a>数组、链表、队列、栈、树、图、堆、散列表</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始</li>
<li>索引查询快；遍历速度快</li>
<li>扩容不方便，在内存中需要连续的存储空间；组只能存储一种类型的数据添加，删除的操作慢，因为要移动其他的元素。</li>
<li>使用场景：频繁查询，对存储空间要求不大，很少增加和删除的情况</li>
</ol>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈；</li>
<li>类似集装箱，先装入的后取出；所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ol>
<li>队列是一种特殊的线性表；不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队</li>
<li>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用</li>
</ol>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol>
<li>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等</li>
<li>优点：添加和删除元素熟读快；不需要连续的地址空间</li>
<li>缺点：需要额外的空间存储指针，不适合数据量大的场景；查找时比较麻烦</li>
<li>适用场景：数据量较小，需要频繁增加，删除操作的场景</li>
</ol>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ol>
<li>树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合</li>
<li>特点<ol>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ol>
</li>
<li>二叉树<ol>
<li>每个结点最多有两颗子树，结点的度最大为2。</li>
<li>左子树和右子树是有顺序的，次序不能颠倒。</li>
<li>即使某结点只有一个子树，也要区分左右子树。</li>
<li>增删数据，查询数据都比较快，适合处理大批量数据</li>
</ol>
</li>
</ol>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ol>
<li>散列表，也叫哈希表，是根据关键码和值 (key和value) 直接进行访问的数据结构，通过key和value来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</li>
<li><strong>记录的存储位置=f(key)</strong></li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：<ol>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ol>
</li>
<li>堆的定义如下：n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。(ki &lt;= k2i,ki &lt;= k2i+1)或者(ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)，满足前者的表达式的成为小顶堆，满足后者表达式的为大顶堆</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ol>
<li>图由节点的又穷集合和边的集合组成</li>
<li>图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法</li>
</ol>
<h1 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble</span><span class="params">(li: List, le: int)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> le &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, le - i - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j + <span class="number">1</span>]:</span><br><span class="line">                li[j], li[j + <span class="number">1</span>] = li[j + <span class="number">1</span>], li[j]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(li: List, le: int)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, le):</span><br><span class="line">        j, tmp = i - <span class="number">1</span>, li[i]</span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> li[j] &gt; tmp:</span><br><span class="line">            li[j + <span class="number">1</span>] = li[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        li[j + <span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(li: List, le: int)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(le):</span><br><span class="line">        min_index, min_value = i, li[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, le):</span><br><span class="line">            <span class="keyword">if</span> li[j] &lt; min_value:</span><br><span class="line">                min_value, min_index = li[j], j</span><br><span class="line">        li[i], li[min_index] = li[min_index], li[i]</span><br></pre></td></tr></table></figure>

<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gb</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">    gb(li, low, mid)</span><br><span class="line">    gb(li, mid + <span class="number">1</span>, high)</span><br><span class="line">    merger(li, low, mid, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merger</span><span class="params">(li, low, mid, high)</span>:</span></span><br><span class="line">    i, j = low, mid + <span class="number">1</span></span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= high:</span><br><span class="line">        <span class="keyword">if</span> li[i] &lt;= li[j]:</span><br><span class="line">            tmp.append(li[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(li[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    start = i <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> j</span><br><span class="line">    end = mid <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> high</span><br><span class="line">    tmp.extend(li[start: end + <span class="number">1</span>])</span><br><span class="line">    li[low: high + <span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><ul>
<li><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fast</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> low &gt;= high:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    number = random.randrange(low, high)</span><br><span class="line">    li[high], li[number] = li[number], li[high]</span><br><span class="line">    p = partition(li, low, high)</span><br><span class="line">    fast(li, low, p - <span class="number">1</span>)</span><br><span class="line">    fast(li, p + <span class="number">1</span>, high)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(li, low, high)</span>:</span></span><br><span class="line">    i, value = low, li[high]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(low, high):</span><br><span class="line">        <span class="keyword">if</span> li[j] &lt;= value:</span><br><span class="line">            li[i], li[j] = li[j], li[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    li[i], li[high] = li[high], li[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="双路排序"><a href="#双路排序" class="headerlink" title="双路排序"></a>双路排序</h3></li>
</ul>
<h2 id="扩展排序"><a href="#扩展排序" class="headerlink" title="扩展排序"></a>扩展排序</h2><ul>
<li><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3></li>
<li><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3></li>
<li><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3></li>
</ul>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li><h3 id="基本实现-1"><a href="#基本实现-1" class="headerlink" title="基本实现"></a>基本实现</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">half</span><span class="params">(li, low, high, value)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + (high - low) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> li[mid] &lt; value:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> li[mid] &gt; value:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="扩展二分"><a href="#扩展二分" class="headerlink" title="扩展二分"></a>扩展二分</h3></li>
</ul>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        print(root.value)</span><br><span class="line">        pre_order(root.left)</span><br><span class="line">        pre_order(root.right)</span><br><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_order_no</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    p = root</span><br><span class="line">    stack = [p]</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        print(p.value)</span><br><span class="line">        <span class="keyword">if</span> p.right:</span><br><span class="line">            stack.append(p.right)</span><br><span class="line">        <span class="keyword">if</span> p.left:</span><br><span class="line">            stack.append(p.left)</span><br><span class="line">        p = stack.pop()</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        in_order(root.left)</span><br><span class="line">        print(root.value)</span><br><span class="line">        in_order(root.right)</span><br><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_order</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    p = root</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">while</span> p <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> p:</span><br><span class="line">            stack.append(p)</span><br><span class="line">            p = p.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = stack.pop()</span><br><span class="line">            print(p.value)</span><br><span class="line">            p = p.right</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="后续遍历"><a href="#后续遍历" class="headerlink" title="后续遍历"></a>后续遍历</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root:</span><br><span class="line">        post_order(root.left)</span><br><span class="line">        post_order(root.right)</span><br><span class="line">        print(root.value)</span><br><span class="line"><span class="comment"># 非递归实现</span></span><br><span class="line"><span class="comment"># 后序打印二叉树（非递归）</span></span><br><span class="line"><span class="comment"># 使用两个栈结构</span></span><br><span class="line"><span class="comment"># 第一个栈进栈顺序：左节点-&gt;右节点-&gt;跟节点</span></span><br><span class="line"><span class="comment"># 第一个栈弹出顺序： 跟节点-&gt;右节点-&gt;左节点(先序遍历栈弹出顺序：跟-&gt;左-&gt;右)</span></span><br><span class="line"><span class="comment"># 第二个栈存储为第一个栈的每个弹出依次进栈</span></span><br><span class="line"><span class="comment"># 最后第二个栈依次出栈</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_order_no</span><span class="params">(node: TreeNode)</span>:</span></span><br><span class="line">    stack = [node]</span><br><span class="line">    stack2 = []</span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        stack2.append(node)</span><br><span class="line">        <span class="keyword">if</span> node.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">if</span> node.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">    <span class="keyword">while</span> len(stack2) &gt; <span class="number">0</span>:</span><br><span class="line">        print(stack2.pop().value)</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_order</span><span class="params">(root: TreeNode)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        queue = [root]</span><br><span class="line">    <span class="keyword">for</span> current <span class="keyword">in</span> queue:</span><br><span class="line">        <span class="keyword">print</span> current.value</span><br><span class="line">        <span class="keyword">if</span> current.left:</span><br><span class="line">            queue.append(current.left)</span><br><span class="line">        <span class="keyword">if</span> current.right:</span><br><span class="line">            queue.append(current.right)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="单链表翻转"><a href="#单链表翻转" class="headerlink" title="单链表翻转"></a>单链表翻转</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span><span class="params">(root: LinkNode)</span>:</span></span><br><span class="line">    pre, now, nex = <span class="literal">None</span>, root, root.next</span><br><span class="line">    <span class="keyword">while</span> now:</span><br><span class="line">        now.next = pre</span><br><span class="line">        pre = now</span><br><span class="line">        now = nex</span><br><span class="line">        nex = nex.next</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2020/03/20/python/python_base/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#文件操作">文件操作</a></li>
<li><a href="#函数">函数</a></li>
<li><a href="#命名空间和作用域">命名空间和作用域</a></li>
<li><a href="#函数-1">函数</a></li>
<li><a href="#装饰器">装饰器</a></li>
<li><a href="#迭代器生成器">迭代器生成器</a></li>
<li><a href="#推导式">推导式</a></li>
<li><a href="#内置函数和匿名函数">内置函数和匿名函数</a></li>
<li><a href="#模块和包">模块和包</a></li>
<li><a href="#常用的模块">常用的模块</a><ul>
<li><a href="#json模块">json模块</a></li>
<li><a href="#pickle模块">pickle模块</a></li>
<li><a href="#hashlib模块">hashlib模块</a></li>
<li><a href="#logging模块">logging模块</a></li>
<li><a href="#collections模块">collections模块</a></li>
<li><a href="#时间模块">时间模块</a></li>
<li><a href="#random模块">random模块</a></li>
<li><a href="#os模块">os模块</a></li>
<li><a href="#sys模块">sys模块</a></li>
<li><a href="#re正则模块">re正则模块</a></li>
</ul>
</li>
<li><a href="#异常处理">异常处理</a></li>
<li><a href="#面向对象编程">面向对象编程</a></li>
<li><a href="#类空间问题以及类之间的关系">类空间问题以及类之间的关系</a></li>
<li><a href="#继承">继承</a></li>
<li><a href="#面向对象编程特性继承封装多态">面向对象编程特性：继承，封装，多态</a></li>
<li><a href="#类的成员">类的成员</a></li>
<li><a href="#对象反射">对象反射</a></li>
<li><a href="#序列化">序列化</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol>
<li><p>打开一个文件包含两部分资源：操作系统级打开的文件+应用程序的变量。在操作完毕一个文件时，必须把与该文件的这两部分资源一个不落地回收</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1. 打开文件，得到文件句柄并赋值给一个变量</span></span><br><span class="line">f=open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="comment">#默认打开模式就为r</span></span><br><span class="line"><span class="comment">#2. 通过句柄对文件进行操作</span></span><br><span class="line">data=f.read()</span><br><span class="line"><span class="comment">#3. 关闭文件</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'a.txt'</span>,<span class="string">'r'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> read_f,open(<span class="string">'b.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">  data=read_f.read()</span><br><span class="line">  write_f.write(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件打开模式和编码</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>字符</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>只读模式【默认模式，文件必须存在，不存在则抛出异常】</td>
</tr>
<tr>
<td>w</td>
<td>只写模式【不可读；不存在则创建；存在则清空内容】</td>
</tr>
<tr>
<td>a</td>
<td>只追加写模式【不可读；不存在则创建；存在则只追加内容】</td>
</tr>
<tr>
<td>*b</td>
<td>r、w、a + b 使用二进制方式打开</td>
</tr>
<tr>
<td>r+</td>
<td>读写【可读，可写】覆盖写</td>
</tr>
<tr>
<td>w+</td>
<td>写读【可写，可读】覆盖写</td>
</tr>
<tr>
<td>a+</td>
<td>写读【可写，可读】追加写</td>
</tr>
<tr>
<td>r+b</td>
<td>读写【可读，可写】</td>
</tr>
<tr>
<td>w+b</td>
<td>写读【可写，可读】</td>
</tr>
<tr>
<td>a+b</td>
<td>写读【可写，可读】</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>文件输入与输出</p>
<ol>
<li><p>输出</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f.read(size)：读多少字节，默认为一次性读完</span><br><span class="line">f.readline()：读一行，默认为‘\n’符号</span><br><span class="line">f.readlines()：读所有行，符号为 \n</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">f.write(<span class="string">'xxxx'</span>)：写入</span><br></pre></td></tr></table></figure>
</li>
<li><p>f.tell()：返回当前文件指正</p>
</li>
<li><p>f.seek()：如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">seek(x,<span class="number">0</span>) ： 从起始位置即文件首行首字符开始移动 x 个字符</span><br><span class="line">seek(x,<span class="number">1</span>) ： 表示从当前位置往后移动x个字符</span><br><span class="line">seek(-x,<span class="number">2</span>)：表示从文件的结尾往前移动x个字符</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ol>
<li><p>return关键字的作用</p>
<ol>
<li>return 是一个关键字，这个词翻译过来就是“返回”，所以我们管写在return后面的值叫“返回值”。</li>
<li>不写return的情况下，会默认返回一个None</li>
<li>一旦遇到return，结束整个函数。</li>
<li>返回的多个值会被组织成元组被返回，也可以用多个值来接收</li>
</ol>
</li>
<li><p>函数的参数</p>
<ol>
<li><p>按照位置传值：位置参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span>   </span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字参数：在调用函数时，按照key=value的形式定义的实参，称为关键字参数</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">fun(x=<span class="number">1</span>,y=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置、关键字形式混着用：混合传参；结合上面两种</p>
<ol>
<li><strong>位置参数必须在关键字参数的前面<br>对于一个形参只能赋值一次</strong></li>
</ol>
</li>
<li><p>默认参数:<strong>默认参数是一个可变数据类型</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(x=<span class="number">1</span>)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname()</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态参数：动态参数，也叫不定长传参，就是你需要传给函数的参数很多，<strong>不定个数</strong>，那这种情况下，你就用<em>args，*</em>kwargs接收，<strong>args是元祖形式</strong>，接收除去键值对以外的所有参数，<strong>kwargs接收的只是键值对的参数</strong>，并保存在字典中</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fname</span><span class="params">(*arg, **kwargs)</span>:</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">fname(<span class="string">'aaron'</span>,<span class="number">1</span>,<span class="number">3</span>,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>],&#123;<span class="string">'a'</span>:<span class="number">123</span>,<span class="string">'b'</span>:<span class="number">321</span>&#125;,country=<span class="string">'china'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>形参、实参：</p>
<ol>
<li>形参：定义函数时的参数</li>
<li>实参：调用函数时的参数</li>
<li>根据实际参数类型不同，将实际参数传递给形参的方式有两种：值传递和引用传递<ol>
<li>值传递：实参为不可变对象，传递给形参后，形参的值改变，实参值不变。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li>引用传递：实参为可变对象，传递给形参后，形参的值改变，实参值改变。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ol>
</li>
</ol>
</li>
<li><p>形式参数前加 * 号表示可变长参数，实参前加 * 号表示解包，将list或者tuple内的元素提取出来</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a, *args)</span>:</span></span><br><span class="line">  print(<span class="string">'a:%s'</span> % a)</span><br><span class="line">  print(<span class="string">'args:'</span>, end=<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">      print(i, end=<span class="string">' '</span>)</span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">fun(*li)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">a:<span class="number">1</span></span><br><span class="line">args: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h1><ol>
<li><p>创建的存储“变量名与值的关系”的空间叫做全局命名空间；在函数的运行中开辟的临时的空间叫做局部命名空间</p>
</li>
<li><p>类型：</p>
<ol>
<li>全局</li>
<li>局部</li>
<li>内置</li>
</ol>
</li>
<li><p>调用顺序</p>
<ol>
<li>局部调用：局部&gt;全局&gt;内置</li>
<li>全局调用：全局&gt;内置</li>
</ol>
</li>
<li><p>作用域</p>
<ol>
<li>全局作用域：包含内置名称空间、全局名称空间，在整个文件的任意位置都能被引用、全局有效</li>
<li>局部作用域：局部名称空间，只能在局部范围内生效</li>
</ol>
</li>
<li><p>globals和locals方法</p>
<ol>
<li><p>global</p>
<ol>
<li>声明一个全局变量。</li>
<li>在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字)。可变数据类型可以直接引用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> a</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">func()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count = <span class="number">2</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">search()</span><br><span class="line">print(count)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>local</p>
<ol>
<li>不能修改全局变量</li>
<li>在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_b</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_global</span><span class="params">()</span>:</span></span><br><span class="line">        b = <span class="number">10</span></span><br><span class="line">        print(b)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dd_nolocal</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">nonlocal</span> b <span class="comment"># 父级改变</span></span><br><span class="line">            b = b + <span class="number">20</span></span><br><span class="line">            print(b)</span><br><span class="line">        dd_nolocal()</span><br><span class="line">        print(b)</span><br><span class="line">    do_global()</span><br><span class="line">    print(b)</span><br><span class="line">add_b()</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h1><ol>
<li>函数名本质上就是函数的内存地址；可以被引用；可以当做容器元素存在如list中；可以作为返回值</li>
<li>闭包：内层函数对于外层函数定义的变量的调用<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">out</span><span class="params">()</span>:</span></span><br><span class="line">  name = <span class="string">'hjq'</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">  print(inner.__closure__)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><ol>
<li><p>让其他函数在不需要做任何代码变动的前提下，增加额外的功能，装饰器的返回值也是一个函数对象。装饰器的应用场景：比如插入日志，性能测试，事务处理，缓存等等场景</p>
</li>
<li><p>函数可以作为参数传递给另一个函数，但是使用比较麻烦；使用装饰器更加简便</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        print(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'in func1'</span>)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure>
</li>
<li><p>加上装饰器后函数的信息就失效了，可以使用 @wrap(fun_name) 装饰器保留原函数的信息</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开放封闭原则</strong></p>
<ol>
<li>开放封闭原则的核心的思想是软件实体是可扩展，而不可修改的。<ol>
<li>对扩展是开放的</li>
<li>对修改是封闭的</li>
</ol>
</li>
</ol>
</li>
<li><p>多个装饰器</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'第一个装饰器，在程序运行之前'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'第一个装饰器，在程序运行之后'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'第二个装饰器，在程序运行之前'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'第二个装饰器，在程序运行之后'</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="meta">@wrapper1</span></span><br><span class="line"><span class="meta">@wrapper2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Hello'</span>)</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">f()</span><br><span class="line"><span class="comment">## 结果</span></span><br><span class="line">第一个装饰器，在程序运行之前</span><br><span class="line">第二个装饰器，在程序运行之前</span><br><span class="line">Hello</span><br><span class="line">第二个装饰器，在程序运行之后</span><br><span class="line">第一个装饰器，在程序运行之后</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="迭代器生成器"><a href="#迭代器生成器" class="headerlink" title="迭代器生成器"></a>迭代器生成器</h1><ol>
<li>可迭代对象：可以使用for循环遍历的对象</li>
<li>可迭代协议：可以被迭代要满足的要求就叫做可迭代协议。可迭代协议的定义非常简单，就是内部实现了iter方法来返回一个迭代器对象</li>
<li>迭代器：内部实现了iter方法和next方法；迭代器惰性计算，同一时刻在内存中只出现一条数据，极大限度的节省了内存；只有在需要时才会生成</li>
<li>for循环遍历可迭代对象<ol>
<li>将可迭代对象转化成迭代器。（可迭代对象.iter()）</li>
<li>内部使用next方法，一个一个取值。</li>
<li>加了异常处理功能，取值到底后自动停止。</li>
</ol>
</li>
<li>生成器：常规函数定义，但是，使用yield语句而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次重它离开的地方继续执行</li>
<li>生成器协议：类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表</li>
</ol>
<h1 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">&#123;k.lower():dic1.get(k.lower(),<span class="number">0</span>) + dic1.get(k.upper(),<span class="number">0</span>) <span class="keyword">for</span> k <span class="keyword">in</span> dic1.keys()&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内置函数和匿名函数"><a href="#内置函数和匿名函数" class="headerlink" title="内置函数和匿名函数"></a>内置函数和匿名函数</h1><ol>
<li><p>作用域相关</p>
<ul>
<li>locals():函数会以字典的类型返回当前位置的全部局部变量</li>
<li>globals():：函数以字典的类型返回全部全局变量</li>
</ul>
</li>
<li><p>字符串类型代码的执行 eval，exec，complie</p>
<ul>
<li><p>eval：执行字符串代码返回结果；只能执行一行代码</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">ret = eval(<span class="string">'2 + 2'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>
</li>
<li><p>exec：执行字符串代码；可以执行多行代码，但是拿不到结果</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'''</span></span><br><span class="line"><span class="string">for i in range(5):</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">exec(s)</span><br></pre></td></tr></table></figure>
</li>
<li><p>complie：:将字符串类型的代码编译。代码对象能够通过exec语句来执行或者eval()进行求值</p>
<ol>
<li>数source：字符串。即需要动态执行的代码段。</li>
<li>参数 filename：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。当传入了source参数时，filename参数传入空字符即可。</li>
<li>参数model：指定编译代码的种类，可以指定为 ‘exec’,’eval’,’single’。<strong>当source中包含流程语句时，model应指定为‘exec’；当source中只包含一个简单的求值表达式，model应指定为‘eval’；当source中包含了交互式命令语句，model应指定为’single’</strong><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"for i in range(0,10): print(i)"</span></span><br><span class="line">c = compile(str,<span class="string">''</span>,<span class="string">'exec'</span>)</span><br><span class="line">exec(c)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</li>
<li><p>输入输出</p>
<ul>
<li>input():函数接受一个标准输入数据，返回为 string 类型</li>
<li>print():标准输出</li>
</ul>
</li>
<li><p>内存相关</p>
<ul>
<li>hash()：获取对象（可哈希对象：int，str，Bool，tuple）的hash值</li>
<li>id()：获取内存地址</li>
</ul>
</li>
<li><p>文件操作相关</p>
<ul>
<li>open()：函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写</li>
</ul>
</li>
<li><p>调用相关</p>
<ul>
<li>callable：函数用于检查一个对象是否是可调用  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo1</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">print(callable(demo1))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>内置属性</p>
<ul>
<li>dir()：函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法</li>
</ul>
</li>
<li><p>迭代器生成器相关</p>
<ul>
<li>range：函数可创建一个整数对象，一般用在 for 循环中。</li>
<li>next：内部实际使用了<strong>next</strong>方法，返回迭代器的下一个项目</li>
</ul>
</li>
<li><p>基础数据类型</p>
<ul>
<li>bool ：用于将给定参数转换为布尔类型，如果没有参数，返回 False。</li>
<li>int：函数用于将一个字符串或数字转换为整型。</li>
<li>float：函数用于将整数和字符串转换成浮点数。</li>
<li>complex：函数用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数。。</li>
</ul>
</li>
<li><p>进制转换</p>
<ul>
<li>bin：将十进制转换成二进制并返回。</li>
<li>oct：将十进制转化成八进制字符串并返回。</li>
<li>hex：将十进制转化成十六进制字符串并返回。</li>
</ul>
</li>
<li><p>数学运算</p>
<ul>
<li>abs：函数返回数字的绝对值。</li>
<li>divmod：计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。</li>
<li>round：保留浮点数的小数位数，默认保留整数。</li>
<li>pow：函数是计算x的y次方，如果z在存在，则再对结果进行取模，其结果等效于pow(x,y) %z）</li>
<li>sum：对可迭代对象进行求和计算（可设置初始值）。</li>
<li>min：返回可迭代对象的最小值（可加key，key为函数名，通过函数的规则，返回最小值）。</li>
<li>max：返回可迭代对象的最大值（可加key，key为函数名，通过函数的规则，返回最大值）</li>
</ul>
</li>
<li><p>数据结构</p>
<ul>
<li>list()：将一个可迭代对象转化成列表（如果是字典，默认将key作为列表的元素）。</li>
<li>tuple()：将一个可迭代对象转化成元祖（如果是字典，默认将key作为元祖的元素）。</li>
<li>dict()：创建一个字典。</li>
<li>set()：创建一个集合。</li>
<li>frozenset()：返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</li>
</ul>
</li>
<li><p>内置函数</p>
<ul>
<li><p>reversed()：翻转一个列表生成<strong>迭代器</strong></p>
</li>
<li><p>str()：将数据转化成字符串。</p>
</li>
<li><p>bytes():用于不同编码之间转换</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'你好'</span></span><br><span class="line">bs = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">s1 = bs.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(s1)</span><br><span class="line">bs = bytes(s, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">print(bs)</span><br><span class="line">b = <span class="string">'你好'</span>.encode(<span class="string">'gbk'</span>)</span><br><span class="line">b1 = b.decode(<span class="string">'gbk'</span>)</span><br><span class="line">print(b1.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>len():返回一个对象中元素的个数。</p>
</li>
<li><p>sorted()：对所有可迭代的对象进行排序操作</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">print(sorted(l, key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)) <span class="comment"># 降序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>filter()：用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p>
  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span> <span class="keyword">return</span> x%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">ret = filter(func,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ret:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>匿名函数</p>
<ul>
<li>为了解决那些功能很简单的需求而设计的一句话函数</li>
<li>函数名 = lambda 参数 ：返回值<ol>
<li>参数可以有多个，用逗号隔开</li>
<li>匿名函数不管逻辑多复杂，只能写一行，且逻辑执行结束后的内容就是返回值</li>
<li>返回值和正常的函数一样可以是任意数据类型<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">l=[<span class="number">3</span>,<span class="number">2</span>,<span class="number">100</span>,<span class="number">999</span>,<span class="number">213</span>,<span class="number">1111</span>,<span class="number">31121</span>,<span class="number">333</span>]</span><br><span class="line">print(max(l))</span><br><span class="line">dic=&#123;<span class="string">'k1'</span>:<span class="number">10</span>,<span class="string">'k2'</span>:<span class="number">100</span>,<span class="string">'k3'</span>:<span class="number">30</span>&#125;</span><br><span class="line">print(max(dic))</span><br><span class="line">print(dic[max(dic,key=<span class="keyword">lambda</span> k:dic[k])])</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h1><ol>
<li><p>什么是模块</p>
<ul>
<li>使用python编写的代码（.py文件）</li>
<li>已被编译为共享库或DLL的C或C++扩展</li>
<li>包好一组模块的包</li>
<li>使用C编写并链接到python解释器的内置模块</li>
</ul>
</li>
<li><p>为什么要使用模块</p>
<ol>
<li>实现代码和功能的复用性</li>
</ol>
</li>
<li><p>import module_name</p>
<ul>
<li>模块可以包含可执行的语句和函数的定义，这些语句的目的是初始化模块，<strong>它们只在模块名第一次遇到导入import语句时才执行</strong></li>
<li>第一次导入后就将模块名加载到内存了，后续的import语句仅是对已经加载大内存中的模块对象增加了一次引用，不会重新执行模块内的语句</li>
</ul>
</li>
<li><p>import时做的事情</p>
<ol>
<li>为模块创建新的命名空间</li>
<li>在新的命名空间中执行模块中的代码函数</li>
<li><strong>创建名字来引用这个命名空间</strong></li>
</ol>
</li>
<li><p>from import</p>
<ul>
<li>from 语句相当于import，也会创建新的名称空间，<strong>但是将my_module中的名字直接导入到当前的名称空间中</strong>，在当前名称空间中，直接使用名字就可以了</li>
<li>from my_module import * 把<strong>my_module中所有的不是以下划线(_)开头的名字都导入到当前位置</strong>，这样做可能造成覆盖掉你之前的定义的名字</li>
<li>想从包api中导入所有，实际上该语句只会导入包api下<strong>init</strong>.py文件中定义的名字，我们可以在这个文件中定义<strong>all</strong>  <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'from api.__init.py'</span>)</span><br><span class="line">__all__=[<span class="string">'x'</span>,<span class="string">'func'</span>,<span class="string">'policy'</span>]</span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>模块搜索路径</p>
<ol>
<li>内存中已经加载的模块-&gt;内置模块-&gt;sys.path路径中包含的模块</li>
</ol>
</li>
<li><p>编译python文件</p>
<ul>
<li>为了提高加载模块的速度，python解释器会在<strong>pycache</strong>目录中下缓存每个模块编译后的版本</li>
</ul>
</li>
<li><p>绝对导入和相对导入</p>
<ol>
<li>绝对导入<ol>
<li>优点：执行文件与被导入的模块中都可以使用</li>
<li>缺点：比较麻烦写入路径名称</li>
</ol>
</li>
<li>相对导入<ol>
<li>优点：方便</li>
<li>缺点：只能在导入包中的模块时才能使用</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="常用的模块"><a href="#常用的模块" class="headerlink" title="常用的模块"></a>常用的模块</h1><h2 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h2><ol>
<li>Json模块提供了四个功能：dumps、dump、loads、load</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>ensure_ascii</td>
<td>当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可，此时存入json的中文即可正常显示。</td>
</tr>
<tr>
<td>separators</td>
<td>分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开。</td>
</tr>
</tbody></table>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">data = &#123;<span class="string">'name'</span>:<span class="string">'陈松'</span>,<span class="string">'sex'</span>:<span class="string">'female'</span>,<span class="string">'age'</span>:<span class="number">88</span>&#125;</span><br><span class="line">json_dic2 = json.dumps(data,sort_keys=<span class="literal">True</span>,indent=<span class="number">2</span>,separators=(<span class="string">','</span>,<span class="string">':'</span>),ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">print(json_dic2)</span><br></pre></td></tr></table></figure>

<h2 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h2><ol>
<li><p>pickle模块提供了四个功能：dumps、dump(序列化，存）、loads（反序列化，读）、load<br>不仅可以序列化字典，列表…可以把python中任意的数据类型序列化</p>
</li>
<li><p>区别</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>模块</th>
<th>区别</th>
</tr>
</thead>
<tbody><tr>
<td>json</td>
<td>用于字符串 和 python数据类型间进行转换</td>
</tr>
<tr>
<td>pickle</td>
<td>用于python特有的类型 和 python的数据类型间进行转换</td>
</tr>
</tbody></table>
<h2 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h2><ol>
<li>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line">md5.update(<span class="string">'how to use md5 in python hashlib?'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment"># md5.update('how to use md5 in python hashlib?'.encode('utf-8')) # 多次调用</span></span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果数据大，可以分块多次调用update()，最后计算的结果是一样的</li>
</ol>
<h2 id="logging模块"><a href="#logging模块" class="headerlink" title="logging模块"></a>logging模块</h2><ol>
<li>日志等级<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)  </span><br><span class="line">logging.info(<span class="string">'info message'</span>)  </span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)  <span class="comment"># （默认）</span></span><br><span class="line">logging.error(<span class="string">'error message'</span>)  </span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    format=<span class="string">'%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s'</span>,</span><br><span class="line">                    datefmt=<span class="string">'%a, %d %b %Y %H:%M:%S'</span>,</span><br><span class="line">                    filename=<span class="string">'test.log'</span>,</span><br><span class="line">                    filemode=<span class="string">'w'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">logging.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logging.info(<span class="string">'info message'</span>)</span><br><span class="line">logging.warning(<span class="string">'warning message'</span>)</span><br><span class="line">logging.error(<span class="string">'error message'</span>)</span><br><span class="line">logging.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>解释</p>
<ol>
<li>logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：</li>
<li>filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。</li>
<li>filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</li>
<li>format：指定handler使用的日志显示格式。</li>
<li>datefmt：指定日期时间格式。</li>
<li>level：设置rootlogger（后边会讲解具体概念）的日志级别</li>
<li>stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open- (‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</li>
<li>format参数中可能用到的格式化串：<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “<span class="number">2003</span><span class="number">-07</span><span class="number">-08</span> <span class="number">16</span>:<span class="number">49</span>:<span class="number">45</span>,<span class="number">896</span>”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s用户输出的消息</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>logger对象设置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"><span class="comment"># 创建一个handler，用于写入日志文件</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">'test.log'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 再创建一个handler，用于输出到控制台</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line">fh.setLevel(logging.DEBUG)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line">logger.addHandler(fh) <span class="comment">#logger对象可以添加多个fh和ch对象</span></span><br><span class="line">logger.addHandler(ch)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h2><ol>
<li><p>在内置数据类型（dict、list、set、tuple）的基础上，collections模块还提供了几个额外的数据类型：Counter、deque、defaultdict、namedtuple和OrderedDict等</p>
<ol>
<li>namedtuple: 生成可以使用名字来访问元素内容的tuple</li>
<li>deque: 双端队列，可以快速的从另外一侧追加和推出对象</li>
<li>Counter: 计数器，主要用来计数</li>
<li>OrderedDict: 有序字典</li>
<li>defaultdict: 带有默认值的字典</li>
</ol>
</li>
<li><p>namedtuple</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line">point = namedtuple(<span class="string">'point'</span>,[<span class="string">'x'</span>,<span class="string">'y'</span>])</span><br><span class="line">p = point(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(p.x)</span><br></pre></td></tr></table></figure>
</li>
<li><p>deque</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">q = deque([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">q.append(<span class="string">'x'</span>)</span><br><span class="line">q.appendleft(<span class="string">'y'</span>)</span><br><span class="line"></span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>
</li>
<li><p>OrderedDict</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = dict([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>),(<span class="string">'c'</span>,<span class="number">3</span>)])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line">od = OrderedDict([(<span class="string">'a'</span>,<span class="number">1</span>),(<span class="string">'b'</span>,<span class="number">2</span>),(<span class="string">'c'</span>,<span class="number">3</span>)])</span><br><span class="line">print(od)</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultdict</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">li = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line">result=defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> li:</span><br><span class="line">    <span class="keyword">if</span> row &gt; <span class="number">66</span>:</span><br><span class="line">        result[<span class="string">'key1'</span>].append(row)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result[<span class="string">'key2'</span>].append(row)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>counter</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="string">'qazxswqazxswqazxswsxaqwsxaqws'</span>)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><ol>
<li>time.sleep(secs)：(线程)推迟指定的时间运行。单位为秒。</li>
<li>time.time()：获取当前时间戳</li>
<li>格式：时间戳、元祖、格式化显示</li>
</ol>
<table>
<thead>
<tr>
<th>格式化</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>%y</td>
<td>两位数的年份表示（00-99）</td>
</tr>
<tr>
<td>%Y</td>
<td>四位数的年份表示（000-9999）</td>
</tr>
<tr>
<td>%m</td>
<td>月份（01-12）</td>
</tr>
<tr>
<td>%d</td>
<td>月内中的一天（0-31）</td>
</tr>
<tr>
<td>%H</td>
<td>24小时制小时数（0-23）</td>
</tr>
<tr>
<td>%I</td>
<td>12小时制小时数（01-12）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟数（00=59）</td>
</tr>
<tr>
<td>%S</td>
<td>秒（00-59）</td>
</tr>
</tbody></table>
<ol start="4">
<li>时间转换<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化时间 ----&gt;  结构化时间</span></span><br><span class="line">ft = time.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br><span class="line">st = time.strptime(ft,<span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br><span class="line">print(st)</span><br><span class="line"><span class="comment"># 结构化时间 ---&gt; 时间戳</span></span><br><span class="line">t = time.mktime(st)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间戳 ----&gt; 结构化时间</span></span><br><span class="line">t = time.time()</span><br><span class="line">st = time.localtime(t)</span><br><span class="line">print(st)</span><br><span class="line"><span class="comment"># 结构化时间 ---&gt; 格式化时间</span></span><br><span class="line">ft = time.strftime(<span class="string">'%Y/%m/%d %H:%M:%S'</span>,st)</span><br><span class="line">print(ft)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h2><ol>
<li>随机模块<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">random.randint(m, n)：m、n之间的随机数</span><br><span class="line">random.randrange(m, n, s)：m、n之间的随机数，步长s</span><br><span class="line">random.choice(argv)：从argv中随机选择其中的数据</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><ol>
<li>os模块是与操作系统交互的一个接口<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">os.remove() 删除文件</span><br><span class="line">os.rename() 重命名文件</span><br><span class="line">os.listdir() 列出指定目录下所有文件</span><br><span class="line">os.chdir() 改变当前工作目录</span><br><span class="line">os.getcwd() 获取当前文件路径</span><br><span class="line">os.mkdir() 新建目录</span><br><span class="line">os.rmdir() 删除空目录(删除非空目录, 使用shutil.rmtree())</span><br><span class="line">os.makedirs() 创建多级目录</span><br><span class="line">os.removedirs() 删除多级目录</span><br><span class="line">os.wait() 暂时未知</span><br><span class="line">os.path模块：</span><br><span class="line">os.path.split(filename) 将文件路径和文件名分割(会将最后一个目录作为文件名而分离)</span><br><span class="line">os.path.dirname(filename) 返回文件路径的目录部分</span><br><span class="line">os.path.basename(filename) 返回文件路径的文件名部分</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><ol>
<li>sys模块是与python解释器交互的一个接口<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sys.argv：命令行参数类似shell的参数</span><br><span class="line">sys.exit(n)：退出程序返回一个字节码</span><br><span class="line">sys.version：python解释器信息</span><br><span class="line">sys.path：模块搜索路径</span><br><span class="line">sys.platfrom：平台信息</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="re正则模块"><a href="#re正则模块" class="headerlink" title="re正则模块"></a>re正则模块</h2><ol>
<li>re.match(pattern, string, flags=0)：re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</li>
<li>re.search(pattern, string, flags=0)：扫描整个字符串并返回第一个成功的匹配</li>
<li>findall(string[, pos[, endpos]])：在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表；<strong>match 和 search 是匹配一次 findall 匹配所有。</strong></li>
</ol>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><ol>
<li><p>为每一种异常定制了一个类型，然后提供了一种特定的语法结构用来进行异常处理</p>
</li>
<li><p>基本语法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">     被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型：</span><br><span class="line">     执行的操作</span><br><span class="line"><span class="comment">#try中一旦检测到异常，就执行这个位置的逻辑</span></span><br><span class="line"><span class="comment">## 多分支，通用异常，else方法，finally</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    int(s1)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># 通用异常捕获</span></span><br><span class="line">   print(e)</span><br><span class="line"><span class="keyword">else</span>:   <span class="comment"># try 正常执行时，跳转到这个</span></span><br><span class="line">    print(<span class="string">'try内代码块没有异常则执行我'</span>)</span><br><span class="line"><span class="keyword">finally</span>:  <span class="comment"># 无论如何都会运行</span></span><br><span class="line">    print(<span class="string">'无论异常与否,都会执行该模块,通常是进行清理工作'</span>)</span><br><span class="line"><span class="comment">## 主动抛出异常</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'类型错误'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
</li>
<li><p>异常操作的优点</p>
<ol>
<li>把错误处理和真正的工作分开来</li>
<li>代码更易组织，更清晰，复杂的工作任务更容易实现</li>
<li>毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了</li>
</ol>
</li>
</ol>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><ol>
<li><p>面向对象编程的优点</p>
<ol>
<li>少代码的重用性。</li>
<li>增强代码的可读性。</li>
</ol>
</li>
<li><p>构造</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""docstring for ."""</span></span><br><span class="line">  var = <span class="string">'string'</span>  <span class="comment"># 静态变量，静态属性</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span>  <span class="comment"># 方法、函数、动态属性</span></span><br><span class="line">    super(, self).__init__()</span><br><span class="line">    self.arg = arg</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建对象</p>
<ol>
<li>在内存中开辟了一个对象空间。</li>
<li>自动执行类中的init方法，并将这个对象空间（内存地址）传给了init方法的第一个位置参数self。</li>
<li>在init 方法中通过self给对象空间添加属性。</li>
</ol>
</li>
<li><p>操作和类中的属性：通过万能的点 . 进行操作；查看对象和类中的所有内容可以通过 <strong>dic</strong> 来查看</p>
</li>
<li><p>类中的方法都会有一个self参数。因为一般情况下这些方法都是通过对象来执行的。在执行的时候将对象的地址空间传给第一个参数，这个self就是对象本省</p>
</li>
</ol>
<h1 id="类空间问题以及类之间的关系"><a href="#类空间问题以及类之间的关系" class="headerlink" title="类空间问题以及类之间的关系"></a>类空间问题以及类之间的关系</h1><ol>
<li><p>类和对象都可以在内外部添加</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self, sex)</span>:</span></span><br><span class="line">    self.sex = sex</span><br><span class="line">A.age = <span class="string">'12'</span>  <span class="comment"># 类内部</span></span><br><span class="line">A.func(<span class="string">'男'</span>) <span class="comment"># 类外部</span></span><br><span class="line">a = A(<span class="string">'margin'</span>) <span class="comment"># 对象</span></span><br><span class="line">a.age = <span class="string">'20'</span>  <span class="comment"># 对象内部</span></span><br><span class="line">a.func(<span class="string">'女'</span>) <span class="comment"># 对象外部</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何找到属性</p>
<ol>
<li>对象空间<ol>
<li>产生这个对象空间，并有一个类对象指针</li>
<li>执行<strong>init</strong>方法，给对象封装属性</li>
</ol>
</li>
<li>对象查找属性的顺序：先从对象空间找 ——&gt; 类空间找 ——&gt; 父类空间找 ——-&gt;…</li>
<li>类名查找属性的顺序：先从本类空间找 ——-&gt; 父类空间找——–&gt; …</li>
</ol>
</li>
<li><p>类之间关系</p>
<ol>
<li>依赖关系<ol>
<li>将大象装进冰箱，需要大象类和冰箱类相互依赖</li>
</ol>
</li>
<li>关联关系、组合关系、聚合关系<ol>
<li>关联关系. 两种事物必须是互相关联的. 但是在某些特殊情况下是<strong>可以更改和更换的</strong></li>
<li>聚合关系. 属于关联关系中的⼀种特例. <strong>侧重点是xxx和xxx聚合成xxx. 各⾃有各⾃的声明周期</strong>. 比如电脑. 电脑⾥有CPU, 硬盘, 内存等等. 电脑挂了. CPU还是好的. 还是完整的个体</li>
<li>组合关系. 属于关联关系中的⼀种特例. 写法上差不多. <strong>组合关系比聚合还要紧密</strong>. 比如⼈的⼤脑, ⼼脏, 各个器官. 这些器官组合成⼀个⼈. 这时. ⼈如果挂了. 其他的东⻄也跟着挂了（<strong>将一个类的对象封装到另一个类的对象的属性中，就叫组合</strong>）</li>
</ol>
</li>
<li>实现关系</li>
<li>继承关系(类的三大特性之一：继承。)</li>
</ol>
</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ol>
<li>优点<ol>
<li>增加了类的耦合性（耦合性不宜多，宜精）。</li>
<li>减少了重复代码。</li>
<li>使得代码更加规范化，合理化。</li>
</ol>
</li>
<li>python中类的类型<ol>
<li>⼀个叫经典类. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.</li>
<li>⼀个叫新式类. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。</li>
<li>python3中使⽤的都是新式类. 如果基类谁都不继承. 那这个类会默认继承 object</li>
</ol>
</li>
<li>执行顺序<ol>
<li>子类中重新方法就会覆盖</li>
<li>子类中调用父类方法<ol>
<li>父类名.方法</li>
<li>super().方法</li>
</ol>
</li>
</ol>
</li>
<li>多继承<ol>
<li>经典类的计算：深度优先</li>
<li>新式类的计算：mro算法<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2), [ Base1, Base2] )</span><br><span class="line"><span class="number">1</span>-merge不为空，取出第一个列表列表①的表头E，进行判断                              </span><br><span class="line">各个列表的表尾分别是[O], [E,F,O]，E在这些表尾的集合中，因而跳过当前当前列表</span><br><span class="line"><span class="number">2</span>-取出列表②的表头C，进行判断</span><br><span class="line">C不在各个列表的集合中，因而将C拿出到merge外，并从所有表头删除</span><br><span class="line">merge( [E,O], [C,E,F,O], [C]) = [C] + merge( [E,O], [E,F,O] )</span><br><span class="line"><span class="number">3</span>-进行下一次新的merge操作 ......</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h1 id="面向对象编程特性：继承，封装，多态"><a href="#面向对象编程特性：继承，封装，多态" class="headerlink" title="面向对象编程特性：继承，封装，多态"></a>面向对象编程特性：继承，封装，多态</h1><ol>
<li>封装：把很多数据封装到⼀个对象中。把固定功能的代码封装到⼀个代码块，函数，对象，打包成模块</li>
<li>继承： ⼦类可以⾃动拥有⽗类中除了私有属性外的其他所有内容；两个类具有相同的功能或者特征的时候就可以使用继承，提高代码的重用率</li>
<li>多态： 同⼀个对象，多种形态；子类可以使用父类的方法也可以重写父类的方法</li>
<li>类的约束<ol>
<li>取⽗类：然后在⽗类中定义好⽅法。在这个⽅法中什么都不⽤⼲。就抛⼀个异常就可以了。这样所有的⼦类都必须重写这个⽅法。否则。访问的时候就会报错。⼈为抛出异常的⽅案</li>
<li>使⽤元类来描述⽗类：在元类中给出⼀个抽象⽅法。这样⼦类就不得不给出抽象⽅法的具体实现。也可以起到约束的效果。  </li>
</ol>
</li>
<li>super()深入了解？？？？？？？？</li>
</ol>
<h1 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h1><ol>
<li><p>对于这些<strong>私有</strong>成员来说,他们<strong>只能在类的内部使用,不能在类的外部以及派生类中使用</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    company_name = <span class="string">'陈松'</span>  <span class="comment"># 静态变量(静态字段)</span></span><br><span class="line">    __iphone = <span class="string">'132333xxxx'</span>  <span class="comment"># 私有静态变量(私有静态字段)</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> <span class="comment">#特殊方法</span></span><br><span class="line">        self.name = name  <span class="comment">#对象属性(普通字段)</span></span><br><span class="line">        self.__age = age  <span class="comment"># 私有对象属性(私有普通字段)</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span>  <span class="comment"># 普通方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span> <span class="comment">#私有方法</span></span><br><span class="line">        print(<span class="number">666</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @classmethod  # 类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_func</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="string">""" 定义类方法，至少有一个cls参数 """</span></span><br><span class="line">        print(<span class="string">'类方法'</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @staticmethod  #静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="string">""" 定义静态方法 ，无默认参数"""</span></span><br><span class="line">        print(<span class="string">'静态方法'</span>)</span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"><span class="meta">    @property  # 属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：普通方法、静态方法和类方法，三种方法在内存中都归属于类</p>
<ol>
<li><p>实例方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</span><br><span class="line">调用：只能由实例对象调用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>类方法：通过类调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</span><br><span class="line">调用：实例对象和类对象都可以调用。</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态方法：逻辑上属于类，但是和类本身没有关系，也就是说在静态方法中，不会涉及到类中的属性和方法的操作。可以理解为，静态方法是个独立的、单纯的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</span><br><span class="line">调用：实例对象和类对象都可以调用。</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>属性：property：property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值；将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本<strong>无法察觉自己的name是执行了一个函数然后计算出来的</strong>，这种特性的使用方式遵循了统一访问的原则</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get的时候运行我啊'</span>)</span><br><span class="line"><span class="meta">    @AAA.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'set的时候运行我啊'</span>)</span><br><span class="line"><span class="meta">    @AAA.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'delete的时候运行我啊'</span>)</span><br><span class="line"><span class="comment">#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter</span></span><br><span class="line">f1=Foo()</span><br><span class="line">f1.AAA</span><br><span class="line">f1.AAA=<span class="string">'aaa'</span></span><br><span class="line"><span class="keyword">del</span> f1.AAA</span><br></pre></td></tr></table></figure>
</li>
<li><p>isinstance(a,b)：判断a是否是b类（或者b类的派生类）实例化的对象</p>
</li>
<li><p>issubclass(a,b)： 判断a类是否是b类（或者b的派生类）的派生类</p>
</li>
</ol>
<h1 id="对象反射"><a href="#对象反射" class="headerlink" title="对象反射"></a>对象反射</h1><ol>
<li>通过字符串的形式操作对象相关的属性<ol>
<li>hasattr()：判断是否有属性</li>
<li>getattr()：获取这个属性</li>
</ol>
</li>
<li>函数和方法的区别<ol>
<li>数的是显式传递数据的。如我们要指明为len()函数传递一些要处理数据。</li>
<li><strong>函数则跟对象无关。</strong></li>
<li>方法中的数据则是隐式传递的。</li>
<li>方法可以操作类内部的数据。</li>
<li><strong>方法跟对象是关联的</strong>。如我们在用strip()方法是，是不是都是要通过str对象调用，比如我们有字符串s,然后s.strip()这样调用。是的，strip()方法属于str对象</li>
</ol>
</li>
</ol>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><ol>
<li><p>在程序运行的过程中，所有的变量都是在内存中，程序结束后全部回收，没有吧变量存储下来；我们把变量从内存中变成可存储或传输的过程称之为序列化；python的pickle模块可以将变量序列化存储到磁盘中；但是这个只适用于python，无法在其他语言中恢复</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line">pickle.dumps(d)</span><br><span class="line">f = open(<span class="string">'dump.txt'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(d, f)</span><br><span class="line">f.close()</span><br><span class="line">f = open(<span class="string">'dump.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line">d = pickle.load(f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON提供一种通用的序列化格式；dict对象可以直接序列化为JSON的{}</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>JSON类型</th>
<th>Python类型</th>
</tr>
</thead>
<tbody><tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>“string”</td>
<td>str</td>
</tr>
<tr>
<td>1234.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody></table>
<ol start="3">
<li><p>JSON模块：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict(name=<span class="string">'Bob'</span>, age=<span class="number">20</span>, score=<span class="number">88</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span> <span class="comment"># 返回一个str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json_str = <span class="string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.loads(json_str)</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">20</span>, <span class="string">'score'</span>: <span class="number">88</span>, <span class="string">'name'</span>: <span class="string">'Bob'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在序列化对象的时候，我们需要将其字典化</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">student2dict</span><span class="params">(std)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">'name'</span>: std.name,</span><br><span class="line">        <span class="string">'age'</span>: std.age,</span><br><span class="line">        <span class="string">'score'</span>: std.score</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(json.dumps(s, default=student2dict))</span><br><span class="line">&#123;<span class="string">"age"</span>: <span class="number">20</span>, <span class="string">"name"</span>: <span class="string">"Bob"</span>, <span class="string">"score"</span>: <span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>上下文切换</title>
    <url>/2020/03/20/linux/%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<ul>
<li><a href="#上下文切换">上下文切换</a><ul>
<li><a href="#进程上下文切换">进程上下文切换</a></li>
<li><a href="#线程上下文切换">线程上下文切换</a></li>
<li><a href="#中断上下文切换">中断上下文切换</a></li>
<li><a href="#案例分析">案例分析</a><!-- TOC END -->

</li>
</ul>
</li>
</ul><h1 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h1><ol>
<li>CPU 寄存器：CPU 内置的容量小、但速度极快的内存</li>
<li>程序计数器：用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置</li>
<li>CPU寄存器和程序计数器是运行任何任务的前提，必须依赖的环境也称为CPU上下文</li>
<li>上下文切换类型<ol>
<li>进程上下文切换</li>
<li>线程上下文切换</li>
<li>中断上下文切换</li>
</ol>
</li>
</ol><a id="more"></a><!-- TOC START min:1 max:3 link:true asterisk:false update:true -->


<h2 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h2><ol>
<li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li>
<li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。<br><img src="http://study.jeffqi.cn/linux/linux-source-space.png" alt></li>
<li>进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。从用户态到内核态的转变，需要通过系统调用来完成；<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换；系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong><ol>
<li>进程上下文切换是在不同进程之间</li>
<li>系统调用只在一个进程中</li>
<li><strong>系统调用过程通常称为特权模式切换，而不是上下文切换；但是也不可避免CPU的上下文切换</strong></li>
</ol>
</li>
<li><strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>；进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</li>
<li>进程切换场景<ol>
<li>时间片轮转结束，或进程执行完成</li>
<li>调用sleep函数</li>
<li>等待系统资源</li>
<li>更高优先级进程抢占</li>
<li>硬件中断</li>
</ol>
</li>
</ol>
<h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><ol>
<li>线程属于不同的进程，与进程上下文切换一致</li>
<li>当进程拥有多个线程时，这些线程会<strong>共享</strong>相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</li>
<li><strong>线程也有自己的私有数据</strong>，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</li>
</ol>
<h2 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h2><ol>
<li>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行</strong></li>
<li><strong>终端上下文不涉及用户空间</strong>；中断过程打断了一个正处在用户态的进程，不会保存和恢复用户空间的虚拟内存、全局变量等；只包含内核空间的栈、CPU寄存器等</li>
<li>中断处理比进程拥有更高的优先级；中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能</li>
</ol>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ol>
<li>使用vmstat查看内存使用情况;vmstat 只给出了系统总体的上下文切换情况<br><img src="http://study.jeffqi.cn/linux/vmstat.jpg" alt="vmstat"></li>
<li>pid查看进程详细情况；-w 选项，你就可以查看每个进程上下文切换的情况；<br><img src="http://study.jeffqi.cn/linux/pidstat_w.jpg" alt="pidstat_w"></li>
<li>上图中：cswch，表示每秒<strong>自愿</strong>上下文切换（voluntary context switches）的次数； nvcswch ，表示每秒<strong>非自愿</strong>上下文切换（non voluntary context switches）的次数<ol>
<li>自愿上下文切换，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换。</li>
<li>非自愿上下文切换，则是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换</li>
</ol>
</li>
<li><strong>实验</strong></li>
<li>sysbench：是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况；sysstat<br><img src="http://study.jeffqi.cn/linux/sysbench_threads=5.jpg" alt="sysbench_threads=5"></li>
<li>vmstat查看实验前上下文切换情况；对比上面实验前的结果；r、in、cs、us、sy参数激增<br><img src="http://study.jeffqi.cn/linux/vmstat_sysbench.jpg" alt="vmstat_sysbench"></li>
<li>pidstat查看进程线程的上下文切换情况；sysbench基于多线程工作模式，需要使用-t参数查看<br><img src="http://study.jeffqi.cn/linux/pidstat_w_u_sysbench.jpg" alt="pidstat_w_u_sysbench"><br><img src="http://study.jeffqi.cn/linux/pidstat_w_t_sysbench.jpg" alt="pidstat_w_t_sysbench"></li>
<li>查看中断上下文切换通过查看/proc/interrupt文件（<strong>单核服务器中看不出变化，需要在多核服务器上RES明显变化</strong>）<br><img src="http://study.jeffqi.cn/linux/cat_proc_interrupts.jpg" alt="cat_proc_interrupt"><br><img src="http://study.jeffqi.cn/linux/cat_proc_interrupts_mulits.jpg" alt="cat_proc_interrupt_mulit"><ol>
<li>重调度中断（RES），这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断</li>
</ol>
</li>
<li>总结<ol>
<li>自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；</li>
<li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；</li>
<li>中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>网络参数</title>
    <url>/2020/03/19/linux/%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#零碎知识点">零碎知识点</a><ul>
<li><a href="#网络内核参数">网络内核参数</a><ul>
<li><a href="#arp_ignore与arp_announce">arp_ignore与arp_announce</a></li>
<li><a href="#关于过多time-wait参数调优">关于过多time-wait参数调优</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考文档">参考文档</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h1><h2 id="网络内核参数"><a href="#网络内核参数" class="headerlink" title="网络内核参数"></a>网络内核参数</h2><h3 id="arp-ignore与arp-announce"><a href="#arp-ignore与arp-announce" class="headerlink" title="arp_ignore与arp_announce"></a>arp_ignore与arp_announce</h3><ul>
<li>arp_ignore和arp_announce参数都和<strong>ARP协议相关</strong>，主要用于<strong>控制系统返回arp响应和发送arp请求时的动作</strong>。这两个参数很重要，特别是在LVS的DR场景下，它们的配置直接影响到DR转发是否正常。</li>
</ul>
<ol>
<li><strong>arp_ignore</strong>：控制系统在收到外部的arp请求时，是否要返回arp响应<ul>
<li><strong>sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效</strong></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>响应任意网卡上接收到的对本机IP地址的arp请求（包括环回网卡上的地址），而不管该目的IP是否在接收网卡上。</td>
</tr>
<tr>
<td>1</td>
<td>只响应目的IP地址为接收网卡上的本地地址的arp请求。</td>
</tr>
<tr>
<td>2</td>
<td>只响应目的IP地址为接收网卡上的本地地址的arp请求，并且arp请求的源IP必须和接收网卡同网段。</td>
</tr>
<tr>
<td>3</td>
<td>如果ARP请求数据包所请求的IP地址对应的本地地址其作用域（scope）为主机（host），则不回应ARP响应数据包，如果作用域为全局（global）或链路（link），则回应ARP响应数据包。</td>
</tr>
<tr>
<td>4~7</td>
<td>保留未使用</td>
</tr>
<tr>
<td>8</td>
<td>不回应所有的arp请求</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>arp_announce</strong>：控制系统在对外发送arp请求时，如何选择arp请求数据包的源IP地址<ul>
<li><strong>sysctl.conf中包含all和eth/lo（具体网卡）的arp_ignore参数，取其中较大的值生效</strong></li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>级别</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>允许使用任意网卡上的IP地址作为arp请求的源IP，通常就是使用数据包a的源IP。</td>
</tr>
<tr>
<td>1</td>
<td>尽量避免使用不属于该发送网卡子网的本地地址作为发送arp请求的源IP地址。</td>
</tr>
<tr>
<td>2</td>
<td>忽略IP数据包的源IP地址，选择该发送网卡上最合适的本地地址作为arp请求的源IP地址。</td>
</tr>
</tbody></table>
<h3 id="关于过多time-wait参数调优"><a href="#关于过多time-wait参数调优" class="headerlink" title="关于过多time-wait参数调优"></a>关于过多time-wait参数调优</h3><ul>
<li><p>net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
</li>
<li><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
</li>
<li><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
</li>
<li><p>net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</p>
</li>
<li><p>net.ipv4.tcp_keepalive_time = 1200 表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</p>
</li>
<li><p>net.ipv4.ip_local_port_range = 1024 65000 表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</p>
</li>
<li><p>net.ipv4.tcp_max_syn_backlog = 8192 表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</p>
</li>
<li><p>net.ipv4.tcp_max_tw_buckets = 5000 表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</p>
</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/lipengxiang2009/p/7451050.html" target="_blank" rel="noopener">lvs中网络参数</a></li>
<li><a href="https://blog.csdn.net/zhangjunli/article/details/89321202" target="_blank" rel="noopener">timewait过多</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Linux笔记网站记录</title>
    <url>/2020/03/19/linux/linux-network-note/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<!--moer-->

<ul>
<li><a href="https://blog.csdn.net/daaikuaichuan/article/details/82951084" target="_blank" rel="noopener">进程线程协程</a></li>
<li><a href="https://www.cnblogs.com/luoyan01/p/9948092.html" target="_blank" rel="noopener">apache MPM工作模式</a></li>
<li><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">写时复制</a></li>
<li><a href="https://blog.csdn.net/qq_37375427/article/details/83046906" target="_blank" rel="noopener">linux调度</a></li>
<li><a href="https://blog.csdn.net/weixin_34007906/article/details/93529347?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">centos7 开机详解</a></li>
<li><a href="http://www.zsythink.net/archives/tag/iptables/page/2/" target="_blank" rel="noopener">linux防火墙之iptables</a></li>
<li><a href="https://blog.csdn.net/taiyang1987912/article/details/39551385" target="_blank" rel="noopener">linux各种括号</a></li>
<li><a href="https://www.cnblogs.com/yanjieli/p/10582324.html" target="_blank" rel="noopener">linux负载均衡lvs</a></li>
<li><a href="https://www.jianshu.com/p/81115a4293c7" target="_blank" rel="noopener">linux VRRP</a></li>
<li><a href="https://blog.csdn.net/u014466109/article/details/68957657" target="_blank" rel="noopener">Gentoo下折腾emerge包管理器</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener">cgroup原理</a></li>
<li><a href="https://www.nanguoyu.com/centos%E5%8D%87%E7%BA%A7glibc" target="_blank" rel="noopener">centos7升级glibc</a></li>
<li><a href="https://blog.csdn.net/pecovio/article/details/82348924" target="_blank" rel="noopener">openssl介绍与使用</a></li>
<li><a href="https://www.cnblogs.com/h2zZhou/p/10984622.html" target="_blank" rel="noopener">qt5安装</a></li>
<li><a href="https://www.cnblogs.com/hanlulu1998/p/12003845.html" target="_blank" rel="noopener">qt升级</a></li>
<li><a href="https://www.jianshu.com/p/36a7775b04ec" target="_blank" rel="noopener">消息队列</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>平均负载</title>
    <url>/2020/03/19/linux/%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#平均负载均衡">平均负载均衡</a><ul>
<li><a href="#案例分析">案例分析</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="平均负载均衡"><a href="#平均负载均衡" class="headerlink" title="平均负载均衡"></a>平均负载均衡</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># uptime</span></span><br><span class="line"> 22:59:05 up 2 min,  2 users,  load average: 0.25, 0.33, 0.14</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过top命令或者uptime命令查看；load average字段为1 分钟、5 分钟、15 分钟的平均负载</p>
</li>
<li><p>平均负载概念：单位时间内，系统处于<strong>可运行状态</strong>和<strong>不可中断状态</strong>的平均进程数，也就是<strong>平均活跃进程数</strong></p>
<ul>
<li>可运行状态（R）：正在使用 CPU 或者正在等待 CPU 的进程</li>
<li>不可中断状态（D）：进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的（io写入的进程）</li>
</ul>
</li>
<li><p>比如当平均负载为 2 时，意味着什么呢？</p>
<ul>
<li>在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。</li>
<li>在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。</li>
<li>而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。</li>
</ul>
</li>
<li><p>查看CPU信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /proc/cpuinfo | wc -l</span><br><span class="line"><span class="comment"># lscpu</span></span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑cpu数：一般情况下，<strong>逻辑cpu=物理CPU个数×每颗核数</strong>，如果不相等的话，则表示服务器的 <strong>CPU支持超线程技术</strong>（HT：简单来说，它可使处理器中的1 颗内核如2 颗内核那样在操作系统中发挥作用。这样一来，操作系统可使用的执行资源扩大了一倍，大幅提高了系统的整体性能，此时逻辑cpu=物理CPU个数×每颗核数x2）</li>
</ul>
</li>
<li><p>一般负载超过70%就需要排查；小于逻辑cpu基本正常，如果在逻辑cpu的0到3倍之间就需要更换更快的cpu或者优化业务；三倍以上服务器就很危险</p>
</li>
<li><p>cpu使用率不等于平均负载：可以由第2点得知；正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程</p>
</li>
</ol>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><ol>
<li><p>sysstat：包含工具iostat、mpstat、pidstat用于查找负载升高的原因</p>
<ol>
<li>mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。</li>
<li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。</li>
</ol>
</li>
<li><p>stress：压力测试工具</p>
</li>
<li><p><strong>模拟cpu密集型服务器压力测试</strong></p>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用一个cpu，占满100%，时间600s</span></span><br><span class="line">[root@node1 ~]<span class="comment"># stress --cpu 1 --timeout 600</span></span><br><span class="line">stress: info: [2319] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据$</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mpstat -P ALL 5     </span></span><br><span class="line">11:31:59 PM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:32:00 PM  all   50.50    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.50</span><br><span class="line">11:32:00 PM    0  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00</span><br><span class="line">11:32:00 PM    1    0.00    0.00    1.00    0.00    0.00    0.00    0.00    0.00    0.00   99.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出占用cpu的进程</span></span><br><span class="line">[root@node1 ~]<span class="comment"># pidstat -u 5 1      </span></span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (node1) 	03/17/2020 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">11:34:37 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:34:42 PM     0      2320   99.40    0.00    0.00   99.40     0  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0      2320   99.40    0.00    0.00   99.40     -  stress</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>模拟io压力</strong><ul>
<li>iowait无法升高的问题，是因为案例中stress使用的是 sync() 系统调用，它的作用是刷新缓冲区内存到磁盘中。对于新安装的虚拟机，缓冲区可能比较小，无法产生大的IO压力，这样大部分就都是系统调用的消耗了。所以，你会看到只有系统CPU使用率升高。解决方法是使用stress的下一代stress-ng，它支持更丰富的选项，比如 stress-ng -i 1 –hdd 1 –timeout 600（–hdd表示读写临时文件）。</li>
</ul>
</li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">占满io，时间600s</span><br><span class="line">[root@node1 ~]<span class="comment"># stress-ng --hdd -i 1 --timeout 600</span></span><br><span class="line">stress: info: [3143] dispatching hogs: 0 cpu, 1 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有的cpu和内存的使用情况</span></span><br><span class="line">[root@node1 ~]<span class="comment"># mpstat -P ALL 5</span></span><br><span class="line">11:30:05 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">11:30:08 AM  all    0.35    0.00    5.30   92.93    0.00    0.00    1.41    0.00    0.00    0.00</span><br><span class="line">11:30:08 AM    0    0.35    0.00    5.30   92.93    0.00    0.00    1.41    0.00    0.00    0.00</span><br><span class="line"></span><br><span class="line">Average:     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">Average:     all    1.10    0.02   16.43   76.55    0.00    0.02    0.58    0.00    0.00    5.31</span><br><span class="line">Average:       0    1.10    0.02   16.43   76.55    0.00    0.02    0.58    0.00    0.00    5.31</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@baidu ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-957.27.2.el7.x86_64 (baidu) 	03/18/2020 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">11:33:26 AM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:33:31 AM     0     25768    0.00   18.38    0.00   18.38     0  stress-ng-hdd</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0     25790    0.35   21.75    0.00   22.11     -  stress-ng-hdd</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>大量进程模拟</strong></li>
</ol>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启多个线程大于核数</span></span><br><span class="line">[root@node1 ~]<span class="comment"># stress --cpu 4 --timeout 600</span></span><br><span class="line">stress: info: [3607] dispatching hogs: 4 cpu, 0 io, 0 vm, 0 hdd</span><br><span class="line"></span><br><span class="line"><span class="comment"># -d参数为高亮变化部分</span></span><br><span class="line">[root@node1 ~]<span class="comment"># watch -d uptime   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">[root@node1 ~]<span class="comment"># pidstat -u 5 1</span></span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (node1) 	03/17/2020 	_x86_64_	(2 CPU)</span><br><span class="line"></span><br><span class="line">11:47:34 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">11:47:39 PM     0      3608   54.76    0.00    0.00   54.76     1  stress</span><br><span class="line">11:47:39 PM     0      3609   45.24    0.00    0.00   45.24     1  stress</span><br><span class="line">11:47:39 PM     0      3610   47.62    0.00    0.00   47.62     0  stress</span><br><span class="line">11:47:39 PM     0      3611   50.00    0.20    0.00   50.20     0  stress</span><br><span class="line"></span><br><span class="line">Average:      UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">Average:        0      3608   54.76    0.00    0.00   54.76     -  stress</span><br><span class="line">Average:        0      3609   45.24    0.00    0.00   45.24     -  stress</span><br><span class="line">Average:        0      3610   47.62    0.00    0.00   47.62     -  stress</span><br><span class="line">Average:        0      3611   50.00    0.20    0.00   50.20     -  stress</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>总结</strong><ul>
<li>平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况</li>
<li>平均负载高有可能是 CPU 密集型进程导致的；</li>
<li>平均负载高并不一定代表 CPU 使用率高，还有可能是 I/O 更繁忙了；</li>
<li>当发现负载高的时候，你可以使用 mpstat、pidstat 等工具，辅助分析负载的来源。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL高可用之MyCat读写分离搭建</title>
    <url>/2020/02/25/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8BMyCat%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mycat">MyCat</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#安装使用">安装使用</a></li>
<li><a href="#mycat-配置文件">MyCat 配置文件</a><ul>
<li><a href="#配置">配置：</a></li>
<li><a href="#三大组件">三大组件</a></li>
<li><a href="#实验配置">实验配置</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>mycat是一个数据库中间件，也可以理解为是数据库代理。在架构体系中是位于数据库和应用层之间的一个组件，并且对于应用层是透明的，即数据库感受不到mycat的存在，认为是直接连接的mysql数据库（实际上是连接的mycat,mycat实现了mysql的原生协议）</li>
<li>mycat的三大功能：分表、读写分离、主从切换</li>
</ul>
<h2 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h2><ol>
<li><p>下载安装 Java jdk</p>
<ul>
<li>网址：<a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></li>
<li>解压，添加环境变量/etc/profile  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/local/java/jdk1.8.0_241</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>下载安装 MyCat</p>
<ul>
<li><p>网址：<a href="https://github.com/MyCATApache/Mycat-download" target="_blank" rel="noopener">https://github.com/MyCATApache/Mycat-download</a></p>
</li>
<li><p>解压，完成安装</p>
</li>
<li><p>指令：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux：</span><br><span class="line">./mycat start 启动</span><br><span class="line">./mycat stop 停止</span><br><span class="line">./mycat console 前台运行</span><br><span class="line">./mycat install 添加到系统自动启动（暂未实现）</span><br><span class="line">./mycat remove 取消随系统自动启动（暂未实现）</span><br><span class="line">./mycat restart 重启服务</span><br><span class="line">./mycat pause 暂停</span><br><span class="line">./mycat status 查看启动状态</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试连接—Mycat连接测试：测试mycat与测试mysql完全一致</p>
</li>
</ul>
</li>
</ol>
<h2 id="MyCat-配置文件"><a href="#MyCat-配置文件" class="headerlink" title="MyCat 配置文件"></a>MyCat 配置文件</h2><h3 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--bin 启动目录</span><br><span class="line">--conf 配置文件存放配置文件：</span><br><span class="line">  --server.xml：是Mycat服务器参数调整和用户授权的配置文件。</span><br><span class="line">  --schema.xml：是逻辑库定义和表以及分片定义的配置文件。</span><br><span class="line">  --rule.xml：  是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</span><br><span class="line">  --log4j.xml： 日志存放在logs/log中，每天一个文件，日志的配置是在conf/log4j.xml中，根据自己的需要可以调整输出级别为debug；debug级别下，会输出更多的信息，方便排查问题。</span><br><span class="line">  --autopartition-long.txt,partition-hash-int.txt,sequence_conf.properties， sequence_db_conf.properties 分片相关的id分片规则配置文件</span><br><span class="line">  --lib	    MyCAT自身的jar包或依赖的jar包的存放目录。</span><br><span class="line">  --logs        MyCAT日志的存放目录。日志存放在logs/log中，每天一个文件</span><br></pre></td></tr></table></figure>

<h3 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h3><ol>
<li><p>server.xml</p>
<ul>
<li>添加两个mycat逻辑库：user,pay: system 参数是所有的mycat参数配置，比如添加解析器：defaultSqlParser，其他类推 user 是用户参数。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultSqlParser"</span>&gt;</span>druidparser<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"mycat"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>mycat<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>user,pay<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>schema.xml</p>
<ul>
<li>修改dataHost和schema对应的连接信息，user,pay 垂直切分后的配置如下所示：schema 是实际逻辑库的配置，user，pay分别对应两个逻辑库，多个schema代表多个逻辑库。dataNode是逻辑库对应的分片，如果配置多个分片只需要多个dataNode即可。dataHost是实际的物理库配置地址，可以配置多主主从等其他配置，多个dataHost代表分片对应的物理库地址，下面的writeHost、readHost代表该分片是否配置多写，主从，读写分离等高级特性。以下例子配置了两个writeHost为主从。  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"pay"</span>  <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"pay"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">"order"</span> <span class="attr">dataNode</span>=<span class="string">"pay1,pay2"</span> <span class="attr">rule</span>=<span class="string">"rule1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"user"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"pay1"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"pay1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"pay2"</span> <span class="attr">dataHost</span>=<span class="string">"host"</span> <span class="attr">database</span>=<span class="string">"pay2"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select 1<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.0.2:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM2"</span> <span class="attr">url</span>=<span class="string">"192.168.0.3:3306"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>rule.xml</p>
<ul>
<li>该规则配置了order表的数据切分方式，及数据切分字段。<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://org.opencloudb/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">"rule1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">columns</span>&gt;</span>user_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">"func1"</span> <span class="attr">class</span>=<span class="string">"org.opencloudb.route.function.PartitionByLong"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionCount"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"partitionLength"</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h3><ul>
<li><p>server.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:server SYSTEM "server.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">"root"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>456789<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"schemas"</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>schema.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">"http://io.mycat/"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">"TESTDB"</span> <span class="attr">checkSQLschema</span>=<span class="string">"false"</span> <span class="attr">sqlMaxLimit</span>=<span class="string">"100"</span> <span class="attr">dataNode</span>=<span class="string">"dn1"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">"dn1"</span> <span class="attr">dataHost</span>=<span class="string">"localhost1"</span> <span class="attr">database</span>=<span class="string">"mycat_test"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">"localhost1"</span> <span class="attr">maxCon</span>=<span class="string">"1000"</span> <span class="attr">minCon</span>=<span class="string">"10"</span> <span class="attr">balance</span>=<span class="string">"3"</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">"0"</span> <span class="attr">dbType</span>=<span class="string">"mysql"</span> <span class="attr">dbDriver</span>=<span class="string">"native"</span> <span class="attr">switchType</span>=<span class="string">"1"</span>  <span class="attr">slaveThreshold</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">"hostM1"</span> <span class="attr">url</span>=<span class="string">"192.168.80.130:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">"Hjqme525+"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS2"</span> <span class="attr">url</span>=<span class="string">"192.168.80.131:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span> <span class="attr">password</span>=<span class="string">"Hjqme525+"</span> /&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">"hostS3"</span> <span class="attr">url</span>=<span class="string">"192.168.80.129:3306"</span> <span class="attr">user</span>=<span class="string">"mycat"</span> <span class="attr">password</span>=<span class="string">"Hjqme525+"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>docker machine</title>
    <url>/2020/02/24/docker/docker-machine/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#docker-machine">docker machine</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#安装machine">安装Machine</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="docker-machine"><a href="#docker-machine" class="headerlink" title="docker machine"></a>docker machine</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>短时间内在本地或云环境中搭建一套 Docker 主机集群；负责实现对Docker 运行环境进行安装和管理</li>
<li>基本功能<ol>
<li>在指定节点或平台上安装Docker 引擎，配置其为可使用的Docker 环境；</li>
<li>集中管理（包括启动、查看等）所安装的 Docker 环境</li>
</ol>
</li>
</ul>
<h2 id="安装Machine"><a href="#安装Machine" class="headerlink" title="安装Machine"></a>安装Machine</h2><ol>
<li><p>下载编译好的二进制文件</p>
<ul>
<li>docker machine安装教程 git 网址：<a href="https://github.com/docker/machine/releases/" target="_blank" rel="noopener">https://github.com/docker/machine/releases/</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/machine/releases/download/v0.16.2/docker-machine-`uname -s`-`uname -m` &gt; /tmp/docker-machine &amp;&amp;</span><br><span class="line">chmod +x /tmp/docker-machine &amp;&amp;</span><br><span class="line">sudo cp /tmp/docker-machine /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>检查安装是否完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine version</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建docker主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-machine -d 驱动 --generic-ip-address=&apos;ip&apos; name</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>docker compose</title>
    <url>/2020/02/23/docker/docker-compose/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#docker-compose">docker compose</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#安装">安装</a></li>
<li><a href="#文件及目录创建">文件及目录创建</a><ul>
<li><a href="#项目目录">项目目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#测试">测试</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>负责实现对Docker 容器集群的快速编排</p>
</li>
<li><p>允许用户通过一个单独的docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
</li>
<li><p>compose 中有两个重要的概念：</p>
<ol>
<li>任务（task）：一个容器被称为一个任务。任务拥有独一无二的ID ，在同一个服务中的多个任务序号依次递增。</li>
<li>服务（service）：某个相同应用镜像的容器副本集合，一个服务可以横向扩展为多个容器实例。</li>
<li>服务栈（stack）：由多个服务组成，相互配合完成特定业务，如Web 应用服务、数据库服务共同构成Web 服务钱，一般由一个docker-cornpose . yaml 文件定义</li>
</ol>
</li>
<li><p>Compose 掌管运行时的编排能力。使用Compose模板文件，用户可以编写包括若干服务的一个模板文件快速启动服务栈；分发给他人，也可快速创建一套相同的服务栈。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>pip安装  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U docker-compose</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="文件及目录创建"><a href="#文件及目录创建" class="headerlink" title="文件及目录创建"></a>文件及目录创建</h2><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><ol>
<li><p>编写 docker-compose.yml 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">    mysql:</span><br><span class="line">        network_mode: &quot;bridge&quot;</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: &quot;Hjqme525-&quot;</span><br><span class="line">            MYSQL_USER: &quot;jerqi&quot;</span><br><span class="line">            MYSQL_PASS: &quot;Hjqme525+&quot;</span><br><span class="line">        image: &quot;docker.io/mysql:latest&quot;</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">            - &quot;./data:/var/lib/mysql&quot;</span><br><span class="line">            - &quot;./conf/my.cnf:/etc/my.cnf&quot;</span><br><span class="line">            - &quot;./init:/docker-entrypoint-initdb.d/&quot;</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;6363:3306&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 my.cnf 配置文件（安装MySQL）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">character-set-server=utf8</span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写初始化文件 init.sql（MySQL初始化）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">alter user &apos;root&apos;@&apos;localhost&apos; identified with &apos;mysql_native_password&apos; by &apos;Hjqme525-&apos;;</span><br><span class="line">update user set host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line">flush privileges;</span><br><span class="line">update mysql set host = &apos;%&apos; where user = &apos;root&apos;;</span><br><span class="line">create database `test`;</span><br><span class="line">use test;</span><br><span class="line">create table `t1`</span><br><span class="line">(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">age int check &apos;age &gt;= 1&apos;</span><br><span class="line">);</span><br><span class="line">insert into `t1`</span><br><span class="line">values</span><br><span class="line">(1,1),(2,2),(3,3),(4,4);</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker_mysql</span><br><span class="line">├── conf</span><br><span class="line">│   └── my.cnf</span><br><span class="line">├── data</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">└── init</span><br><span class="line">    └── init.sql</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ol>
<li><p>下拉镜像</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>linux替换python3</title>
    <url>/2020/02/21/linux/python-install/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>

<h1 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h1><ol>
<li><p>安装python</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">yum install python36 python36-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>替换bin文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改yum配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /usr/bin/yum</span><br><span class="line">vim /usr/libexec/urlgrabber-ext-down</span><br><span class="line">将文件 #!/usr/bin/python修改为#!/usr/bin/python2即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install -y python36 python36-devel</span><br><span class="line">mv /usr/bin/python /usr/bin/python.bak</span><br><span class="line">ln -s /usr/bin/python3.6 /usr/bin/python</span><br><span class="line">sed -i <span class="string">'s/python2/python/'</span> /usr/bin/yum</span><br><span class="line">sed -i <span class="string">'s/python2/python/'</span> /usr/libexec/urlgrabber-ext-down</span><br><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line">python get-pip.py</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="升级python版本"><a href="#升级python版本" class="headerlink" title="升级python版本"></a>升级python版本</h1><ol>
<li><p>下载<a href="https://www.python.org/ftp/python/" target="_blank" rel="noopener">官网</a>Python安装包</p>
</li>
<li><p>解压并进入解压目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf xxx</span><br><span class="line"><span class="built_in">cd</span> xxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建python安装目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/python3.x</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译(解压目录下)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python38</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>备份就Python3文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mv /usr/bin/python3 /usr/bin/python3.backup</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/python38/bin/python3 /usr/bin/python3</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python3 -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>可能出现新建项目时无法使用pip，需要移动一个文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 报错</span></span><br><span class="line"><span class="comment"># （Error: Command '['/home/jerqi/untitled/bin/python3', '-Im', 'ensurepip', '--upgrade', '--default-pip']' returned non-zero exit status 2.）</span></span><br><span class="line">sudo rm /usr/bin/lsb_release</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>MySQL高可用之MHA搭建</title>
    <url>/2020/02/20/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8BMHA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mha">MHA</a><ul>
<li><a href="#简介">简介</a></li>
<li><a href="#组成与工作原理">组成与工作原理</a></li>
<li><a href="#工作过秤">工作过秤</a></li>
<li><a href="#mha软件">MHA软件</a></li>
</ul>
</li>
<li><a href="#部署mha">部署MHA</a><ul>
<li><a href="#配置主从复制">配置主从复制</a><ul>
<li><a href="#注意">注意</a></li>
<li><a href="#节点配置">节点配置</a></li>
</ul>
</li>
<li><a href="#配置mha">配置MHA</a></li>
</ul>
</li>
<li><a href="#检验">检验</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案；是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用；</li>
</ul>
<h2 id="组成与工作原理"><a href="#组成与工作原理" class="headerlink" title="组成与工作原理"></a>组成与工作原理</h2><ul>
<li>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）</li>
<li>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明；</li>
<li>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失；但是如果发生了硬件故障等就无法获取到日志，导致数据丢失。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性；</li>
<li>至少需要三台服务器完成</li>
</ul>
<h2 id="工作过秤"><a href="#工作过秤" class="headerlink" title="工作过秤"></a>工作过秤</h2><ol>
<li>从宕机崩溃的master保存二进制日志事件（binlog events）;</li>
<li>识别含有最新更新的slave；</li>
<li>应用差异的中继日志（relay log）到其他的slave；</li>
<li>应用从master保存的二进制日志事件（binlog events）；</li>
<li>提升一个slave为新的master；</li>
<li>使其他的slave连接新的master进行复制；</li>
</ol>
<h2 id="MHA软件"><a href="#MHA软件" class="headerlink" title="MHA软件"></a>MHA软件</h2><ul>
<li><p>MHA软件由两部分组成，Manager工具包和Node工具包</p>
<ol>
<li><p>Manager工具包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh              检查MHA的SSH配置状况</span><br><span class="line">masterha_check_repl             检查MySQL复制状况</span><br><span class="line">masterha_manager                启动MHA</span><br><span class="line">masterha_check_status           检测当前MHA运行状态</span><br><span class="line">masterha_master_monitor         检测master是否宕机</span><br><span class="line">masterha_master_switch          控制故障转移（自动或者手动）</span><br><span class="line">masterha_conf_host              添加或删除配置的server信息</span><br></pre></td></tr></table></figure>
</li>
<li><p>Node工具包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save_binary_logs                保存和复制master的二进制日志</span><br><span class="line">apply_diff_relay_logs           识别差异的中继日志事件并将其差异的事件应用于其他的slave</span><br><span class="line">filter_mysqlbinlog              去除不必要的ROLLBACK事件（MHA已不再使用这个工具）</span><br><span class="line">purge_relay_logs                清除中继日志（不会阻塞SQL线程）</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>为了尽可能的减少主库硬件损坏宕机造成的数据丢失，因此在配置MHA的同时建议配置成MySQL 5.5的半同步复制</p>
</li>
</ul>
<h1 id="部署MHA"><a href="#部署MHA" class="headerlink" title="部署MHA"></a>部署MHA</h1><ul>
<li>准备：四台服务器（一个manager节点，一个master节点，两个slave节点</li>
</ul>
<h2 id="配置主从复制"><a href="#配置主从复制" class="headerlink" title="配置主从复制"></a>配置主从复制</h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>开启二进制日志功能与中继日志</li>
<li>从节点显示开启read-only只读设置，并设置relay_log_purge = 0 清理中继日志的功能</li>
<li>每个节点的server-id不同</li>
</ol>
<h3 id="节点配置"><a href="#节点配置" class="headerlink" title="节点配置"></a>节点配置</h3><ul>
<li><p>master节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=1</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave-1节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=2</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">read-only</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave-2节点配置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">server-id=3</span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line">user=mysql</span><br><span class="line">log_bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">relay-log=relay-bin</span><br><span class="line">relay-log-index=relay-bin.index</span><br><span class="line">binlog_format=row</span><br><span class="line">basedir=/usr</span><br><span class="line">tmpdir=/tmp</span><br><span class="line">read-only</span><br><span class="line">relay_log_purge=0</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后重启 MySQL 服务</p>
</li>
</ul>
<h2 id="配置MHA"><a href="#配置MHA" class="headerlink" title="配置MHA"></a>配置MHA</h2><ul>
<li><p>管理节点安装manager和node软件；数据库节点安装node软件</p>
</li>
<li><p>软件地址：</p>
<ul>
<li><p>mha4mysql-manager</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/yoshinorim/mha4mysql-manager</span><br></pre></td></tr></table></figure>
</li>
<li><p>mha4mysql-node</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/yoshinorim/mha4mysql-node</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>安装rpm包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum localinstall ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置manager节点mha配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/mha/cluster1.conf #没有文件需要自己创建</span><br><span class="line"></span><br><span class="line">[server default]</span><br><span class="line">user=test    #管理用户为数据库上的账户</span><br><span class="line">password=Hjqme525+   #管理密码</span><br><span class="line">manager_workdir=/data/mastermha/cluster1/     #mha工作路径</span><br><span class="line">manager_log=/data/mastermha/cluster1/manager.log   #mha日志文件</span><br><span class="line">remote_workdir=/data/mastermha/cluster1/      #每个远程主机的工作目录</span><br><span class="line">ssh_user=root</span><br><span class="line">repl_user=repl_user        #主从复制用户名称</span><br><span class="line">repl_password=Hjqme525+    #复制用户数据库密码</span><br><span class="line">ping_interval=1            #ping时间时长</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[server1]</span><br><span class="line">hostname=192.168.80.129  #主服务器IP地址</span><br><span class="line">candidate_master=1  #优先选为master节点</span><br><span class="line">[server2]</span><br><span class="line">hostname=192.168.80.130   #候选主服务器IP地址</span><br><span class="line">candidate_master=1  #优先选为master节点</span><br><span class="line">[server3]</span><br><span class="line">hostname=192.168.80.131</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置上所有节点见免密登陆，通过密钥对进行登陆</p>
</li>
</ul>
<h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><ol>
<li><p>检验SSH登陆</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_ssh --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>检验主从复制状况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_repl --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动MHA(前台开启)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_manager --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看MHA运行状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masterha_check_status --conf=/etc/mha/cluster1.cnf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><a href="https://www.cnblogs.com/xuanzhi201111/p/4231412.html" target="_blank" rel="noopener">MySQL高可用之MHA搭建</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySQL高可用</title>
    <url>/2020/02/20/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mysql高可用">MySQL高可用</a><ul>
<li><a href="#主备延迟">主备延迟</a></li>
<li><a href="#主备切换策略">主备切换策略</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="MySQL高可用"><a href="#MySQL高可用" class="headerlink" title="MySQL高可用"></a>MySQL高可用</h1><h2 id="主备延迟"><a href="#主备延迟" class="headerlink" title="主备延迟"></a>主备延迟</h2><ul>
<li><p>主备延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值；</p>
</li>
<li><p>查看主备延迟</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> stauts;  <span class="comment">/*second_behind_master 参数*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于 seconds_behind_master 参数</p>
<ul>
<li>sbm参数事从服务器落后与主服务器的时间</li>
<li>由于主服务器性能或者网络等问题，可能导致，主服务器的日志到达从服务器的时候就已经很慢，不能通过这个时间直接判断<ol>
<li>sbm出现NULL值：<ul>
<li>出现空值时主从复制就断了或者停止工作</li>
</ul>
</li>
<li>sbm值大于等于0：<ul>
<li>大于0时，则主从服务器已经数据不一致，有滞后现象</li>
<li>等于0时，只能说明SQL解析线程relay_log到目前为止没有延迟</li>
</ul>
</li>
</ol>
</li>
<li>稍微准确的方法<ol>
<li>首先查看master_log_file参数，同relay_master_log_file参数的差异，比较日志的同步情况</li>
<li>其次查看read_master_log_pos和exec_master_log_pos参数的差异，比较日志的读取和执行差异</li>
<li>最后查看seconds_behind_master参数</li>
</ol>
</li>
<li>较新的GTID和pt工具<ol>
<li>较新的GIID的复制方式有更好的方式来判断时间点主从复制的差异</li>
<li>pt工具中的beatheart判断<ul>
<li>pt工具：在主服务器上有一个库表，定时写入数据，从服务器读取来分析差异</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>主备延迟来源：</p>
<ol>
<li>主备数据库服务器性能差距大</li>
<li>备库压力大，大量 DML 操作</li>
<li>大事务的执行是将过长</li>
<li>大表做 DDL 操作</li>
</ol>
</li>
<li><p>主备延迟——过期读</p>
<ol>
<li>强制走主库</li>
<li>sleep方法</li>
<li>判断主备延迟方法</li>
<li>配合使用semi-sync（半同步复制）</li>
<li>等主库位点</li>
<li>等GTID方法</li>
</ol>
</li>
</ul>
<h2 id="主备切换策略"><a href="#主备切换策略" class="headerlink" title="主备切换策略"></a>主备切换策略</h2><ol>
<li>可靠性优先策略<ul>
<li>数据一致性良好，但是可能照成数据库处于不可用状态。还可能照成数据暂时性丢失；</li>
</ul>
</li>
<li>可用性优先策略<ul>
<li>数据库不存在不可用状态，但是会造成数据不一致；</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL全局锁与表锁</title>
    <url>/2020/02/12/mysql/MySQL_lock/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mysql锁">MySQL锁</a><ul>
<li><a href="#全局锁">全局锁</a></li>
<li><a href="#表级锁">表级锁</a><ul>
<li><a href="#表锁">表锁</a></li>
<li><a href="#元数据锁">元数据锁</a></li>
</ul>
</li>
<li><a href="#行锁">行锁</a><ul>
<li><a href="#行锁-1">行锁</a></li>
<li><a href="#间隙锁gap锁">间隙锁（gap锁）</a></li>
<li><a href="#两阶段锁">两阶段锁</a></li>
<li><a href="#死锁于死锁检测">死锁于死锁检测</a></li>
</ul>
</li>
<li><a href="#加锁规则两原则两优化一bug">加锁规则（两原则，两优化，一bug）</a><ul>
<li><a href="#上锁注意点">上锁注意点</a></li>
</ul>
</li>
<li><a href="#小结">小结</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h1><ul>
<li>计算机协调多个进程或线程并发访问同一资源的机制</li>
<li>MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</li>
<li>锁分类<ol>
<li>表锁：开销小，性能差</li>
<li>页锁：介于行锁与表锁之间</li>
<li>行锁：开销大，性能好，适于高并发</li>
<li>间隙锁：解决幻读的锁</li>
</ol>
</li>
<li>读锁：阻塞写不阻塞读，只能操作自己上锁表和数据</li>
<li>写锁：同时阻塞读写，其他会话的写操作会阻塞</li>
</ul>
<h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><ul>
<li><p>命令</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">flush</span> <span class="keyword">tables</span> <span class="keyword">with</span> <span class="keyword">read</span> <span class="keyword">lock</span>;  <span class="comment">/*此时整个库处于只读状态*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不加锁的话，备份系统备份的得到的库不是一个逻辑时间点，这个视图是逻辑不一致的</p>
</li>
<li><p>MySQL中的innodb支持事务：当 mysqldump 使用参数：–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图；同时过程中数据可更新</p>
</li>
<li><p>推荐使用ftwrl命令，少用set global variable readonly=true</p>
<ol>
<li>readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库</li>
<li>执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁；而后者则会一直持有锁不会自动释放</li>
</ol>
</li>
</ul>
<ol>
<li><p>查看加锁表</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看分析表锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Table_lock%'</span>;</span><br><span class="line">table_lock_immediate  <span class="comment">/*累计加锁次数*/</span></span><br><span class="line">table_lock_waited <span class="comment">/*正在等待的加索的进程*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul>
<li>语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lock</span> <span class="keyword">tables</span> … <span class="keyword">read</span>/write <span class="comment">#加锁</span></span><br><span class="line"><span class="keyword">unlock</span> <span class="keyword">tables</span> <span class="comment">#释放</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><ul>
<li>访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性</li>
<li>当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁<ul>
<li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查</li>
<li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性</li>
<li><strong>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放</strong>，需要小心使用避免误操作使数据库挂掉。在拿不到MDL使需要进行处理<ul>
<li>这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃</li>
<li>DDL NOWAIT/WAIT n 语法<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">NOWAIT</span> <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">WAIT</span> N <span class="keyword">add</span> <span class="keyword">column</span> ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><h3 id="行锁-1"><a href="#行锁-1" class="headerlink" title="行锁"></a>行锁</h3><ul>
<li>行锁实现于存储引擎层</li>
</ul>
<ol>
<li><p>事务的ACID特性（原子性，一致性，隔离性，持久性）</p>
</li>
<li><p>事务隔离级别（read uncommited,read commited,repeatable read,lock read）</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>read uncommited</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>read commited</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>repeatable read</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>lock read</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody></table>
</li>
<li><p>查看当前事务隔离级别</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> lik <span class="string">'transaction_isolation'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>索引失效会导致行锁变为表锁；例如使用类型转换</p>
</li>
<li><p>间隙锁会在锁定一个范围导致一些操作无法操作</p>
</li>
<li><p>锁定一行</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> s <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="间隙锁（gap锁）"><a href="#间隙锁（gap锁）" class="headerlink" title="间隙锁（gap锁）"></a>间隙锁（gap锁）</h3><ul>
<li>为了解决幻读问题，InnoDB 引入新的锁，也就是间隙锁 (Gap Lock)</li>
<li>间隙锁，锁的就是两个值之间的空隙</li>
<li>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系</li>
<li>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间</li>
<li>gap锁是一个动态概念，数据修改后可能会扩展范围</li>
<li>间隙锁的引入，解决了幻读的问题。但是导致同样的语句锁住更大的范围，影响了并发度</li>
<li>你如果把隔离级别设置为读提交，就没有间隙锁了。但同时需要解决可能出现的数据和日志不一致问题，需要把 binlog 格式设置为 row</li>
</ul>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><ul>
<li>innodb中行锁在需要时加上，事务提交时释放</li>
<li><strong>如果需要锁多行，则需要将并发度高的放后面</strong></li>
</ul>
<h3 id="死锁于死锁检测"><a href="#死锁于死锁检测" class="headerlink" title="死锁于死锁检测"></a>死锁于死锁检测</h3><ul>
<li>死锁：由于不同线程出现资源相互等待而进入无限循环状态<ul>
<li>解决方法：<ol>
<li>等待超时：参数：innodb_lock_wait_timeout：设置等待超时时间</li>
<li>死锁检测：参数：innodb_deadlock_detect：设置开启死锁检测</li>
</ol>
</li>
<li>解决方案的优缺点</li>
</ul>
</li>
<li>提高并发度建议：<ol>
<li>关闭死锁检测</li>
<li>控制并发数</li>
<li>逻辑上通过将一行使用多行来代替</li>
</ol>
</li>
</ul>
<h2 id="加锁规则（两原则，两优化，一bug）"><a href="#加锁规则（两原则，两优化，一bug）" class="headerlink" title="加锁规则（两原则，两优化，一bug）"></a>加锁规则（两原则，两优化，一bug）</h2><ol>
<li>原则 1：加锁的基本单位是 next-key lock。next-key lock 是前开后闭区间</li>
<li>原则 2：查找过程中访问到的对象才会加锁</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ol>
<h3 id="上锁注意点"><a href="#上锁注意点" class="headerlink" title="上锁注意点"></a>上锁注意点</h3><ul>
<li>锁是加载在索引上。执行 for update 时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上行锁</li>
<li>删除数据的时候尽量加 limit。这样不仅可以控制删除数据的条数，让操作更安全，还可以减小加锁的范围</li>
<li>next-key lock 先是加间隙锁，加锁成功；然后加上行锁</li>
<li>读提交隔离级别下：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>MySQL全局锁与表级锁</li>
<li>备库时看是否支持事务，选择锁库方式</li>
<li>注意MDL元数据表锁的使用</li>
<li>数据库出现 lock tables 语句时，需要引起注意。检查存储引擎和业务代码</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>docker笔记网站记录</title>
    <url>/2020/01/22/docker/docker-network-notes/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->

<!-- TOC END -->
<a id="more"></a>

<ul>
<li><a href="http://dockone.io/article/2941" target="_blank" rel="noopener">docker核心技术与实现原理</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2019/12/10/mysql/MySQL%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#索引">索引</a></li>
<li><a href="#索引的优缺点">索引的优缺点</a><ul>
<li><a href="#常见索引类型">常见索引类型</a><ul>
<li><a href="#哈希索引kv键值对类型通过计算将查找值换算成一个具体位置然后取出数据">哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据</a></li>
<li><a href="#有序数组按照字段排序来确定存放位置">有序数组：按照字段排序来确定存放位置</a></li>
</ul>
</li>
<li><a href="#innodb的索引模型">Innodb的索引模型</a><ul>
<li><a href="#覆盖索引">覆盖索引</a></li>
<li><a href="#最左匹配原则">最左匹配原则</a></li>
<li><a href="#索引下推">索引下推</a></li>
</ul>
</li>
<li><a href="#小结">小结</a></li>
</ul>
</li>
<li><a href="#索引选择出错">索引选择出错</a></li>
<li><a href="#字符串索引创建">字符串索引创建</a></li>
<li><a href="#索引失效案例">索引失效案例</a><ul>
<li><a href="#条件函数操作">条件函数操作</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>索引是特殊的数据结构</li>
<li>索引可以加速数据库对数据的检索速度，对数据进行排序</li>
<li>索引就是对数据进行排序加速检索速度的特殊数据结构</li>
</ul>
<h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><ul>
<li>优点<ol>
<li>建立索引可以加速对于数据的检索速度</li>
<li>可以消除排序的操作，加快 SQL 执行速度，节省 CPU 资源</li>
<li>可以较低磁盘的 IO 读写</li>
</ol>
</li>
<li>缺点<ol>
<li>索引实质还是一张表，建立索引意味着额外的资源开销</li>
<li>维护许多索引需要较大的内存等资源开销</li>
<li>索引加快了读操作，但是降低了写操作的速度，因为修改表的操作同时需要对索引进行修改</li>
<li>需要花费更多的时间来建立一个优秀的索引</li>
</ol>
</li>
</ul>
<h2 id="常见索引类型"><a href="#常见索引类型" class="headerlink" title="常见索引类型"></a>常见索引类型</h2><h3 id="哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据"><a href="#哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据" class="headerlink" title="哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据"></a>哈希索引：kv键值对类型，通过计算将查找值换算成一个具体位置，然后取出数据</h3><ol>
<li>无序索引,数据添加容易,直接追加</li>
<li>适合等值查找，范围查找性能差<h3 id="有序数组：按照字段排序来确定存放位置"><a href="#有序数组：按照字段排序来确定存放位置" class="headerlink" title="有序数组：按照字段排序来确定存放位置"></a>有序数组：按照字段排序来确定存放位置</h3></li>
</ol>
<ul>
<li>采用N叉树：B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数</li>
</ul>
<ol>
<li>有序索引，范围查找更优秀</li>
<li>适用于静态存储引擎</li>
<li>插入数据删除数据时存在一定问题，可能会导致页分裂和页合并，造成数据的空洞</li>
</ol>
<h2 id="Innodb的索引模型"><a href="#Innodb的索引模型" class="headerlink" title="Innodb的索引模型"></a>Innodb的索引模型</h2><ul>
<li>InnoDB 中，表都是根据主键顺序以索引的形式存放</li>
<li>主键为聚簇索引：主键索引的叶子节点存的是整行数据</li>
<li>非主键索引：非主键索引的叶子节点内容是主键的值（二级索引）</li>
<li>回表：在非主键索引中找到主键，然后回到主键索引树搜索的操作</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul>
<li>在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引</li>
<li>覆盖索引可以减少树的搜索次数，显著提升查询性能</li>
</ul>
<h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><ul>
<li>利用索引的“最左前缀”，来定位记录</li>
<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><ul>
<li>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>普通索引重建时可以提高磁盘利用率，使索引更紧凑</li>
<li>重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建；建议使用 “alter table T engine=InnoDB”</li>
</ul>
<h1 id="索引选择出错"><a href="#索引选择出错" class="headerlink" title="索引选择出错"></a>索引选择出错</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time=<span class="number">0</span>;    //开启慢查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;    //普通查询</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">force</span> <span class="keyword">index</span>(a) <span class="keyword">where</span> a <span class="keyword">between</span> <span class="number">10000</span> <span class="keyword">and</span> <span class="number">20000</span>;   //强制索引查询</span><br></pre></td></tr></table></figure>

<ul>
<li><p>由优化器选择出最有索引，通过扫描行数来决定最优的，越少则访问磁盘次数最少</p>
</li>
<li><p>区分度：索引统计信息，索引的不同值的多少。不同值越多，区分度愈大。区分度大好</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_nane;//查看基数值</span><br></pre></td></tr></table></figure>

<ol>
<li><p>通过局部估算来获得基数值。InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数。当数据库修改的数据超过阈值 1/M 时会重新计算基数值。也可以手动重新计算基数值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> table_name;//重新计算基数值</span><br></pre></td></tr></table></figure>
</li>
<li><p>两种统计方法置参数 innodb_stats_persistent</p>
<ol>
<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10。</li>
<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h1 id="字符串索引创建"><a href="#字符串索引创建" class="headerlink" title="字符串索引创建"></a>字符串索引创建</h1><ol>
<li>直接索引，使用较大存储空间</li>
<li>前缀索引，增加回表次数，无法使用覆盖索引</li>
<li>倒叙再前缀索引，弥补前缀索引区分度不够</li>
<li>hash索引，性能稳定，额外开销</li>
</ol>
<h1 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h1><h2 id="条件函数操作"><a href="#条件函数操作" class="headerlink" title="条件函数操作"></a>条件函数操作</h2><ol>
<li><p>如果在 sql 语句中条件不部分使用了函数操作，则会导致索引失效，走全盘扫描。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tradelog <span class="keyword">where</span> <span class="keyword">month</span>(t_modified)=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对索引字段做函数操作，可能会破坏索引值的有序性，优化器就决定放弃走树搜索功能</p>
</li>
<li><p>对于索引右边的数据可以进行函数操作</p>
</li>
<li><p><strong>解决</strong>：避免在 where 条件中左边使用函数操作</p>
</li>
</ul>
</li>
<li><p>隐式类型转换</p>
<ul>
<li>字符串和数字做比较的话，是将字符串转换成数字（同使用了函数操作类似）</li>
<li><strong>解决</strong>：写语句时注意字段类型</li>
</ul>
</li>
<li><p>隐式字符编码转换</p>
<ul>
<li>关联表中的数据进行对比时如果不是一个字符集则需要进行类型转换</li>
<li><strong>解决</strong>：连接过程中要求在被驱动表的索引字段上加函数操作，是直接导致对被驱动表做全表扫描的原因</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL隔离级别</title>
    <url>/2019/12/09/mysql/MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#隔离性与隔离级别">隔离性与隔离级别</a><ul>
<li><a href="#隔离级别">隔离级别</a><ul>
<li><a href="#视图">视图</a></li>
<li><a href="#事务隔离实现">事务隔离实现</a></li>
</ul>
</li>
<li><a href="#小结">小结</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h1><ul>
<li>当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul>
<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到</li>
<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到</li>
<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</li>
<li>串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>
<li><strong>隔离级别越高，并发性能越低</strong></li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li>数据库在事务启动时会创建一个视图，整个事务过程都需要使用</li>
<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>
<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问</li>
<li>事务启动时的视图可以认为是静态的，不受其他事务更新的影响</li>
</ul>
<h3 id="事务隔离实现"><a href="#事务隔离实现" class="headerlink" title="事务隔离实现"></a>事务隔离实现</h3><ul>
<li>实现：每条记录在更新时都记录有一条回滚操作，记录上的新值通过回滚操作回到上一个状态的值</li>
<li>回滚日志删除：系统判断没有比当前回滚日志更早的视图时自动删除</li>
<li><strong>避免使用长事务</strong>：长事务会使系统存在很老的视图，所以会一直保留回滚日志。照成较大的存储空间浪费；同时还有可能照成锁的占用，拖垮数据库</li>
</ul>
<h4 id="事务启动方式"><a href="#事务启动方式" class="headerlink" title="事务启动方式"></a>事务启动方式</h4><ol>
<li><p>显示启动事务：通过begin或者start transaction来启动事务，通过commit提交或rollback回滚</p>
</li>
<li><p>隐式自动提交事务：系统设置 set autocommit=1 自动提交事务</p>
<ul>
<li>显示开启事务：使用 commit work and chain 来提交事务并自动开启下一个事务</li>
</ul>
</li>
<li><p>查看时间超过60s的长事务</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.innodb_trx</span><br><span class="line"><span class="keyword">where</span> TIME_TO_SEC(<span class="keyword">timediff</span>(<span class="keyword">now</span>(),trx_started))&gt;<span class="number">60</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>参数：transaction_isolation：查看数据库当前隔离状态</li>
<li>参数：MAX_EXECUTION_TIME：set MAX_EXECUTION_TIME来设置事务最大执行时间</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2019/12/08/mysql/MySQL%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mysql日志模块">MySQL日志模块</a><ul>
<li><a href="#redo-log重做日志">redo-log（重做日志）</a></li>
<li><a href="#binlog归档日志">binlog（归档日志）</a></li>
<li><a href="#两种日志比较">两种日志比较</a></li>
<li><a href="#两阶段提交">两阶段提交</a></li>
<li><a href="#小结">小结</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="MySQL日志模块"><a href="#MySQL日志模块" class="headerlink" title="MySQL日志模块"></a>MySQL日志模块</h1><h2 id="redo-log（重做日志）"><a href="#redo-log（重做日志）" class="headerlink" title="redo-log（重做日志）"></a>redo-log（重做日志）</h2><ul>
<li><p>MySQL如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高</p>
</li>
<li><p>MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘。InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，在系统不是那么繁忙时再将内存中数据写入磁盘</p>
</li>
<li><p>redo-log大小固定，类似循环队列</p>
</li>
<li><p>为MySQL提供cache-safe功能，中途crash也能恢复</p>
</li>
</ul>
<h2 id="binlog（归档日志）"><a href="#binlog（归档日志）" class="headerlink" title="binlog（归档日志）"></a>binlog（归档日志）</h2><ul>
<li>MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志</li>
</ul>
<h2 id="两种日志比较"><a href="#两种日志比较" class="headerlink" title="两种日志比较"></a>两种日志比较</h2><ol>
<li><p>redo-log是innodb存储引擎的日志系统；binlog是MySQL的server层的日志系统</p>
</li>
<li><p>redo-log是物理日志，记录数据库那个页上发生了改变；binlog是逻辑日志，记录某一条具体的数据库操作</p>
</li>
<li><p>redo-log大小固定，循环写，类似循环队列；binlog采用追加方式，写满后跳转下一个日志文件，不会覆盖前面的文件</p>
</li>
</ol>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><ul>
<li><p>prepare状态与commit状态</p>
</li>
<li><p>如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><p>redo log 用于保证 crash-safe 能力</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">#这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘</span><br><span class="line"></span><br><span class="line">sync_binlog=1</span><br><span class="line">#这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘</span><br></pre></td></tr></table></figure>
</li>
<li><p>两阶段提交保证两个日志保持逻辑上一致</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>初始Docker</title>
    <url>/2019/11/29/docker/%E5%88%9D%E8%AF%86Docker/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#docker第一步">Docker第一步</a><ul>
<li><a href="#安装docker">安装Docker</a></li>
<li><a href="#deepin安装docker">deepin安装docker</a></li>
<li><a href="#创建docker用户组">创建docker用户组</a></li>
</ul>
</li>
<li><a href="#docker国内镜像加速">Docker国内镜像加速</a></li>
<li><a href="#dockerfile">Dockerfile</a><ul>
<li><a href="#定制">定制</a></li>
<li><a href="#from-与-run-构建">FROM 与 RUN 构建</a><ul>
<li><a href="#from指定基础对象">FROM指定基础对象</a></li>
<li><a href="#run执行命令">RUN执行命令</a></li>
</ul>
</li>
<li><a href="#命令">命令</a><ul>
<li><a href="#构建上下文context">构建上下文Context</a></li>
</ul>
</li>
<li><a href="#dockerfile指令详解">Dockerfile指令详解</a><ul>
<li><a href="#copy">copy</a></li>
<li><a href="#add">add</a></li>
<li><a href="#cmd">cmd</a></li>
<li><a href="#entrypoint">entrypoint</a></li>
<li><a href="#env与arg设置变量参数">env与arg设置变量参数</a></li>
<li><a href="#volume">volume</a></li>
<li><a href="#expose">expose</a></li>
<li><a href="#workdir与user">workdir与user</a></li>
<li><a href="#healthcheck">healthcheck</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Docker第一步"><a href="#Docker第一步" class="headerlink" title="Docker第一步"></a>Docker第一步</h1><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><ol>
<li><p>安装必要工具，yum-utils提供yum-config-manager功能，另外两个是devicemapper驱动依赖</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data.x86_64 \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建yum源repo文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker中央仓库</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># 阿里仓库</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新并安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum install docker-ce-19.03.2-3.el7</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="deepin安装docker"><a href="#deepin安装docker" class="headerlink" title="deepin安装docker"></a>deepin安装docker</h2><ol>
<li><p>安装docker-ce与密钥管理与下载相关的工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -   <span class="comment"># 国内的源</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证密钥</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-key fingerprint 0EBFCD88</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加docker仓库</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository <span class="string">"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian jessie stable"</span></span><br><span class="line"><span class="comment"># 如果不行就讲引号中的内容添加到 /etc/apt/sources.list</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更新</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建docker用户组"><a href="#创建docker用户组" class="headerlink" title="创建docker用户组"></a>创建docker用户组</h2><ul>
<li>默认情况下，docker 命令会使用Unix socket与Docker引擎通讯。而只有root用户和docker 组的用户才可以访问Docker引擎的Unix socket</li>
<li>使普通用户也能使用docker所以需要将用户加入docker用户组中</li>
</ul>
<h1 id="Docker国内镜像加速"><a href="#Docker国内镜像加速" class="headerlink" title="Docker国内镜像加速"></a>Docker国内镜像加速</h1><ol>
<li><p>镜像加速页</p>
<ul>
<li><a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">https://cr.console.aliyun.com/</a></li>
</ul>
</li>
<li><p>选择镜像加速服务</p>
</li>
<li><p>启用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json \&lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://3hijzt0l.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 国内镜像源</span></span><br><span class="line">　　　  <span class="comment"># "http://ovfftd6p.mirror.aliyuncs.com",</span></span><br><span class="line">　　　  <span class="comment"># "http://registry.docker-cn.com",</span></span><br><span class="line">　　　  <span class="comment"># "http://docker.mirrors.ustc.edu.cn",</span></span><br><span class="line">　　　  <span class="comment"># "http://hub-mirror.c.163.com"</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h2><ul>
<li>定制每一层所添加的配置、文件</li>
</ul>
<h2 id="FROM-与-RUN-构建"><a href="#FROM-与-RUN-构建" class="headerlink" title="FROM 与 RUN 构建"></a>FROM 与 RUN 构建</h2><h3 id="FROM指定基础对象"><a href="#FROM指定基础对象" class="headerlink" title="FROM指定基础对象"></a>FROM指定基础对象</h3><ul>
<li>Dockerfile 中FROM 是必备的指令，并且必须是第一条指令</li>
</ul>
<h3 id="RUN执行命令"><a href="#RUN执行命令" class="headerlink" title="RUN执行命令"></a>RUN执行命令</h3><ul>
<li>执行命令行命令</li>
<li>每一个指令都会建立一层</li>
<li>确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉</li>
</ul>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><ul>
<li>创建一个镜像<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build [option] &lt;context上下文路劲&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="构建上下文Context"><a href="#构建上下文Context" class="headerlink" title="构建上下文Context"></a>构建上下文Context</h3><ul>
<li>一切都是使用的远程调用形式在服务端（Docker 引擎）完成</li>
<li>docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker 引擎</li>
</ul>
<h2 id="Dockerfile指令详解"><a href="#Dockerfile指令详解" class="headerlink" title="Dockerfile指令详解"></a>Dockerfile指令详解</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><ul>
<li><p>格式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等</p>
</li>
</ul>
<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul>
<li>与copy相似</li>
<li>ADD 指令将会自动解压缩这个压缩文件到&lt;目标路径&gt;</li>
<li>ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</li>
</ul>
<h3 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h3><ul>
<li>用于指定默认的容器主进程的启动命令</li>
<li>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出</li>
</ul>
<h3 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h3><ul>
<li>指定容器启动程序及参数</li>
<li>指定了ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将CMD 的内容作为参数传给ENTRYPOINT 指令</li>
</ul>
<h3 id="env与arg设置变量参数"><a href="#env与arg设置变量参数" class="headerlink" title="env与arg设置变量参数"></a>env与arg设置变量参数</h3><ul>
<li>ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的</li>
</ul>
<h3 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h3><ul>
<li><p>尽量保持容器存储层不发生写操作</p>
</li>
<li><p>数据持久化</p>
</li>
<li><p>格式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">VOLUME [<span class="string">"&lt;路径1&gt;"</span>, <span class="string">"&lt;路径2&gt;"</span>...]</span><br><span class="line">VOLUME &lt;路径&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名卷：任何写入操作都写入宿主机中不写入容器存储层。从而实现数据持久化</p>
</li>
</ul>
<h3 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h3><ul>
<li>声明运行时容器提供服务端口，在运行时并不会开启这个端口的服务</li>
<li>-p参数是映射宿主端口和容器端口；EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射</li>
</ul>
<h3 id="workdir与user"><a href="#workdir与user" class="headerlink" title="workdir与user"></a>workdir与user</h3><ul>
<li>workdir:指定工作目录</li>
<li>user:指定当前用户</li>
</ul>
<h3 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h3><ul>
<li>健康检查</li>
<li>如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务</li>
<li>HEALTHCHECK 支持下列选项：<ol>
<li>--interval=&lt;间隔&gt; ：两次健康检查的间隔，默认为30 秒；</li>
<li>--timeout=&lt;时长&gt; ：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认30 秒；</li>
<li>--retries=&lt;次数&gt; ：当连续失败指定次数后，则将容器状态视为unhealthy ，默认3 次</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL磁盘扩展与介质迁移</title>
    <url>/2019/11/23/mysql/MySQL%E7%A3%81%E7%9B%98%E6%89%A9%E5%B1%95%E4%B8%8E%E4%BB%8B%E8%B4%A8%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mysql外部表mysql80">MySQL外部表（MySQL8.0）</a><ul>
<li><a href="#使用原因">使用原因</a></li>
</ul>
</li>
<li><a href="#实验实例">实验实例</a><ul>
<li><a href="#实验迁移mysql57">实验迁移（MySQL5.7）</a></li>
</ul>
</li>
<li><a href="#问题">问题</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="MySQL外部表（MySQL8-0）"><a href="#MySQL外部表（MySQL8-0）" class="headerlink" title="MySQL外部表（MySQL8.0）"></a>MySQL外部表（MySQL8.0）</h1><ul>
<li>使用MySQL的外部表进行数据的迁移可扩展</li>
</ul>
<h2 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h2><ul>
<li>存储空间不够，一些大表需要更大的存储空间</li>
<li>存储介质更新，需要迁移到更块的介质中</li>
</ul>
<h1 id="实验实例"><a href="#实验实例" class="headerlink" title="实验实例"></a>实验实例</h1><ul>
<li>源数据库位于 /var/lib/mysql/pre_database</li>
<li>外部表库位于 /var/lib/mysql_extend/pre_database</li>
</ul>
<ol>
<li><p>新建的表，位于新的存储位置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mysql_extend_table`</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">age <span class="built_in">INT</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">21</span></span><br><span class="line">)<span class="keyword">DATA</span> <span class="keyword">DIRECTORY</span> = <span class="string">'/var/lib/mysql_extend'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend1.png" alt="权限"></p>
</li>
<li><p>可以看见，新建的表已经在指定的存储位置</p>
<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend2.png" alt="权限"></p>
</li>
<li><p><strong>注意相应文件夹权限要够</strong><br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/extend3.png" alt="权限"></p>
</li>
</ol>
<h2 id="实验迁移（MySQL5-7）"><a href="#实验迁移（MySQL5-7）" class="headerlink" title="实验迁移（MySQL5.7）"></a>实验迁移（MySQL5.7）</h2><ol>
<li><p>转移前<br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra1.png" alt="转移前"></p>
</li>
<li><p>创建表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">tablespace</span> mysql_pre_table</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">datafile</span> <span class="string">'/var/lib/mysql_extend/pre_database/tra_table.ibd'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra2.png" alt="创建"></p>
</li>
<li><p>迁移表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mysql_pre_table <span class="keyword">tablespace</span> mysql_pre_table;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果:原pre_table转移为现在的now_table<br><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra3.png" alt="转移后"></p>
</li>
<li><p>查看表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.INNODB_SYS_TABLESPACES;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/11/23/mysql/MySQL磁盘扩展与介质迁移/tra4.png" alt="tablespace"></p>
<ol>
<li>FILE_FORMAT:ANY ROW_FORMAT:ANY SPACE_TYPE:General 表明：<ol>
<li>这个表空间并不是 per_table 的，是可以多个表公用的存储空间</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li><p>在MySQL8.0中无法在其他数据目录下创建tablespace</p>
<ul>
<li>需要配置 innodb_directories 参数：官方文档链接(<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_directories</a>)</li>
<li>定义要在启动时扫描的表空间文件的目录。当服务器脱机时将表空间文件移动或还原到新位置时，将使用此选项。它还用于指定使用绝对路径创建或位于数据目录外部的表空间文件的目录</li>
</ul>
</li>
<li><p>在MySQL8.0中，将表创建在其他地方，不会在当前数据目录下创建任何东西，无 .isl 文件</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>HTML5基础</title>
    <url>/2019/11/20/python/Django3.0/HTML%E5%9F%BA%E7%A1%80/HTML5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#html5基础">HTML5基础</a><ul>
<li><a href="#html格式与部分元素">HTML格式与部分元素</a></li>
<li><a href="#html元素">HTML元素</a></li>
<li><a href="#html属性">HTML属性</a></li>
<li><a href="#html格式化">HTML格式化</a></li>
<li><a href="#html列表">HTML列表</a><ul>
<li><a href="#html块">HTML块</a></li>
</ul>
</li>
<li><a href="#html样式">HTML样式</a></li>
<li><a href="#html布局">HTML布局</a></li>
<li><a href="#html链接属性">HTML链接属性</a><ul>
<li><a href="#html表单">HTML表单</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="HTML5基础"><a href="#HTML5基础" class="headerlink" title="HTML5基础"></a>HTML5基础</h1><h2 id="HTML格式与部分元素"><a href="#HTML格式与部分元素" class="headerlink" title="HTML格式与部分元素"></a>HTML格式与部分元素</h2>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文档类型说明 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!Doctype html&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--头部信息--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--元信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--标题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML基础<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--包含页面内的所有主体内容--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--直接显示文本--&gt;</span></span><br><span class="line">    Hello Html5!</span><br><span class="line">    <span class="comment">&lt;!-- class:给元素添加一个或多个样式表类名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span>here is title!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- contenteditable:表示文件是否可编辑 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span>&gt;</span>可编辑<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 显示内容的开始位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">dir</span>=<span class="string">"rtl"</span>&gt;</span>在右边哟,不是在左边<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id：元素的唯一标识 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"myheader"</span>&gt;</span>这是显示id的作用!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- style：行内元素的样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: blue;text-align: center"</span>&gt;</span>这是标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span>这也是标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color: yellow;text-align: center;"</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- tabindex：tab键的选取顺序 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com/"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.aliyun.com/"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span>Aliyun<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.tencent.com/"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span>Tencent<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- title：鼠标悬停时显示的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">title</span>=<span class="string">"http://www.jd.com/"</span>&gt;</span>JD<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>HTML基础标签</p>
<ul>
<li>head、body<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML标题</p>
<ul>
<li>&lt;h1&gt;到&lt;h6&gt;缩进标签<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML段落</p>
<ul>
<li>&lt;p&gt;标识段落<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>message<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML超链接</p>
<ul>
<li>&lt;a&gt;标识超链接<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com/"</span>&gt;</span>Baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>HTML图像</p>
<ul>
<li><img>标签为图片<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"local"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h2><ol>
<li><p>元素</p>
<ul>
<li>元素是指开始标签从开始到结束标签的所有代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span>：换行标签（空元素标签）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>语法</p>
<ol>
<li>空元素在开始标签中结束关闭</li>
<li>大多数HTML元素可以嵌套</li>
</ol>
</li>
</ol>
<h2 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h2><ol>
<li><p>标签可以拥有属性为元素提供更多信息</p>
</li>
<li><p>属性以键值对形式出现</p>
</li>
<li><p>常用标签</p>
<ol>
<li><p>&lt;h1&gt;:align对其方式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>title 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;body&gt;：bgcolor背景颜色</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">"#82cf05"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&lt;a&gt;:target规定在何处打开</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"localhost.html"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">1. _self：当前页面打开</span><br><span class="line">2. _blank：新页面打开</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>通用属性：</p>
<ol>
<li>class：规定元素的类名</li>
<li>id：标记元素的唯一ID</li>
<li>style：规定元素的样式</li>
<li>title：元素额外信息</li>
</ol>
</li>
</ol>
<h2 id="HTML格式化"><a href="#HTML格式化" class="headerlink" title="HTML格式化"></a>HTML格式化</h2><p><img src="/2019/11/20/python/Django3.0/HTML基础/HTML5基础/%E6%A0%BC%E5%BC%8F%E5%8C%96.png" alt></p>
<h2 id="HTML列表"><a href="#HTML列表" class="headerlink" title="HTML列表"></a>HTML列表</h2><p><img src="/2019/11/20/python/Django3.0/HTML基础/HTML5基础/HTML%E5%88%97%E8%A1%A8.png" alt></p>
<h3 id="HTML块"><a href="#HTML块" class="headerlink" title="HTML块"></a>HTML块</h3><p><img src="/2019/11/20/python/Django3.0/HTML基础/HTML5基础/HTML%E5%9D%97.png" alt></p>
<h2 id="HTML样式"><a href="#HTML样式" class="headerlink" title="HTML样式"></a>HTML样式</h2><ol>
<li><p>标签</p>
<ul>
<li>&lt;style&gt;：样式定义</li>
<li>&lt;link&gt;：资源引用</li>
</ul>
</li>
<li><p>属性</p>
<ol>
<li>rel=”syslesheet”：外部样式表</li>
<li>type=”text/css”：引入文档的类型</li>
<li>margin-left：边距</li>
</ol>
</li>
<li><p>插入方法</p>
<ol>
<li><p>外部样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"mystyle.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">body &#123;background-color: gred&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内联样式表</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:red"</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h2><ul>
<li>div布局</li>
<li>table布局</li>
</ul>
<h2 id="HTML链接属性"><a href="#HTML链接属性" class="headerlink" title="HTML链接属性"></a>HTML链接属性</h2><ol>
<li><p>链接数据：</p>
<ul>
<li>文本链接</li>
<li>图片链接</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li>href：指向另一个文档的链接</li>
<li>name：创建文档内的链接（同一页面内的内容跳转）</li>
</ul>
</li>
<li><p>img标签属性</p>
<ul>
<li>alt：替换文本属性</li>
<li>width：宽</li>
<li>height：高</li>
</ul>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span>baidu<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"suo.jpeg"</span> <span class="attr">width</span>=<span class="string">"200px"</span> <span class="attr">hight</span>=<span class="string">"200px"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JeffQi<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> &gt;</span></span><br><span class="line">        用户：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        密码：</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"sign in"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        多选:</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        苹果：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        西红柿：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        性别：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        男：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">        女：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        选项网址：</span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.baidu.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.google.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>www.jeffqi.com<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"button"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">row</span>=<span class="string">"30"</span>&gt;</span>填写个人信息<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2019/11/10/linux/git/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#分布式与集中式">分布式与集中式</a></li>
<li><a href="#git起步">git起步</a></li>
<li><a href="#版本控制">版本控制</a><ul>
<li><a href="#第一个任务">第一个任务</a></li>
<li><a href="#版本回退">版本回退</a><ul>
<li><a href="#工作区与暂存区">工作区与暂存区</a></li>
</ul>
</li>
<li><a href="#撤销修改和删除">撤销修改和删除</a></li>
</ul>
</li>
<li><a href="#远程仓库">远程仓库</a><ul>
<li><a href="#创建远程仓库">创建远程仓库</a></li>
<li><a href="#远程克隆仓库">远程克隆仓库</a></li>
</ul>
</li>
<li><a href="#分支管理">分支管理</a><ul>
<li><a href="#创建与合并分支">创建与合并分支</a></li>
<li><a href="#分支管理-1">分支管理</a></li>
<li><a href="#bug分支">Bug分支</a></li>
<li><a href="#featurre分支">featurre分支</a></li>
</ul>
</li>
<li><a href="#多人协作">多人协作</a></li>
<li><a href="#标签">标签</a></li>
<li><a href="#创建git仓库">创建git仓库</a></li>
<li><a href="#其他git配置使用">其他git配置使用</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="分布式与集中式"><a href="#分布式与集中式" class="headerlink" title="分布式与集中式"></a>分布式与集中式</h1><ul>
<li><p>集中式CVS，SVN：</p>
<ol>
<li>速度慢，必须联网，开源精神不符</li>
<li>版本库集中放在中央服务器，工作时，获取最新版本，工作完成后，再推送给中央服务器！</li>
</ol>
</li>
<li><p>分布式GIT：</p>
<ol>
<li>无中央服务器，每个人的电脑都是一个完整的版本库</li>
<li>安全性能更高</li>
<li>通常有一台充当“中央服务器”的电脑，仅仅作为方便“交换”大家的修改</li>
</ol>
</li>
<li><p>所有的版本控制系统，其实<strong>只能跟踪文本文件的改动</strong>，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
</li>
</ul>
<h1 id="git起步"><a href="#git起步" class="headerlink" title="git起步"></a>git起步</h1><ol>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install  -y git</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><h2 id="第一个任务"><a href="#第一个任务" class="headerlink" title="第一个任务"></a>第一个任务</h2><ol>
<li><p>工作区文件放入站暂存区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add xx.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>暂存区文件提交(设置你的git邮箱和git姓名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git commit -m &apos;message&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看查当前状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看修改文件不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git diff xx.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ol>
<li><p>查看提交记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log [--pretty=oneline]</span><br><span class="line">git reflog #查看历史记录</span><br></pre></td></tr></table></figure>
</li>
<li><p>回退版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^(hash码)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>控制版本历史记录：因为git内部有个Head指针指向当前的版本，如果需要退回版本，只需要将Head指针指向相对应的版本号，并且更新工作区文件</li>
</ul>
<h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><ul>
<li>工作区：当前所在的firstgit目录就是一个工作区</li>
<li>暂存区：git add 后的状态</li>
<li>master：git commit 后的状态保存到master上</li>
<li><strong>git跟踪的是每次修改而不是文件，如果不将修改添加到暂存区是无法加入commit中的</strong></li>
</ul>
<h2 id="撤销修改和删除"><a href="#撤销修改和删除" class="headerlink" title="撤销修改和删除"></a>撤销修改和删除</h2><ol>
<li><p>丢弃工作区修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- xx.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>将暂存区文件拉回工作区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD xx.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm xx.txt</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><ol>
<li><p>新建github仓库</p>
</li>
<li><p>添加ssh密钥</p>
</li>
<li><p>关联远程仓库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin url</span><br></pre></td></tr></table></figure>
</li>
<li><p>首次推送分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br><span class="line">git push origin master  #以后提交</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="远程克隆仓库"><a href="#远程克隆仓库" class="headerlink" title="远程克隆仓库"></a>远程克隆仓库</h2><ol>
<li>克隆<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone url</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul>
<li>你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作</li>
</ul>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><ol>
<li><p>创建新分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch dev</span><br><span class="line">git checkout -b dev #创建并切换</span><br><span class="line">git switch -c dev #创建并切换</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="分支管理-1"><a href="#分支管理-1" class="headerlink" title="分支管理"></a>分支管理</h2><ol>
<li><p>分支合并</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge --no-ff -m &apos;message&apos; dev</span><br></pre></td></tr></table></figure>

<ul>
<li>合并分支时，加上–no-ff参数关闭fast forward合并就可以用普通模式合并，合并后的历史<br>有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</li>
</ul>
</li>
<li><p>查看合并记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --graph --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><ol>
<li><p>将当前工作区内容藏起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改完后，将藏起来的内容恢复修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git stash list</span><br><span class="line">git stash apply # 用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</span><br><span class="line">git stash pop</span><br><span class="line">git stash apply stash@&#123;0&#125; # 多次stash，恢复的时候，先用git stash list查看，然后恢</span><br><span class="line">复指定的stash</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改bug后，将修改的bug分支复制到dev分支，完成修改工作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git cherry-pick hash</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="featurre分支"><a href="#featurre分支" class="headerlink" title="featurre分支"></a>featurre分支</h2><ol>
<li>删除未合并的分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -D tempbranch</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><ol>
<li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li>
<li>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创<br>建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></li>
<li>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</li>
</ol>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><ol>
<li><p>创建标签</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag tag_name</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看标签</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定标签</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag tag_name hash_id</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签需要和一个commit版本绑定</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -a tag_name -m <span class="string">'information'</span> hash_id</span><br></pre></td></tr></table></figure>
</li>
<li><p>标签删除</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -d tag_name</span><br><span class="line"><span class="comment"># 远程删除比较麻烦，先本地删除，在同步push远程</span></span><br><span class="line"><span class="comment"># git push origin :refs/tags/tag_name</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过标签推送</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin tag_name</span><br><span class="line"><span class="comment"># git push origin --tags</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><ol>
<li><p>安装git</p>
</li>
<li><p>创建git用户</p>
</li>
<li><p>收集公钥（id_rsa.pub文件），把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个</p>
</li>
<li><p>选定目录初始化</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init --bare sample.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改仓库的owner与group</p>
</li>
<li><p>修改git用户登录shell</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/passwd</span><br><span class="line">/usr/bin/git-shell</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="其他git配置使用"><a href="#其他git配置使用" class="headerlink" title="其他git配置使用"></a>其他git配置使用</h1><ol>
<li><p>使用颜色</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git config --global color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略git文件</p>
<ul>
<li>必须把某些文件放到Git工作目录中，但又不能提交它们</li>
<li>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL高可用之主从复制搭建</title>
    <url>/2019/11/07/mysql/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#配置主服务器">配置主服务器</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
<h1 id="配置主服务器"><a href="#配置主服务器" class="headerlink" title="配置主服务器"></a>配置主服务器</h1><ol>
<li><p>修改master配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">port=3306  </span><br><span class="line"></span><br><span class="line">basedir=/usr</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">tmpdir=/tmp</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line">log-bin=master-bin</span><br><span class="line">log-bin-index=master-bin.index</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个用于复制的用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &apos;repl_user&apos;@&apos;%&apos; identified with &apos;mysql_native_password&apos; by &apos;123456&apos;;</span><br><span class="line">grant replication slave on *.* to &apos;repl_user&apos;@&apos;%&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启master服务器的MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置slave配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">port=3306  </span><br><span class="line"></span><br><span class="line">basedir=/usr</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"></span><br><span class="line">tmpdir=/tmp</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line">relay-log=slave-relay-bin</span><br><span class="line">relay-log-index=slave-relay-bin.index</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启slave服务器MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
</li>
<li><p>slave切换master（MySQL服务中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">change master to</span><br><span class="line">  master_host=&apos;ip&apos;,</span><br><span class="line">  master_port=3306,</span><br><span class="line">  master_user=&apos;repl_user&apos;</span><br><span class="line">  master_password=&apos;123456&apos;,</span><br><span class="line">  &lt;!-- Master_log_file=&apos;&apos;,</span><br><span class="line">  master_log_pos=&apos;&apos; --&gt;</span><br><span class="line">  master_auto_position=1;</span><br><span class="line"></span><br><span class="line">start slave</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  mysql&gt; show slave status\G</span><br><span class="line"></span><br><span class="line">               Slave_IO_State: Waiting for master to send event   //检查</span><br><span class="line">                  Master_Host: xxx.xxx.xxx.xxx</span><br><span class="line">                  Master_User: repl_user</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: master-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 3117</span><br><span class="line">               Relay_Log_File: slave-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 3333</span><br><span class="line">        Relay_Master_Log_File: master-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes                                //检查</span><br><span class="line">            Slave_SQL_Running: Yes                                //检查</span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 3117</span><br><span class="line">              Relay_Log_Space: 3541</span><br><span class="line">              Until_Condition: None</span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">             Master_Server_Id: 1</span><br><span class="line">                  Master_UUID: 74be5d5f-9fe5-11e9-8853-e02651c</span><br><span class="line">             Master_Info_File: mysql.slave_master_info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates //检查</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                Auto_Position: 0</span><br><span class="line">        Get_master_public_key: 0</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>网课赠送笔记</title>
    <url>/2019/10/19/mysql/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#第1章mysql数据库的介绍以及课程大纲总览">第1章：mysql数据库的介绍以及课程大纲总览</a><ul>
<li><a href="#11-mysql的简介介绍">1.1 mysql的简介介绍</a></li>
<li><a href="#12-课程大纲总览">1.2 课程大纲总览</a></li>
</ul>
</li>
<li><a href="#第2章mysql数据库面试必备入门基础知识">第2章：mysql数据库面试必备入门基础知识</a><ul>
<li><a href="#21-mysql各个版本的重要性介绍">2.1 mysql各个版本的重要性介绍</a></li>
<li><a href="#22-mysql的核心知识之服务管理">2.2 mysql的核心知识之服务管理</a></li>
<li><a href="#23-mysql的可视化图形界面与命令行操作">2.3 mysql的可视化图形界面与命令行操作</a></li>
<li><a href="#24-mysql的库表深入解析">2.4 mysql的库表深入解析</a></li>
<li><a href="#25-mysql的sql各类语句精讲">2.5 mysql的sql各类语句精讲</a></li>
</ul>
</li>
<li><a href="#第3章mysql核心知识之ddl数据定义语言">第3章：mysql核心知识之DDL数据定义语言</a><ul>
<li><a href="#31-mysql数据库必备知识之创建查看以及使用切换">3.1 mysql数据库必备知识之创建、查看以及使用/切换</a></li>
<li><a href="#32-mysql创建表之常用数据类型">3.2 mysql创建表之常用数据类型</a></li>
<li><a href="#33-mysql数据表必备知识之创建表">3.3 mysql数据表必备知识之创建表</a></li>
<li><a href="#34-mysql数据表必备知识之查看">3.4 mysql数据表必备知识之查看</a></li>
<li><a href="#35-mysql数据表必备知识之表结构维护与删除">3.5 mysql数据表必备知识之表结构维护与删除</a></li>
</ul>
</li>
<li><a href="#第4章mysql核心知识之dml数据操纵语言">第4章：mysql核心知识之DML数据操纵语言</a><ul>
<li><a href="#41-mysql深入剖析表数据新增">4.1 mysql深入剖析表数据新增</a></li>
<li><a href="#42-mysql深入剖析表数据的修改以及删除">4.2 mysql深入剖析表数据的修改以及删除</a></li>
<li><a href="#43-mysql核心知识之中文乱码问题">4.3 mysql核心知识之中文乱码问题</a></li>
</ul>
</li>
<li><a href="#第5章mysql核心知识之dql数据查询语言与项目高级查询实战">第5章：mysql核心知识之DQL数据查询语言与项目高级查询实战</a><ul>
<li><a href="#51-mysql查询子句之一where条件查询">5.1 mysql查询子句之一where条件查询</a></li>
<li><a href="#52-mysql查询子句之二group-by分组查询分组">5.2 mysql查询子句之二group by分组查询（分组）</a></li>
<li><a href="#53-mysql查询子句之三having条件查询筛选">5.3 mysql查询子句之三having条件查询（筛选）</a></li>
<li><a href="#54-mysql查询子句之四order-by排序查询排序">5.4 mysql查询子句之四order by排序查询（排序）</a></li>
<li><a href="#55-mysql查询子句之五limit限制查询限制">5.5 mysql查询子句之五limit限制查询（限制）</a></li>
<li><a href="#56-mysql查询之exists型子查询">5.6 mysql查询之exists型子查询</a></li>
<li><a href="#57-mysql查询之左连接查询与右连接查询">5.7 mysql查询之左连接查询与右连接查询</a></li>
<li><a href="#58-mysql查询之内连接查询与联合查询">5.8 mysql查询之内连接查询与联合查询</a></li>
<li><a href="#59-mysql查询之项目高级查询实战一">5.9 mysql查询之项目高级查询实战(一)</a></li>
<li><a href="#510-mysql查询之项目高级查询实战二">5.10 mysql查询之项目高级查询实战(二)</a></li>
</ul>
</li>
<li><a href="#第6章mysql核心知识之dcl数据控制语言对用户权限的设置">第6章：mysql核心知识之DCL数据控制语言（对用户权限的设置）</a><ul>
<li><a href="#61-mysql限制root用户指定ip登录">6.1 mysql限制root用户指定ip登录</a></li>
<li><a href="#62-mysql必备知识之用户密码">6.2 mysql必备知识之用户密码</a></li>
<li><a href="#63-mysql实战系列之创建新用户并限制ip网段登录">6.3 mysql实战系列之创建新用户并限制ip网段登录</a></li>
<li><a href="#64-mysql实战系列之库表权限授权与回收">6.4 mysql实战系列之库表权限授权与回收</a></li>
</ul>
</li>
<li><a href="#第7章mysql的核心知识之事务实战视图触发器以及存储过程">第7章：mysql的核心知识之事务实战，视图，触发器，以及存储过程</a><ul>
<li><a href="#71-mysql-必备核心知识之事务的详细解析">7.1 mysql 必备核心知识之事务的详细解析</a></li>
<li><a href="#72-mysql-必备核心知识之事务实战">7.2 mysql 必备核心知识之事务实战</a></li>
<li><a href="#73-mysql核心知识之视图的应用">7.3 mysql核心知识之视图的应用</a></li>
<li><a href="#74-mysql-的触发器介绍">7.4 mysql 的触发器介绍</a></li>
<li><a href="#75-mysql的存储过程介绍">7.5 mysql的存储过程介绍</a></li>
</ul>
</li>
<li><a href="#第8章mysql必备核心知识之索引与存储引擎的介绍">第8章：mysql必备核心知识之索引与存储引擎的介绍</a><ul>
<li><a href="#81-mysql的存储引擎介绍">8.1 mysql的存储引擎介绍</a></li>
<li><a href="#82-mysql必备知识之常用索引精讲">8.2 mysql必备知识之常用索引精讲</a></li>
<li><a href="#83-mysql必备核心知识之普通索引与唯一索引">8.3 mysql必备核心知识之普通索引与唯一索引</a></li>
<li><a href="#84-mysql必备核心知识之主键索引">8.4 mysql必备核心知识之主键索引</a></li>
<li><a href="#85-mysql核心知识之全文索引的使用">8.5 mysql核心知识之全文索引的使用</a></li>
<li><a href="#86-mysql核心知识之外键约束剖析">8.6 mysql核心知识之外键约束剖析</a></li>
<li><a href="#87-mysql核心知识之联合索引">8.7 mysql核心知识之联合索引</a></li>
</ul>
</li>
<li><a href="#第9章mysql不得不学的sql语句优化思路">第9章：mysql不得不学的sql语句优化思路</a><ul>
<li><a href="#91-mysql的慢查询日志开启与问题定位">9.1 mysql的慢查询日志开启与问题定位</a></li>
<li><a href="#92-mysql的sql语句执行过程解析">9.2 mysql的sql语句执行过程解析</a></li>
<li><a href="#93-mysql语句优化的几个小建议">9.3 mysql语句优化的几个小建议</a></li>
</ul>
</li>
<li><a href="#第10章mysql数据安全核心知识之备份技能">第10章：mysql数据安全核心知识之备份技能</a><ul>
<li><a href="#101-mysql数据安全之备份的背景意义">10.1 mysql数据安全之备份的背景意义</a></li>
<li><a href="#102-mysql数据安全之备份的介绍">10.2 mysql数据安全之备份的介绍</a></li>
<li><a href="#103-mysql数据安全之mysqldump备份实例跨机器">10.3 mysql数据安全之mysqldump备份实例（跨机器）</a></li>
<li><a href="#104-mysql数据安全之mysql数据的恢复">10.4 mysql数据安全之mysql数据的恢复</a></li>
<li><a href="#105-mysql数据安全之物理备份">10.5 mysql数据安全之物理备份</a></li>
<li><a href="#106-mysql数据安全之利用二进制日志mysqlbinlog备份数据">10.6 mysql数据安全之利用二进制日志mysqlbinlog备份数据</a></li>
<li><a href="#107-mysql数据安全之利用二进制日志mysqlbinlog恢复数据">10.7 mysql数据安全之利用二进制日志mysqlbinlog恢复数据</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h2 id="第1章：mysql数据库的介绍以及课程大纲总览"><a href="#第1章：mysql数据库的介绍以及课程大纲总览" class="headerlink" title="第1章：mysql数据库的介绍以及课程大纲总览"></a>第1章：mysql数据库的介绍以及课程大纲总览</h2><p>​    <strong>简介：介绍什么是mysql以及整套课程的大纲知识点</strong></p>
<h3 id="1-1-mysql的简介介绍"><a href="#1-1-mysql的简介介绍" class="headerlink" title="1.1 mysql的简介介绍"></a>1.1 mysql的简介介绍</h3><p>​    <strong>简介：mysql的简介</strong></p>
<ul>
<li>1、什么是mysql？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql是一个开源的关系型数据库管理系统，现在是oracle公司旗下的一款产品，由C和C++语言编写，可移植性高。支持在多种操作系统上安装，最常见有AIX，linux，window。mysql因为开源免费，所以受到了目前互联网行业的欢迎。</span><br><span class="line"></span><br><span class="line">以mysql作为数据库，linux系统作为操作系统，apache或者nginx作为web服务器，perl/php/python作为服务端的脚本解释器，就可以搭建起一个免费的网站。被业界称为LNMP或者LAMP</span><br></pre></td></tr></table></figure>

<ul>
<li>2、适合人群：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">适合零基础，运维人员，程序开发人员，DBA数据库管理员等等所有从事IT行业的人。</span><br></pre></td></tr></table></figure>

<ul>
<li>3、学后达到的水平：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">入门偏中等水平</span><br></pre></td></tr></table></figure>

<h3 id="1-2-课程大纲总览"><a href="#1-2-课程大纲总览" class="headerlink" title="1.2 课程大纲总览"></a>1.2 课程大纲总览</h3><p>​    <strong>简介：介绍课程知识目录大纲</strong></p>
<hr>
<h2 id="第2章：mysql数据库面试必备入门基础知识"><a href="#第2章：mysql数据库面试必备入门基础知识" class="headerlink" title="第2章：mysql数据库面试必备入门基础知识"></a>第2章：mysql数据库面试必备入门基础知识</h2><p>​    <strong>简介：主讲面试时，面试官必问的知识点，主要关于版本号，服务进程，有哪些sql操作语句等</strong></p>
<h3 id="2-1-mysql各个版本的重要性介绍"><a href="#2-1-mysql各个版本的重要性介绍" class="headerlink" title="2.1 mysql各个版本的重要性介绍"></a>2.1 mysql各个版本的重要性介绍</h3><pre><code>**简介：各个版本的区别**
 官网：https://dev.mysql.com/downloads/mysql/</code></pre><ul>
<li>MySQL Community Server 社区版本，开源免费，但不提供官方技术支持。</li>
<li>MySQL Enterprise Edition 企业版本，需付费，购买了之后可以电话支持</li>
<li>MySQL Cluster 集群版，开源免费。可将几个MySQL Server封装成一个Server。</li>
</ul>
<h3 id="2-2-mysql的核心知识之服务管理"><a href="#2-2-mysql的核心知识之服务管理" class="headerlink" title="2.2 mysql的核心知识之服务管理"></a>2.2 mysql的核心知识之服务管理</h3><p>​    <strong>简介：mysql的service服务管理与登录管理</strong></p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看mysql服务进程：ps -ef | grep mysql</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service服务管理：cp -a mysql.server /etc/rc.d/init.d/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动命令：service mysql start</span><br><span class="line">关闭命令：service mysql stop</span><br><span class="line">重新启动命令：service mysql restart</span><br><span class="line">查看状态命令：service mysql status</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录管理： ln -s /usr/local/mysql/bin/*  /bin</span><br><span class="line">登录命令：mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">默认端口号：3306</span><br><span class="line">配置文件：/etc/my.cnf</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-3-mysql的可视化图形界面与命令行操作"><a href="#2-3-mysql的可视化图形界面与命令行操作" class="headerlink" title="2.3 mysql的可视化图形界面与命令行操作"></a>2.3 mysql的可视化图形界面与命令行操作</h3><pre><code>**简介：命令行的登录与图形化界面的登录**</code></pre><ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令行模式：</span><br><span class="line"></span><br><span class="line">	登录命令：mysql -u用户 -p密码</span><br><span class="line"></span><br><span class="line"> 	退出命令：exit;	quit;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">图形化模式：</span><br><span class="line"> 	ip地址或者主机名：120.76.62.13</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-4-mysql的库表深入解析"><a href="#2-4-mysql的库表深入解析" class="headerlink" title="2.4 mysql的库表深入解析"></a>2.4 mysql的库表深入解析</h3><p>​    <strong>简介：mysql数据库的基本概念详解</strong></p>
<ul>
<li><p>什么是库？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">顾名思义就是数据仓库的意思，存储着一定数据结构的数据，一个数据库中可能包含着若干个表，我们可以</span><br><span class="line">通过数据库提供的多种方法来管理数据库里边的数据。本质上mysql数据库是一个关系型数据服务管理系统</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么是表？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们所说的表就是数据表，每一张表是由行和列组成，每记录一条数据，数据表就增加一行。列是由字段名</span><br><span class="line">与字段数据属性组成，我们称之列为字段，每一个字段有着多个属性。例如是否允许为空、长度、类型等等</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库：database</span><br><span class="line">数据表：table</span><br><span class="line">字段（列）：column</span><br><span class="line">行：row</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-5-mysql的sql各类语句精讲"><a href="#2-5-mysql的sql各类语句精讲" class="headerlink" title="2.5 mysql的sql各类语句精讲"></a>2.5 mysql的sql各类语句精讲</h3><p>​    <strong>简介：mysql的操作语句分类</strong></p>
<ul>
<li>操作语句分为四类：</li>
</ul>
<ol>
<li>DDL 数据定义语言 (Data Definition Language)  例如：建库，建表</li>
<li>DML 数据操纵语言(Data Manipulation Language) 例如：对表中的数据进行增删改操作</li>
<li>DQL 数据查询语言(Data Query Language)    例如：对数据进行查询</li>
<li>DCL 数据控制语言(Data Control Language)    例如：对用户的权限进行设置</li>
</ol>
<hr>
<h2 id="第3章：mysql核心知识之DDL数据定义语言"><a href="#第3章：mysql核心知识之DDL数据定义语言" class="headerlink" title="第3章：mysql核心知识之DDL数据定义语言"></a>第3章：mysql核心知识之DDL数据定义语言</h2><p>​    <strong>简介：对DDl数据定义语言进行深入学习</strong></p>
<h3 id="3-1-mysql数据库必备知识之创建、查看以及使用-切换"><a href="#3-1-mysql数据库必备知识之创建、查看以及使用-切换" class="headerlink" title="3.1 mysql数据库必备知识之创建、查看以及使用/切换"></a>3.1 mysql数据库必备知识之创建、查看以及使用/切换</h3><p>​    <strong>简介：细讲数据库的创建使用</strong></p>
<ul>
<li><p>直接创建数据库 db1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database db1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前在哪个库里边</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入库的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use 库名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断是否存在，如果不存在则创建数据库 db2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database if not exists db2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库并指定字符集为 gbk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database db3 default character set gbk;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某个库是什么字符集；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create database XD;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前mysql使用的字符集</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;character%&apos;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-2-mysql创建表之常用数据类型"><a href="#3-2-mysql创建表之常用数据类型" class="headerlink" title="3.2 mysql创建表之常用数据类型"></a>3.2 mysql创建表之常用数据类型</h3><p>​    <strong>简介：细讲常用数据类型</strong></p>
<ul>
<li><p>数据类型是什么？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同的信息类型。有一些数据是要存储为数字的，数字当中有些是要存储为整数、小数、日期型等...</span><br></pre></td></tr></table></figure>
</li>
<li><p>mysql常见数据类型</p>
<pre><code>&lt;1&gt;整数型
     类型      大小      范围（有符号）               范围（无符号unsigned）    用途
     TINYINT   1 字节    (-128，127)                (0，255)                 小整数值
     SMALLINT  2 字节    (-32768，32767)            (0，65535)               大整数值
     MEDIUMINT 3 字节    (-8388608，8388607)        (0，16777215)            大整数值
     INT       4 字节    (-2147483648，2147483647)  (0，4294967295)          大整数值
     BIGINT    8 字节     （）                         (0，2的64次方减1)        极大整数值

&lt;2&gt;浮点型
 FLOAT(m,d）  4 字节    单精度浮点型  备注：m代表总个数，d代表小数位个数
 DOUBLE(m,d） 8 字节    双精度浮点型  备注：m代表总个数，d代表小数位个数

 &lt;3&gt;定点型
 DECIMAL(m,d）    依赖于M和D的值    备注：m代表总个数，d代表小数位个数

 &lt;4&gt;字符串类型
 类型          大小              用途
 CHAR          0-255字节         定长字符串
 VARCHAR       0-65535字节       变长字符串
 TINYTEXT      0-255字节         短文本字符串
 TEXT          0-65535字节       长文本数据
 MEDIUMTEXT    0-16777215字节    中等长度文本数据
 LONGTEXT      0-4294967295字节  极大文本数据

 char的优缺点：存取速度比varchar更快，但是比varchar更占用空间
 varchar的优缺点：比char省空间。但是存取速度没有char快

 &lt;5&gt;时间型
 数据类型    字节数            格式                    备注
 date        3                yyyy-MM-dd              存储日期值
 time        3                HH:mm:ss                存储时分秒
 year        1                yyyy                    存储年
 datetime    8                yyyy-MM-dd HH:mm:ss     存储日期+时间
 timestamp   4                yyyy-MM-dd HH:mm:ss     存储日期+时间，可作时间戳</code></pre></li>
</ul>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test_time (</span><br><span class="line">            date_value date,</span><br><span class="line">            time_value time,</span><br><span class="line">            year_value year,</span><br><span class="line">            datetime_value datetime,</span><br><span class="line">            timestamp_value timestamp</span><br><span class="line">        ) engine=innodb charset=utf8;</span><br></pre></td></tr></table></figure>

<pre><code>insert into test_time values(now(), now(), now(), now(), now());</code></pre></li>
</ul>
<h3 id="3-3-mysql数据表必备知识之创建表"><a href="#3-3-mysql数据表必备知识之创建表" class="headerlink" title="3.3 mysql数据表必备知识之创建表"></a>3.3 mysql数据表必备知识之创建表</h3><p> <strong>简介：讲解表是怎么来创建的，以及常见约束条件举例说明</strong></p>
<ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">                  字段名1 字段类型1 约束条件1 说明1,</span><br><span class="line">                  字段名2 字段类型2 约束条件2 说明2,</span><br><span class="line">                  字段名3 字段类型3 约束条件3 说明3</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 新表名 as select * from 旧表名 where 1=2;(注意：建议这种创建表的方式用于日常测试，因	为可能索引什么的会复制不过来)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 新表名 like 旧表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>约束条件：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment         ----说明解释</span><br><span class="line">not null        ----不为空</span><br><span class="line">default         ----默认值</span><br><span class="line">unsigned        ----无符号（即正数）</span><br><span class="line">auto_increment  ----自增</span><br><span class="line">zerofill        ----自动填充</span><br><span class="line">unique key      ----唯一值</span><br></pre></td></tr></table></figure>

<ul>
<li>创建sql</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">                    id tinyint(5) zerofill auto_increment  not null comment &apos;学生学号&apos;,</span><br><span class="line">                    name varchar(20) default null comment &apos;学生姓名&apos;,</span><br><span class="line">                    age  tinyint  default null comment &apos;学生年龄&apos;,</span><br><span class="line">                    class varchar(20) default null comment &apos;学生班级&apos;,</span><br><span class="line">                    sex char(5) not null comment &apos;学生性别&apos;,</span><br><span class="line">                    unique key (id)</span><br><span class="line">                    )engine=innodb charset=utf8;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE student (</span><br><span class="line">                    id tinyint(5)  auto_increment  default null comment &apos;学生学号&apos;,</span><br><span class="line">                    name varchar(20) default null comment &apos;学生姓名&apos;,</span><br><span class="line">                    age  tinyint  default null comment &apos;学生年龄&apos;,</span><br><span class="line">                    class varchar(20) default null comment &apos;学生班级&apos;,</span><br><span class="line">                    sex char(5) not null comment &apos;学生性别&apos;,</span><br><span class="line">                    unique key (id)</span><br><span class="line">                    )engine=innodb charset=utf8;;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-mysql数据表必备知识之查看"><a href="#3-4-mysql数据表必备知识之查看" class="headerlink" title="3.4 mysql数据表必备知识之查看"></a>3.4 mysql数据表必备知识之查看</h3><p><strong>简介：如何查看表的基本结构信息</strong></p>
<ul>
<li>查看数据库中的所有表：show tables；</li>
<li>查看表结构：desc 表名;</li>
<li>查看创建表的sql语句：show create table 表名;</li>
<li>\G :有结束sql语句的作用，还有把显示的数据纵向旋转90度</li>
<li>\g :有结束sql语句的作用</li>
</ul>
<h3 id="3-5-mysql数据表必备知识之表结构维护与删除"><a href="#3-5-mysql数据表必备知识之表结构维护与删除" class="headerlink" title="3.5 mysql数据表必备知识之表结构维护与删除"></a>3.5 mysql数据表必备知识之表结构维护与删除</h3><p><strong>简介：细讲核心知识表结构的修改</strong></p>
<ul>
<li>修改表名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rename table 旧表名 to 新表名;</span><br><span class="line">rename table student to user;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给表添加一列：alter table 表名 add 列名 类型;</span><br><span class="line">alter table user add addr varchar(50);</span><br><span class="line"></span><br><span class="line">alter table add 列名 类型 comment &apos;说明&apos;;</span><br><span class="line">alter table user add famliy varchar(50) comment &apos;学生父母&apos;;</span><br><span class="line"></span><br><span class="line">给表最前面添加一列：alter table 表名 add 列名 类型 first;</span><br><span class="line">alter table user add job varchar(10) first;</span><br><span class="line"></span><br><span class="line">给表某个字段后添加一列：alter table 表名 add 列名 类型 after 字段名;</span><br><span class="line">alter table user add servnumber int(11)  after id;</span><br><span class="line"></span><br><span class="line">注意：没有给表某个字段前添加一列的说法。</span><br></pre></td></tr></table></figure>

<ul>
<li>修改列类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 modify 列名 新类型;</span><br><span class="line">alter table user modify servnumber varchar(20);</span><br></pre></td></tr></table></figure>

<ul>
<li>修改列名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧列名 新列名 类型;</span><br><span class="line">alter table user change servnumber telephone varchar(20);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 列名;</span><br><span class="line">alter table user drop famliy;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改字符集</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 character set 字符集;</span><br><span class="line">alter table user character  set GBK;</span><br></pre></td></tr></table></figure>

<ul>
<li>mysql表的删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table 表名；</span><br><span class="line">drop table user;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看表是否存在，若存在则删除表：drop table if exists 表名;</span><br><span class="line">drop table  if exists teacher;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第4章：mysql核心知识之DML数据操纵语言"><a href="#第4章：mysql核心知识之DML数据操纵语言" class="headerlink" title="第4章：mysql核心知识之DML数据操纵语言"></a>第4章：mysql核心知识之DML数据操纵语言</h2><p>​    <strong>简介：细讲核心知识对数据表的数据进行增删改</strong></p>
<h3 id="4-1-mysql深入剖析表数据新增"><a href="#4-1-mysql深入剖析表数据新增" class="headerlink" title="4.1 mysql深入剖析表数据新增"></a>4.1 mysql深入剖析表数据新增</h3><p>​    <strong>简介：讲解表数据新增的多种例子</strong></p>
<ul>
<li>普通的插入表数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名（字段名） values（字段对应值）;</span><br><span class="line"></span><br><span class="line">insert into employee (empno,ename,job,mgr,hiredate,sal,deptnu) values (&apos;1000&apos;,&apos;小明&apos;,&apos;经理&apos;,&apos;10001&apos;,&apos;2019-03-03&apos;,&apos;12345.23&apos;,&apos;10&apos;);</span><br><span class="line"></span><br><span class="line">insert into 表名 values（所有字段对应值）;</span><br><span class="line">insert into employee  values (&apos;1001&apos;,&apos;小明&apos;,&apos;经理&apos;,&apos;10001&apos;,&apos;2019-03-03&apos;,&apos;12345.23&apos;,&apos;10&apos;);</span><br></pre></td></tr></table></figure>

<ul>
<li>蠕虫复制（将一张表的数据复制到另一张表中）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名1 select * from 表名2;</span><br><span class="line"></span><br><span class="line">insert into 表名1（字段名1，字段名2） select 字段名1，字段名2 from 表名2;</span><br><span class="line"></span><br><span class="line">insert into emp (empno,ename) select empno,ename from employee;</span><br></pre></td></tr></table></figure>

<ul>
<li>建表复制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table 表名1 as select 字段名1，字段名2 from 表名2;</span><br><span class="line"></span><br><span class="line">create table emp as select empno ,ename from employee;</span><br></pre></td></tr></table></figure>

<ul>
<li>一次性插入多个数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into 表名  (字段名) values (对应值1),(对应值2),(对应值3);</span><br></pre></td></tr></table></figure>

<ul>
<li>创建sql：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">某个公司的员工表</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">    empno       INT  PRIMARY KEY comment &apos;雇员编号&apos;,</span><br><span class="line">    ename       VARCHAR(20) comment &apos;雇员姓名&apos;,</span><br><span class="line">    job         VARCHAR(20) comment &apos;雇员职位&apos;,</span><br><span class="line">    mgr         INT comment &apos;雇员上级编号&apos;,</span><br><span class="line">    hiredate    DATE comment &apos;雇佣日期&apos;,</span><br><span class="line">    sal         DECIMAL(7,2) comment &apos;薪资&apos;,</span><br><span class="line">    deptnu      INT comment &apos;部门编号&apos;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="4-2-mysql深入剖析表数据的修改以及删除"><a href="#4-2-mysql深入剖析表数据的修改以及删除" class="headerlink" title="4.2 mysql深入剖析表数据的修改以及删除"></a>4.2 mysql深入剖析表数据的修改以及删除</h3><p><strong>简介：讲解如何对表数据进行修改删除以及注意事项</strong></p>
<ul>
<li><p>修改（更新）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段名1=值1 where 字段名=值;</span><br><span class="line"></span><br><span class="line">update 表名 set 字段名1=值1,字段名2=值2 where 字段名=值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from 表名 where 字段名=值;</span><br><span class="line"></span><br><span class="line"> truncate table 表名;</span><br><span class="line"> delete from 表名;</span><br><span class="line"> drop table 表名;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">面试时：面试官问在删改数据之前，你会怎么做？</span><br><span class="line">答案：会对数据进行备份操作，以防万一，可以进行数据回退</span><br><span class="line"></span><br><span class="line">面试时：面试官会问，delete与truncate与drop 这三种删除数据的共同点都是删除数据，他们的不同点是什么?</span><br><span class="line">delele 会把删除的操作记录给记录起来，以便数据回退，不会释放空间，而且不会删除定义。</span><br><span class="line">truncate不会记录删除操作，会把表占用的空间恢复到最初，不会删除定义</span><br><span class="line">drop会删除整张表，释放表占用的空间。</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除速度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop &gt; truncate &gt; delete</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-3-mysql核心知识之中文乱码问题"><a href="#4-3-mysql核心知识之中文乱码问题" class="headerlink" title="4.3 mysql核心知识之中文乱码问题"></a>4.3 mysql核心知识之中文乱码问题</h3><p><strong>简介：详细讲解汉字显示乱码问题</strong></p>
<ul>
<li>查看当前mysql使用的字符集：show variables like ‘character%’;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;character%&apos;;</span><br><span class="line">+--------------------------+----------------------------------+</span><br><span class="line">| Variable_name            | Value                            |</span><br><span class="line">+--------------------------+----------------------------------+</span><br><span class="line">| character_set_client     | utf8                             |</span><br><span class="line">| character_set_connection | utf8                             |</span><br><span class="line">| character_set_database   | utf8                             |</span><br><span class="line">| character_set_filesystem | binary                           |</span><br><span class="line">| character_set_results    | utf8                             |</span><br><span class="line">| character_set_server     | utf8                             |</span><br><span class="line">| character_set_system     | utf8                             |</span><br><span class="line">| character_sets_dir       | /usr/local/mysql/share/charsets/ |</span><br><span class="line">+--------------------------+----------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li><p>character_set_client：客户端请求数据的字符集</p>
</li>
<li><p>character_set_connection：客户端与服务器连接的字符集</p>
</li>
<li><p>character_set_database：数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将默认使用配置上的字符集</p>
</li>
<li><p>character_set_results：返回给客户端的字符集(从数据库读取到的数据是什么编码的)</p>
</li>
<li><p>character_set_server：为服务器安装时指定的默认字符集设定。</p>
</li>
<li><p>character_set_system：系统字符集(修改不了的，就是utf8)</p>
</li>
<li><p>character_sets_dir：mysql字符集文件的保存路径</p>
</li>
<li><p>临时：set names gbk;</p>
</li>
</ul>
<ul>
<li><p>永久：修改配置文件my.cnf里边的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=gbk</span><br><span class="line">作用于外部的显示</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character_set_server=gbk</span><br><span class="line">作用于内部，会作用于创建库表时默认字符集</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改库的字符集编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter database xiaoxiao default character set gbk;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表的字符集编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table employee default character set utf8;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="第5章：mysql核心知识之DQL数据查询语言与项目高级查询实战"><a href="#第5章：mysql核心知识之DQL数据查询语言与项目高级查询实战" class="headerlink" title="第5章：mysql核心知识之DQL数据查询语言与项目高级查询实战"></a>第5章：mysql核心知识之DQL数据查询语言与项目高级查询实战</h2><p>​    <strong>简介：细讲对数据表中的数据进行各种查询，以及项目实战查询</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*创建部门表*/</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">    deptnu      INT  PRIMARY KEY comment &apos;部门编号&apos;,</span><br><span class="line">    dname       VARCHAR(50) comment &apos;部门名称&apos;,</span><br><span class="line">    addr        VARCHAR(50) comment &apos;部门地址&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">某个公司的员工表</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line">    empno       INT  PRIMARY KEY comment &apos;雇员编号&apos;,</span><br><span class="line">    ename       VARCHAR(50) comment &apos;雇员姓名&apos;,</span><br><span class="line">    job         VARCHAR(50) comment &apos;雇员职位&apos;,</span><br><span class="line">    mgr         INT comment &apos;雇员上级编号&apos;,</span><br><span class="line">    hiredate    DATE comment &apos;雇佣日期&apos;,</span><br><span class="line">    sal         DECIMAL(7,2) comment &apos;薪资&apos;,</span><br><span class="line">    deptnu      INT comment &apos;部门编号&apos;</span><br><span class="line">)ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">/*创建工资等级表*/</span><br><span class="line">CREATE TABLE salgrade(</span><br><span class="line">    grade       INT  PRIMARY KEY comment &apos;等级&apos;,</span><br><span class="line">    lowsal      INT comment &apos;最低薪资&apos;,</span><br><span class="line">    higsal      INT comment &apos;最高薪资&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*插入dept表数据*/</span><br><span class="line">INSERT INTO dept VALUES (10, &apos;研发部&apos;, &apos;北京&apos;);</span><br><span class="line">INSERT INTO dept VALUES (20, &apos;工程部&apos;, &apos;上海&apos;);</span><br><span class="line">INSERT INTO dept VALUES (30, &apos;销售部&apos;, &apos;广州&apos;);</span><br><span class="line">INSERT INTO dept VALUES (40, &apos;财务部&apos;, &apos;深圳&apos;);</span><br><span class="line"></span><br><span class="line">/*插入emp表数据*/</span><br><span class="line">INSERT INTO employee VALUES (1009, &apos;唐僧&apos;, &apos;董事长&apos;, NULL, &apos;2010-11-17&apos;, 50000,  10);</span><br><span class="line">INSERT INTO employee VALUES (1004, &apos;猪八戒&apos;, &apos;经理&apos;, 1009, &apos;2001-04-02&apos;, 29750, 20);</span><br><span class="line">INSERT INTO employee VALUES (1006, &apos;猴子&apos;, &apos;经理&apos;, 1009, &apos;2011-05-01&apos;, 28500, 30);</span><br><span class="line">INSERT INTO employee VALUES (1007, &apos;张飞&apos;, &apos;经理&apos;, 1009, &apos;2011-09-01&apos;, 24500,10);</span><br><span class="line">INSERT INTO employee VALUES (1008, &apos;诸葛亮&apos;, &apos;分析师&apos;, 1004, &apos;2017-04-19&apos;, 30000, 20);</span><br><span class="line">INSERT INTO employee VALUES (1013, &apos;林俊杰&apos;, &apos;分析师&apos;, 1004, &apos;2011-12-03&apos;, 30000, 20);</span><br><span class="line">INSERT INTO employee VALUES (1002, &apos;牛魔王&apos;, &apos;销售员&apos;, 1006, &apos;2018-02-20&apos;, 16000, 30);</span><br><span class="line">INSERT INTO employee VALUES (1003, &apos;程咬金&apos;, &apos;销售员&apos;, 1006, &apos;2017-02-22&apos;, 12500, 30);</span><br><span class="line">INSERT INTO employee VALUES (1005, &apos;后裔&apos;, &apos;销售员&apos;, 1006, &apos;2011-09-28&apos;, 12500, 30);</span><br><span class="line">INSERT INTO employee VALUES (1010, &apos;韩信&apos;, &apos;销售员&apos;, 1006, &apos;2018-09-08&apos;, 15000,30);</span><br><span class="line">INSERT INTO employee VALUES (1012, &apos;安琪拉&apos;, &apos;文员&apos;, 1006, &apos;2011-12-03&apos;, 9500,  30);</span><br><span class="line">INSERT INTO employee VALUES (1014, &apos;甄姬&apos;, &apos;文员&apos;, 1007, &apos;2019-01-23&apos;, 7500, 10);</span><br><span class="line">INSERT INTO employee VALUES (1011, &apos;妲己&apos;, &apos;文员&apos;, 1008, &apos;2018-05-23&apos;, 11000, 20);</span><br><span class="line">INSERT INTO employee VALUES (1001, &apos;小乔&apos;, &apos;文员&apos;, 1013, &apos;2018-12-17&apos;, 8000, 20);</span><br><span class="line"></span><br><span class="line">/*插入salgrade表数据*/</span><br><span class="line">INSERT INTO salgrade VALUES (1, 7000, 12000);</span><br><span class="line">INSERT INTO salgrade VALUES (2, 12010, 14000);</span><br><span class="line">INSERT INTO salgrade VALUES (3, 14010, 20000);</span><br><span class="line">INSERT INTO salgrade VALUES (4, 20010, 30000);</span><br><span class="line">INSERT INTO salgrade VALUES (5, 30010, 99990);</span><br></pre></td></tr></table></figure>

<h3 id="5-1-mysql查询子句之一where条件查询"><a href="#5-1-mysql查询子句之一where条件查询" class="headerlink" title="5.1 mysql查询子句之一where条件查询"></a>5.1 mysql查询子句之一where条件查询</h3><p>   <strong>简介：详解where条件下的各种查询</strong></p>
<ul>
<li><p>简单查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee;</span><br><span class="line">select empno,ename,job as ename_job from employee;</span><br></pre></td></tr></table></figure>
</li>
<li><p>精确条件查询   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where ename=&apos;后裔&apos;;</span><br><span class="line">select * from employee where sal != 50000;</span><br><span class="line">select * from employee where sal &lt;&gt; 50000;</span><br><span class="line">select * from employee where sal &gt; 10000;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模糊条件查询   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%aracter%&apos;;</span><br><span class="line">select * from employee  where ename like &apos;林%&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围查询  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where sal between 10000 and 30000;</span><br><span class="line">select * from employee where hiredate between &apos;2011-01-01&apos; and &apos;2017-12-1&apos;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>离散查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from employee where ename in (&apos;猴子&apos;,&apos;林俊杰&apos;,&apos;小红&apos;,&apos;小胡&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>清除重复值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select distinct(job) from employee;</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计查询（聚合函数）:                  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count(code)或者count(*)</span><br><span class="line"> select count(*) from employee;</span><br><span class="line"> select count(ename) from employee;</span><br><span class="line"></span><br><span class="line">sum()  计算总和</span><br><span class="line"> select sum(sal) from employee;</span><br><span class="line"></span><br><span class="line">max()	计算最大值</span><br><span class="line"> select * from employee where sal= (select  max(sal) from employee);</span><br><span class="line"></span><br><span class="line">avg()   计算平均值</span><br><span class="line"> select avg(sal) from employee;</span><br><span class="line"></span><br><span class="line">min()   计算最低值</span><br><span class="line"> select * from employee where sal= (select  min(sal) from employee);</span><br><span class="line"></span><br><span class="line">concat函数： 起到连接作用</span><br><span class="line"> select concat(ename,&apos; 是 &apos;,job) as aaaa from employee;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-2-mysql查询子句之二group-by分组查询（分组）"><a href="#5-2-mysql查询子句之二group-by分组查询（分组）" class="headerlink" title="5.2 mysql查询子句之二group by分组查询（分组）"></a>5.2 mysql查询子句之二group by分组查询（分组）</h3><p>​    <strong>简介：详解group by的用法以及应用场景</strong></p>
<ul>
<li>作用：把行 按 字段 分组</li>
<li>语法：group by 列1，列2….列N</li>
<li>适用场合：常用于统计场合，一般和聚合函数连用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">     select deptnu,count(*) from employee group by deptnu;</span><br><span class="line">     select deptnu,job,count(*) from employee group by deptnu,job;</span><br><span class="line">     select job,count(*) from employee group by job;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-mysql查询子句之三having条件查询（筛选）"><a href="#5-3-mysql查询子句之三having条件查询（筛选）" class="headerlink" title="5.3 mysql查询子句之三having条件查询（筛选）"></a>5.3 mysql查询子句之三having条件查询（筛选）</h3><p>​    <strong>简介：详解having的用法以及应用场景</strong></p>
<ul>
<li><p>​    作用：对查询的结果进行筛选操作</p>
</li>
<li><p>​    语法：having 条件 或者 having 聚合函数 条件</p>
</li>
<li><p>​    适用场合：一般跟在group by之后</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">    select job,count(*) from employee group by job having job =&apos;文员&apos;;</span><br><span class="line">    select  deptnu,job,count(*) from employee group by deptnu,job having count(*)&gt;=2;</span><br><span class="line">    select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;=2;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-mysql查询子句之四order-by排序查询（排序）"><a href="#5-4-mysql查询子句之四order-by排序查询（排序）" class="headerlink" title="5.4 mysql查询子句之四order by排序查询（排序）"></a>5.4 mysql查询子句之四order by排序查询（排序）</h3><p>​    <strong>简介：详解order by的用法以及应用场景</strong></p>
<ul>
<li><p>作用：对查询的结果进行排序操作</p>
</li>
<li><p>语法：order by 字段1,字段2 …..</p>
</li>
<li><p>适用场合：一般用在查询结果的排序</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">     select * from employee order by sal;</span><br><span class="line">     select * from employee order by hiredate;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;=2 order by deptnu desc;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;=2 order by deptnu asc;</span><br><span class="line">     select  deptnu,job,count(*) as 总数 from employee group by deptnu,job having 总数&gt;=2 order by deptnu;</span><br><span class="line"></span><br><span class="line">     顺序：where ---- group by ----- having ------ order by</span><br></pre></td></tr></table></figure>

<h3 id="5-5-mysql查询子句之五limit限制查询（限制）"><a href="#5-5-mysql查询子句之五limit限制查询（限制）" class="headerlink" title="5.5 mysql查询子句之五limit限制查询（限制）"></a>5.5 mysql查询子句之五limit限制查询（限制）</h3><p>​    <strong>简介：详解limit的用法以及应用场景</strong></p>
<ul>
<li>作用：对查询结果起到限制条数的作用</li>
<li>语法：limit n，m   n:代表起始条数值，不写默认为0；m代表：取出的条数</li>
<li>适用场合：数据量过多时，可以起到限制作用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">    select * from XD.employee limit 4,5;</span><br></pre></td></tr></table></figure>

<h3 id="5-6-mysql查询之exists型子查询"><a href="#5-6-mysql查询之exists型子查询" class="headerlink" title="5.6 mysql查询之exists型子查询"></a>5.6 mysql查询之exists型子查询</h3><p> <strong>简介：详解exists的用法</strong></p>
<ul>
<li><p>exists型子查询后面是一个受限的select查询语句</p>
</li>
<li><p>exists子查询，如果exists后的内层查询能查出数据，则返回 TRUE 表示存在；为空则返回 FLASE则不存在。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分为俩种：exists跟 not exists</span><br><span class="line"></span><br><span class="line">select 1 from employee where 1=1;</span><br><span class="line">select * from 表名 a where exists (select 1 from 表名2 where 条件);</span><br><span class="line"></span><br><span class="line">eg:查询出公司有员工的部门的详细信息</span><br><span class="line">select * from dept a where exists (select 1 from employee b where a.deptnu=b.deptnu);</span><br><span class="line">select * from dept a where not exists (select 1 from employee b where a.deptnu=b.deptnu);</span><br></pre></td></tr></table></figure>

<h3 id="5-7-mysql查询之左连接查询与右连接查询"><a href="#5-7-mysql查询之左连接查询与右连接查询" class="headerlink" title="5.7 mysql查询之左连接查询与右连接查询"></a>5.7 mysql查询之左连接查询与右连接查询</h3><p><strong>简介：详解左右连接的用法以及应用场景</strong></p>
<ul>
<li><p>左连接称之为左外连接<br>右连接称之为右外连接<br>这俩个连接都是属于外连接</p>
</li>
<li><p>左连接关键字：left join 表名 on 条件 / left outer 表名 join on 条件<br>右连接关键字：right join 表名 on 条件/ right outer 表名 join on 条件</p>
</li>
<li><p>左连接说明： left join 是left outer join的简写，左(外)连接，左表(a_table)的记录将会全部表示出来，<br>而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。</p>
</li>
<li><p>右连接说明：right join是right outer join的简写，与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:列出部门名称和这些部门的员工信息，同时列出那些没有的员工的部门</span><br><span class="line">        dept，employee</span><br><span class="line">        select a.dname,b.* from dept a  left join employee b on a.deptnu=b.deptnu;</span><br><span class="line">        select b.dname,a.* from employee a  right join  dept b on b.deptnu=a.deptnu;</span><br></pre></td></tr></table></figure>

<h3 id="5-8-mysql查询之内连接查询与联合查询"><a href="#5-8-mysql查询之内连接查询与联合查询" class="headerlink" title="5.8 mysql查询之内连接查询与联合查询"></a>5.8 mysql查询之内连接查询与联合查询</h3><p><strong>简介：详解内连接与联合查询的用法以及应用场景</strong></p>
<ul>
<li>内连接：获取两个表中字段匹配关系的记录</li>
</ul>
<p>-<br>    主要语法：INNER JOIN 表名 ON 条件;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:想查出员工张飞的所在部门的地址</span><br><span class="line">    select a.addr  from dept a inner join employee b on a.deptnu=b.deptnu and b.ename=&apos;张飞&apos;;</span><br><span class="line">    select a.addr from dept a,employee b where a.deptnu=b.deptnu and b.ename=&apos;张飞&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>联合查询：就是把多个查询语句的查询结果结合在一起</li>
</ul>
<p>   主要语法1：… UNION … （去除重复）<br>   主要语法2：… UNION ALL …（不去重复）</p>
<ul>
<li><p>union查询的注意事项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(1)两个select语句的查询结果的“字段数”必须一致；</span><br><span class="line"></span><br><span class="line">(2)通常，也应该让两个查询语句的字段类型具有一致性；</span><br><span class="line"></span><br><span class="line">(3)也可以联合更多的查询结果；</span><br><span class="line"></span><br><span class="line">(4)用到order by排序时，需要加上limit（加上最大条数就行），需要对子句用括号括起来</span><br><span class="line"></span><br><span class="line">eg:对销售员的工资从低到高排序，而文员的工资从高到低排序</span><br><span class="line">    (select * from employee a where a.job = &apos;销售员&apos;  order by a.sal limit 999999 ) union  (select * from employee b where b.job = &apos;文员&apos; order by b.sal desc limit 999999);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="5-9-mysql查询之项目高级查询实战-一"><a href="#5-9-mysql查询之项目高级查询实战-一" class="headerlink" title="5.9 mysql查询之项目高级查询实战(一)"></a>5.9 mysql查询之项目高级查询实战(一)</h3><p><strong>简介：高级查询实战</strong></p>
<ul>
<li>查出至少有一个员工的部门。显示部门编号、部门名称、部门位置、部门人数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表： employee dept</span><br><span class="line">语句：select deptnu,count(*) from employee group by deptnu</span><br><span class="line">语句：select a.deptnu,a.dname,a.addr, b.zongshu from dept a,(select deptnu,count(*) as zongshu from employee group by deptnu) b where a.deptnu=b.deptnu;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出薪金比安琪拉高的所有员工。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee</span><br><span class="line">语句：select * from  employee where sal &gt; (select sal from employee where ename=&apos;安琪拉&apos;);</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有员工的姓名及其直接上级的姓名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee</span><br><span class="line">语句：select a.ename,ifnull(b.ename,&apos;BOSS&apos;) as leader from employee a left join employee b on a.mgr=b.empno;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出受雇日期早于直接上级的所有员工的编号、姓名、部门名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept</span><br><span class="line">条件：a.hiredate &lt; b.hiredate</span><br><span class="line">语句：select a.empno,a.ename,c.dname from employee a left join employee b on a.mgr=b.empno left join dept c on a.deptnu=c.deptnu where a.hiredate &lt; b.hiredate;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出部门名称和这些部门的员工信息，同时列出那些没有员工的部门。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：dept employee</span><br><span class="line">语句：select a.dname,b.* from dept a left join employee b on a.deptnu=b.deptnu;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有文员的姓名及其部门名称，所在部门的总人数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept</span><br><span class="line">条件：job=&apos;文员&apos;</span><br><span class="line">语句：select deptnu,count(*) as zongshu from employee group by deptnu;</span><br><span class="line">语句：select b.ename,a.dname,b.job,c.zongshu from dept a ,employee b ,(select deptnu,count(*) as zongshu from employee group by deptnu) c where a.deptnu=b.deptnu and b.job=&apos;文员&apos; and b.deptnu=c.deptnu;</span><br></pre></td></tr></table></figure>

<h3 id="5-10-mysql查询之项目高级查询实战-二"><a href="#5-10-mysql查询之项目高级查询实战-二" class="headerlink" title="5.10 mysql查询之项目高级查询实战(二)"></a>5.10 mysql查询之项目高级查询实战(二)</h3><p><strong>简介：高级查询实战续</strong></p>
<ul>
<li>列出最低薪金大于15000的各种工作及从事此工作的员工人数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee</span><br><span class="line">条件：min(sal) &gt; 15000</span><br><span class="line">语句：select job,count(*) from employee group by job having   min(sal) &gt; 15000;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出在销售部工作的员工的姓名，假定不知道销售部的部门编号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept</span><br><span class="line">select  ename  from employee where deptnu=(select deptnu from dept where dname=&apos;销售部&apos;);</span><br></pre></td></tr></table></figure>

<ul>
<li>列出与诸葛亮从事相同工作的所有员工及部门名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept</span><br><span class="line">语句：select a.ename,b.dname from employee a,dept b where a.deptnu=b.deptnu and a.job=                (select job from employee where ename=&apos;诸葛亮&apos;);</span><br><span class="line">语句：select a.ename,b.dname from employee a left join dept b on a.deptnu=b.deptnu where               a.job=(select job from employee where ename=&apos;诸葛亮&apos;);</span><br></pre></td></tr></table></figure>

<ul>
<li>列出薪金比  在部门30工作的员工的薪金  还高的员工姓名和薪金、部门名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept</span><br><span class="line">语句：select a.ename,a.sal,b.dname from employee a ,dept b where a.deptnu=b.deptnu and sal &gt;          (select max(sal) from employee where deptnu=30);</span><br></pre></td></tr></table></figure>

<ul>
<li>列出每个部门的员工数量、平均工资。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee</span><br><span class="line">语句：select deptnu , count(*) ,avg (sal) from employee  group by deptnu;</span><br></pre></td></tr></table></figure>

<ul>
<li>列出薪金高于公司平均薪金的所有员工信息，所在部门名称，上级领导，工资等级。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及表：employee dept salgrade</span><br><span class="line">条件：select avg(sal) from employee</span><br><span class="line">语句：elect a.*,c.dname,b.ename,d.grade from employee a,employee b,dept c ,salgrade d where           a.mgr=b.empno and a.deptnu =c.deptnu and a.sal &gt; (select avg(sal) from employee)  and           a.sal  between d.lowsal and d.higsal;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第6章：mysql核心知识之DCL数据控制语言（对用户权限的设置）"><a href="#第6章：mysql核心知识之DCL数据控制语言（对用户权限的设置）" class="headerlink" title="第6章：mysql核心知识之DCL数据控制语言（对用户权限的设置）"></a>第6章：mysql核心知识之DCL数据控制语言（对用户权限的设置）</h2><p>​    <strong>简介：精讲数据控制语言如何限制用户的各种权限</strong></p>
<ul>
<li><p>什么是DCL数据控制语言？</p>
<p>数据控制语言（DCL：Data Control Language）是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、DENY、REVOKE等语句</p>
</li>
</ul>
<h3 id="6-1-mysql限制root用户指定ip登录"><a href="#6-1-mysql限制root用户指定ip登录" class="headerlink" title="6.1 mysql限制root用户指定ip登录"></a>6.1 mysql限制root用户指定ip登录</h3><p><strong>简介：详解如何从安全角度出发限制root用户指定ip登录</strong></p>
<ul>
<li>查看root用户可以在哪台机器登录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select user,host from mysql.user where user=&apos;root&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改mysql库里边的user表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set host=&apos;localhost&apos; where user=&apos;root&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新权限</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-mysql必备知识之用户密码"><a href="#6-2-mysql必备知识之用户密码" class="headerlink" title="6.2 mysql必备知识之用户密码"></a>6.2 mysql必备知识之用户密码</h3><p><strong>简介：详解忘记密码以及如何修改用户密码</strong></p>
<ul>
<li>修改用户密码分三种方法：</li>
</ul>
<ol>
<li><p>​    第一种：set password for 用户@ip = password(‘密码’);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set password for root@localhost = password(&apos;root&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>​    第二种：mysqladmin -u用户 -p旧密码 password 新密码;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqladmin -urootmysqladmin -uroot -proot password;</span><br></pre></td></tr></table></figure>
</li>
<li><p>​    第三种：update mysql.user set authentication_string=password(‘密码’) where user=’用户’ and host=’ip’;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(&apos;root&apos;) where user=&apos;root&apos; and host=&apos;localhost&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>忘记密码:</li>
</ul>
<ol>
<li>​    第一步：修改配置文件my.cnf (默认在/etc/my.cnf)，在[mysqld]下面加上 skip-grant-tables （跳过权限的意思）</li>
<li>​    第二步：重启mysql服务</li>
<li>​    第三步：mysql -uroot -p 无需密码登录进入</li>
<li>​    第四步：修改密码</li>
</ol>
<h3 id="6-3-mysql实战系列之创建新用户并限制ip网段登录"><a href="#6-3-mysql实战系列之创建新用户并限制ip网段登录" class="headerlink" title="6.3 mysql实战系列之创建新用户并限制ip网段登录"></a>6.3 mysql实战系列之创建新用户并限制ip网段登录</h3><p> <strong>简介：讲解如何创建新用户与删除用户并限制ip登录</strong></p>
<ul>
<li>创建用户的语法：create user ‘username’@’host’ identified by ‘password’;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">username：你将创建的用户名</span><br><span class="line"></span><br><span class="line">host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机	登陆，可以使用通配符%</span><br><span class="line"></span><br><span class="line">password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</span><br></pre></td></tr></table></figure>

<ul>
<li>创建用户语法：</li>
</ul>
<p>​    创建一个pig用户，并指定登录密码：123456，可以在任何一台远程主机都可以登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &apos;pig&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br></pre></td></tr></table></figure>

<p>​    创建一个pig用户，并指定登录密码：为空，指定在120网段的机器登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create user &apos;pig&apos;@&apos;120.%.%.%&apos; identified by &apos;&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看权限：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from mysql.user where user=&apos;pig&apos;\G</span><br><span class="line"> mysql&gt; show grants for &apos;pig&apos;@&apos;%&apos;;</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> | Grants for pig@%                |</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> | GRANT USAGE ON *.* TO &apos;pig&apos;@&apos;%&apos; |</span><br><span class="line"> +---------------------------------+</span><br><span class="line"> USAGE：无权限的意思</span><br><span class="line"> mysql&gt; show grants for &apos;root&apos;@&apos;localhost&apos;;</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> | Grants for root@localhost                                           |</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> | GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;localhost&apos; WITH GRANT OPTION |</span><br><span class="line"> +---------------------------------------------------------------------+</span><br><span class="line"> WITH GRANT OPTION:表示这个用户拥有grant权限，即可以对其他用户授权</span><br></pre></td></tr></table></figure>

<ul>
<li>删除用户语法：drop user ‘username’@’host’;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop user &apos;pig&apos;@&apos;%&apos;;</span><br><span class="line">delete from mysql.user where user=&apos;pig&apos;;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-mysql实战系列之库表权限授权与回收"><a href="#6-4-mysql实战系列之库表权限授权与回收" class="headerlink" title="6.4 mysql实战系列之库表权限授权与回收"></a>6.4 mysql实战系列之库表权限授权与回收</h3><p><strong>简介：讲解如何限制用户对库表的增删改查权限</strong></p>
<ul>
<li>授权语法：grant 权限1,权限2….. on 数据库对象 to ‘用户’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grant 权限1,权限2..... on 数据库对象 to &apos;用户&apos;@&apos;host&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>all privileges:代表所有权限</p>
</li>
<li><p><em>.</em>     :代表所有库所有表</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对现有用户进行授权：对现有用户pig授予所有库所有表所有权限。</span><br><span class="line">grant all privileges on *.*  to &apos;pig&apos;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对没有的用户进行授权：创建一个新用户dog授予XD库的所有权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant all privileges on XD.* to &apos;dog&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对没有的用户进行授权：创建一个新用户cat授予XD库的employee表 查与修改权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant select,update on XD.employee to &apos;cat&apos;@&apos;%&apos; identified by &apos;123456&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对没有的用户进行授权：对用户cat授予XD库的employee表insert 权限，登录密码123456，任何一台主机登录</span><br><span class="line">grant insert on XD.employee to &apos;cat&apos;@&apos;%&apos; identified by &apos;123456&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>回收语法：revoke 权限1,权限2…..  on 数据库对象 from ‘用户‘@’host’;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回收pig用户的所有权限（注意：并没有回收它的登录权限）</span><br><span class="line">revoke all privileges on *.*  from &apos;pig&apos; @ &apos;%&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回收pig用户的所有权限（并回收它的登录权限）</span><br><span class="line">delete from mysql.user where user=&apos;pig&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">回收cat用户对XD库的employee的查与修改权限</span><br><span class="line">revoke select,update on XD.employee from &apos;cat&apos;@&apos;%&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第7章：mysql的核心知识之事务实战，视图，触发器，以及存储过程"><a href="#第7章：mysql的核心知识之事务实战，视图，触发器，以及存储过程" class="headerlink" title="第7章：mysql的核心知识之事务实战，视图，触发器，以及存储过程"></a>第7章：mysql的核心知识之事务实战，视图，触发器，以及存储过程</h2><p>​    <strong>简介：主要分5节课来详细讲解事务以及视图优缺点，触发器以及存储过程介绍</strong></p>
<h3 id="7-1-mysql-必备核心知识之事务的详细解析"><a href="#7-1-mysql-必备核心知识之事务的详细解析" class="headerlink" title="7.1 mysql 必备核心知识之事务的详细解析"></a>7.1 mysql 必备核心知识之事务的详细解析</h3><p>​    <strong>简介：深入详解事务</strong></p>
<ul>
<li>什么是事务?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答：数据库事务通常指对数据库进行读或写的一个操作过程。有两个目的，第一个是为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法；第二个是当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>事务的特性（ACID）：</p>
</li>
<li><input disabled type="checkbox"> <p>原子性(Atomicity)：事务必须是原子工作单元，一个事务中的所有语句，应该做到：要么全做，要么一个都不做；</p>
</li>
<li><input disabled type="checkbox"> <p>一致性(Consistency):让数据保持逻辑上的“合理性”，比如：小明给小红打10000块钱，既要让小明的账户减少10000，又要让小红的账户上增加10000块钱；</p>
</li>
<li><input disabled type="checkbox"> <p>隔离性(Isolation)：如果多个事务同时并发执行，但每个事务就像各自独立执行一样。</p>
</li>
<li><input disabled type="checkbox"> <p>持久性(Durability)：一个事务执行成功，则对数据来说应该是一个明确的硬盘数据更改（而不仅仅是内存中的变化）。</p>
</li>
<li><p>你要使用事务的话，表的引擎要为innodb引擎</p>
</li>
</ul>
<h3 id="7-2-mysql-必备核心知识之事务实战"><a href="#7-2-mysql-必备核心知识之事务实战" class="headerlink" title="7.2 mysql 必备核心知识之事务实战"></a>7.2 mysql 必备核心知识之事务实战</h3><p><strong>简介：主要讲解事务的开启以及事务实战，深入了解什么是事务</strong></p>
<ul>
<li><p>事务的开启与提交：</p>
</li>
<li><input disabled type="checkbox"> <p>事务的开启：begin; start transaction;</p>
</li>
<li><input disabled type="checkbox"> <p>事务的提交：commit;</p>
</li>
<li><input disabled type="checkbox"> <p>事务的回滚：rollback;</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个账户表模拟转账</span><br><span class="line">create table account (</span><br><span class="line">                         id tinyint(5) zerofill auto_increment  not null comment &apos;id编号&apos;,</span><br><span class="line">                         name varchar(20) default null comment &apos;客户姓名&apos;,</span><br><span class="line">                         money decimal(10,2) not null comment &apos;账户金额&apos;,</span><br><span class="line">                         primary key (id)</span><br><span class="line">                         )engine=innodb charset=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>开启autocommit（临时生效）：</p>
<p>OFF（0）：表示关闭<br>ON （1）：表示开启</p>
<pre><code>mysql&gt; set autocommit=0;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; show variables like &apos;autocommit&apos;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
mysql&gt; set autocommit=1;
Query OK, 0 rows affected (0.00 sec)
mysql&gt;
mysql&gt; show variables like &apos;autocommit&apos;;
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |</code></pre></li>
<li><p>开启autocommit（永久生效）：</p>
<p>修改配置文件：vi /etc/my.cnf<br>在[mysqld]下面加上：autocommit=1<br>记得重启服务才会生效</p>
</li>
</ul>
<h3 id="7-3-mysql核心知识之视图的应用"><a href="#7-3-mysql核心知识之视图的应用" class="headerlink" title="7.3 mysql核心知识之视图的应用"></a>7.3 mysql核心知识之视图的应用</h3><p><strong>简介：详细讲解视图的优缺点以及应用</strong></p>
<ul>
<li>什么是视图？视图的作用是什么？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视图（view）是一种虚拟存在的表，是一个逻辑表，它本身是不包含数据的。作为一个select语句保存在数据字典中的。</span><br><span class="line">通过视图，可以展现基表（用来创建视图的表叫做基表base table）的部分数据，说白了视图的数据就是来自于基表</span><br></pre></td></tr></table></figure>

<ul>
<li>视图的优点是：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</span><br><span class="line"></span><br><span class="line">2）安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</span><br><span class="line"></span><br><span class="line">3）数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响;源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</span><br><span class="line">　　</span><br><span class="line">4）不占用空间：视图是逻辑上的表，不占用内存空间</span><br><span class="line"></span><br><span class="line">总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。</span><br></pre></td></tr></table></figure>

<ul>
<li>视图的创建以及修改</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建的基本语法是：</span><br><span class="line">    create view &lt;视图名称&gt; as select 语句;</span><br><span class="line">    create view &lt;视图名称&gt; (字段) as select 语句;</span><br><span class="line">    create or replace view &lt;视图名称&gt;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改的语法是：</span><br><span class="line">alter view &lt;视图名称&gt; as select 语句;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视图删除语法：</span><br><span class="line">drop view &lt;视图名称&gt; ;</span><br></pre></td></tr></table></figure>

<ul>
<li>视图的缺点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1)性能差：sql server必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，sql server也要把它变成一个复杂的结合体，需要花费一定的时间。</span><br><span class="line"></span><br><span class="line">2)修改限制：当用户试图修改试图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的试图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。</span><br></pre></td></tr></table></figure>

<h3 id="7-4-mysql-的触发器介绍"><a href="#7-4-mysql-的触发器介绍" class="headerlink" title="7.4 mysql 的触发器介绍"></a>7.4 mysql 的触发器介绍</h3><p><strong>简介:介绍什么是触发器以及如何来创建</strong></p>
<ul>
<li>什么是触发器？</li>
</ul>
<p>​    触发器就是监视某种情况，并触发某种操作</p>
<ul>
<li>创建触发器的语法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create trigger 触发器名称  after/before   insert/update/delete on 表名  </span><br><span class="line">        for each row</span><br><span class="line">        begin</span><br><span class="line">        sql语句;</span><br><span class="line">        end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">after/before:可以设置为事件发生前或后</span><br><span class="line">insert/update/delete:它们可以在执行insert、update或delete的过程中触发</span><br><span class="line">for each row:每隔一行执行一次动作</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除触发器的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop trigger 触发器名称;</span><br></pre></td></tr></table></figure>
</li>
<li><p>演示：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个员工迟到表：</span><br><span class="line"> create table work_time_delay(</span><br><span class="line">            empno int not null comment &apos;雇员编号&apos;,</span><br><span class="line">            ename varchar(50) comment &apos;雇员姓名&apos;,</span><br><span class="line">            status int comment &apos;状态&apos;</span><br><span class="line">            );</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delimiter // 自定义语句的结束符号</span><br><span class="line"></span><br><span class="line">    mysql&gt; delimiter //</span><br><span class="line">    mysql&gt;</span><br><span class="line">    mysql&gt; create trigger trig_work after insert on work_time_delay</span><br><span class="line">        -&gt; for each row</span><br><span class="line">        -&gt; begin</span><br><span class="line">        -&gt; update employee set sal=sal-100 where empno=new.empno;</span><br><span class="line">        -&gt; end</span><br><span class="line">        -&gt; //</span><br><span class="line">    Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">new：指的是事件发生before或者after保存的新数据</span><br></pre></td></tr></table></figure>

<h3 id="7-5-mysql的存储过程介绍"><a href="#7-5-mysql的存储过程介绍" class="headerlink" title="7.5 mysql的存储过程介绍"></a>7.5 mysql的存储过程介绍</h3><p> <strong>简介：介绍什么是存储过程</strong></p>
<ul>
<li>什么是存储过程？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">存储过程就是把复杂的一系列操作，封装成一个过程。类似于shell，python脚本等。</span><br></pre></td></tr></table></figure>

<ul>
<li>存储过程的优缺点</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点是：</span><br><span class="line">    1)复杂操作，调用简单</span><br><span class="line">    2)速度快</span><br><span class="line"></span><br><span class="line">缺点是：</span><br><span class="line">    1）封装复杂</span><br><span class="line">    2) 没有灵活性</span><br></pre></td></tr></table></figure>

<ul>
<li>创建存储过程语法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 名称 (参数....)</span><br><span class="line">  		begin</span><br><span class="line">         过程体;</span><br><span class="line">         过程体;</span><br><span class="line">         end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数：in|out|inout 参数名称 类型（长度）</span><br><span class="line">        in：表示调用者向过程传入值（传入值可以是字面量或变量）</span><br><span class="line">        out：表示过程向调用者传出值(可以返回多个值)（传出值只能是变量）</span><br><span class="line">        inout：既表示调用者向过程传入值，又表示过程向调用者传出值（值只能是变量）</span><br></pre></td></tr></table></figure>

<ul>
<li>声明变量：declare 变量名 类型(长度) default 默认值;</li>
</ul>
<ul>
<li>给变量赋值：set @变量名=值;</li>
</ul>
<ul>
<li><p>调用存储命令：call 名称(@变量名);</p>
</li>
<li><p>删除存储过程命令：drop procedure 名称;</p>
</li>
<li><p>查看创建的存储过程命令：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create procedure 名称\G;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个简单的存储过程：</span><br><span class="line">    mysql&gt; delimiter //</span><br><span class="line">    mysql&gt; create procedure  name(in n int)</span><br><span class="line">        -&gt;             begin</span><br><span class="line">        -&gt;             select * from employee limit n;</span><br><span class="line">        -&gt;             end</span><br><span class="line">        -&gt; //</span><br><span class="line">    Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">    mysql&gt; set @n=5;</span><br><span class="line">        -&gt; //</span><br><span class="line">    Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">    mysql&gt;</span><br><span class="line">    mysql&gt; call name(@n);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt;         create procedure  name()</span><br><span class="line">      -&gt;             begin</span><br><span class="line">      -&gt;             declare  n int default 6;</span><br><span class="line">      -&gt;             select * from employee limit n;</span><br><span class="line">      -&gt;             end</span><br><span class="line">      -&gt; //</span><br><span class="line">  Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">  mysql&gt; call name();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="第8章：mysql必备核心知识之索引与存储引擎的介绍"><a href="#第8章：mysql必备核心知识之索引与存储引擎的介绍" class="headerlink" title="第8章：mysql必备核心知识之索引与存储引擎的介绍"></a>第8章：mysql必备核心知识之索引与存储引擎的介绍</h2><p>​    <strong>简介：各种索引的概述，以及如何创建索引与引擎的介绍</strong></p>
<h3 id="8-1-mysql的存储引擎介绍"><a href="#8-1-mysql的存储引擎介绍" class="headerlink" title="8.1 mysql的存储引擎介绍"></a>8.1 mysql的存储引擎介绍</h3><pre><code>**简介：主要来详细介绍MyISAM与InnoDB引擎**</code></pre><p>（1）什么是数据库存储引擎？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据库引擎是数据库底层软件组件，不同的存储引擎提供不同的存储机制，索引技巧，锁定水平等功能，使用不同的数据库引擎，可以获得特定的功能</span><br></pre></td></tr></table></figure>

<p>（2）如何查看引擎？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如何查看数据库支持的引擎</span><br><span class="line">show engines;</span><br><span class="line"></span><br><span class="line">查看当前数据的引擎：</span><br><span class="line">show create table 表名\G</span><br><span class="line"></span><br><span class="line">查看当前库所有表的引擎：</span><br><span class="line">show table status\G</span><br></pre></td></tr></table></figure>

<p>（3）建表时指定引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table yingqin (id int,name varchar(20)) engine=&apos;InnoDB&apos;;</span><br></pre></td></tr></table></figure>

<p>（4）修改表的引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 engine=&apos;MyiSAm&apos;;</span><br><span class="line"></span><br><span class="line">修改默认引擎</span><br><span class="line">​    vi /etc/my.cnf</span><br><span class="line">​    [mysqld]下面</span><br><span class="line">​    default-storage-engine=MyIsAM</span><br><span class="line">​    记得保存后重启服务</span><br></pre></td></tr></table></figure>

<p>（5）MyISAM与InnoDB的区别</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyISAM：支持全文索引（full text）;不支持事务;表级锁;保存表的具体行数;奔溃恢复不好</span><br><span class="line"></span><br><span class="line">Innodb：支持事务;以前的版本是不支持全文索引，但在5.6之后的版本就开始支持这个功能了;行级锁（并非绝对，当执行sql语句时不能确定范围时，也会进行锁全表例如： update table set id=3 where name like &apos;a%&apos;;）;不保存表的具体行数;奔溃恢复好</span><br></pre></td></tr></table></figure>

<p>（6）总结：什么时候选择什么引擎比较好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyISAM：</span><br><span class="line">​    一般来说MyISAM不需要用到事务的时候</span><br><span class="line">​    做很多count计算</span><br><span class="line"></span><br><span class="line">InnoDB：</span><br><span class="line">​    可靠性要求高的，或者要求支持事务</span><br><span class="line">​ 	 想要用到外键约束的时候（讲外键的时候会讲）</span><br><span class="line"></span><br><span class="line">推荐：</span><br><span class="line">​    推荐用InnoDB</span><br></pre></td></tr></table></figure>

<h3 id="8-2-mysql必备知识之常用索引精讲"><a href="#8-2-mysql必备知识之常用索引精讲" class="headerlink" title="8.2 mysql必备知识之常用索引精讲"></a>8.2 mysql必备知识之常用索引精讲</h3><p>​    <strong>简介：讲解什么是索引，索引的优缺点，以及常见索引有哪些</strong></p>
<ul>
<li>什么是索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">索引是一个单独的，存储在磁盘中上的数据库结构，它们包含着对数据表里的所有记录的引用指针。使用索引可以快速的找出在某列或多列中有特定值的行。</span><br></pre></td></tr></table></figure>

<p>-<br>  索引的优点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	通过创建唯一索引，来保证数据库表中的每一行数据的唯一性。</span><br><span class="line">​	可以加快数据的检索速度。</span><br><span class="line">​	可以保证表数据的完整性与准确性</span><br></pre></td></tr></table></figure>

<ul>
<li>索引的缺点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	索引需要占用物理空间。</span><br><span class="line">​	对表中的数据进行改动时，索引也需要跟着动态维护，降低了数据的维护速度。</span><br></pre></td></tr></table></figure>

<ul>
<li>索引的常见类型：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	index：普通索引</span><br><span class="line"></span><br><span class="line">​   unique：唯一索引</span><br><span class="line"></span><br><span class="line">​   primary key：主键索引</span><br><span class="line"></span><br><span class="line">​   foreign key：外键索引</span><br><span class="line"></span><br><span class="line">​   fulltext: 全文索引</span><br><span class="line"></span><br><span class="line">​   组合索引</span><br></pre></td></tr></table></figure>

<ul>
<li>创建表的sql语句：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test (</span><br><span class="line">	id int(7) zerofill auto_increment not null,</span><br><span class="line">	username varchar(20),</span><br><span class="line">	servnumber varchar(30),</span><br><span class="line">	password varchar(20),</span><br><span class="line">	createtime datetime,</span><br><span class="line">	primary key (id)</span><br><span class="line">)DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成百万甚至千万级别表的sql 语句 shell脚本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;请输入字段servnumber的值：&quot;</span><br><span class="line">read serber</span><br><span class="line">echo &quot;请输入创建sql语句的数量：&quot;</span><br><span class="line">read number</span><br><span class="line"></span><br><span class="line"># char=`head /dev/urandom | tr -dc 0-9 | head -c 11`</span><br><span class="line"></span><br><span class="line">for (( i=0;i&lt;$number;i++ ))</span><br><span class="line">        do</span><br><span class="line">        pass=`head /dev/urandom | tr -dc a-z | head -c 8`</span><br><span class="line">        let serber=serber+1</span><br><span class="line">        echo &quot;insert into test(id,username,servnumber,password,createtime) values(&apos;$i&apos;,&apos;user$&#123;i&#125;&apos;,&apos;$&#123;serber&#125;&apos;,&apos;$pass&apos;,now());&quot; &gt;&gt;sql.txt</span><br><span class="line"></span><br><span class="line">    done</span><br></pre></td></tr></table></figure>

<p>vi test.sh</p>
<p>执行shell脚本：sh test.sh</p>
<p>进行插数操作：source /home/dazhu/sql.txt</p>
<h3 id="8-3-mysql必备核心知识之普通索引与唯一索引"><a href="#8-3-mysql必备核心知识之普通索引与唯一索引" class="headerlink" title="8.3 mysql必备核心知识之普通索引与唯一索引"></a>8.3 mysql必备核心知识之普通索引与唯一索引</h3><p>​    <strong>简介：介绍普通索引与唯一索引</strong></p>
<ul>
<li>什么是普通索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通索引（index）顾名思义就是各类索引中最为普通的索引，主要任务就是提高查询速度。其特点是允许出现相同的索引内容，允许空（null）值</span><br></pre></td></tr></table></figure>

<ul>
<li>什么是唯一索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">唯一索引：（unique）顾名思义就是不可以出现相同的索引内容，但是可以为空（null）值</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如何创建普通索引或者唯一索引？</p>
<ul>
<li><p>创建表的时候创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table test (</span><br><span class="line">                        id int(7) zerofill auto_increment not null,</span><br><span class="line">                        username varchar(20),</span><br><span class="line">                        servnumber varchar(30),</span><br><span class="line">                        password varchar(20),</span><br><span class="line">                        createtime datetime,</span><br><span class="line">                        unique (id)</span><br><span class="line">                  )DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接为表添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">     alter table 表名 add index 索引名称 (字段名称);</span><br><span class="line"> eg:</span><br><span class="line"> 	 alter table test add unique unique_username (username);</span><br><span class="line"></span><br><span class="line">注意：假如没有指定索引名称时，会以默认的字段名为索引名称</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：create index 索引 on 表名 (字段名);</span><br><span class="line">eg：create index index_createtime on test (createtime);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看索引</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：show index from 表名\G</span><br><span class="line">eg: show index from test\G</span><br></pre></td></tr></table></figure>
</li>
<li><p>如何删除索引</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：drop index 索引名称 on 表名;</span><br><span class="line">eg：drop index unique_username on test;</span><br></pre></td></tr></table></figure>

<pre><code>语法：alter table 表名 drop index 索引名;
eg：alter table test drop index createtime;</code></pre><h3 id="8-4-mysql必备核心知识之主键索引"><a href="#8-4-mysql必备核心知识之主键索引" class="headerlink" title="8.4 mysql必备核心知识之主键索引"></a>8.4 mysql必备核心知识之主键索引</h3><p>​    <strong>简介：详细讲解主键索引</strong></p>
<ul>
<li>什么是主键索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把主键添加索引就是主键索引，它是一种特殊的唯一索引，不允许有空值，而唯一索引（unique是允许为空值的）。指定为“PRIMARY KEY”</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主键：主键是表的某一列，这一列的值是用来标志表中的每一行数据的。</span><br><span class="line">注意：每一张表只能拥有一个主键</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建主键：</p>
<pre><code>1）创建表的时候创建

2）直接为表添加主键索引
   语法：alter table 表名 add primary key (字段名);
   eg：alter table test add primary key (id);</code></pre></li>
<li><p>删除主键：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">alter table 表名 drop primary key;</span><br><span class="line">eg：</span><br><span class="line">alter table test drop primary key;</span><br><span class="line"></span><br><span class="line">注意：在有自增的情况下，必须先删除自增，才可以删除主键</span><br><span class="line"></span><br><span class="line">删除自增：alter table test change id id int(7) unsigned zerofill not null;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-mysql核心知识之全文索引的使用"><a href="#8-5-mysql核心知识之全文索引的使用" class="headerlink" title="8.5 mysql核心知识之全文索引的使用"></a>8.5 mysql核心知识之全文索引的使用</h3><p>​    <strong>简介：介绍什么是全文索引以及使用</strong></p>
<ul>
<li><p>什么是全文索引？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全文索引是将存储在数据库中的文章或者句子等任意内容信息查找出来的索引，单位是词。全文索引也是目前搜索引擎使用的一种关键技术。指定为 fulltex</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建练习表的sql：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table command (</span><br><span class="line">id int(5) unsigned primary key  auto_increment,</span><br><span class="line">name varchar(10),</span><br><span class="line">instruction varchar(60)</span><br><span class="line">)engine=MyISAM;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入数据sql：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into command values(&apos;1&apos;,&apos;ls&apos;,&apos;list directory contents&apos;);</span><br><span class="line">insert into command values(&apos;2&apos;,&apos;wc&apos;,&apos;print newline, word, and byte counts for each file&apos;);</span><br><span class="line">insert into command values(&apos;3&apos;,&apos;cut&apos;,&apos;remove sections from each line of files&apos;);</span><br><span class="line">insert into command values(&apos;4&apos;,&apos;sort&apos;,&apos;sort lines of text files&apos;);</span><br><span class="line">insert into command values(&apos;5&apos;,&apos;find&apos;,&apos;search for files in a directory hierarchy&apos;);</span><br><span class="line">insert into command values(&apos;6&apos;,&apos;cp&apos;,&apos;复制文件或者文件夹&apos;);</span><br><span class="line">insert into command values(&apos;7&apos;,&apos;top&apos;,&apos;display Linux processes&apos;);</span><br><span class="line">insert into command values(&apos;8&apos;,&apos;mv&apos;,&apos;修改文件名，移动&apos;);</span><br><span class="line">insert into command values(&apos;9&apos;,&apos;停止词&apos;,&apos;is,not,me,yes,no ...&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加全文索引：</p>
<ul>
<li><p>创建表的时候创建全文索引</p>
</li>
<li><p>通过alter添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table command  add fulltext(instruction);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用全文索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from 表名 where match  (字段名) against (&apos;检索内容&apos;);</span><br><span class="line">select * from command where match(instruction) against (&apos;sections&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看匹配度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from command where match(instruction) against (&apos;directory&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止词：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">出现频率很高的词，将会使全文索引失效</span><br></pre></td></tr></table></figure>
</li>
<li><p>in boolean mode 模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in boolean mode：意思是指定全文检索模式为布尔全文检索（简单可以理解为是检索方式）</span><br><span class="line">select * from 表名 where match (字段名) against (&apos;检索内容&apos; in boolean mode);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用通配符*时，只能放在词的后边，不能放前边。</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除全文索引：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table command drop index instruction;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意点总结：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 	1、一般情况下创建全文索引的字段数据类型为 char、varchar、text 。其它字段类型不可以</span><br><span class="line"></span><br><span class="line">​   2、全文索引不针对非常频繁的词做索引。比如is，no，not，you，me，yes这些，我们称之为停止词</span><br><span class="line"></span><br><span class="line">​   3、对英文检索时忽略大小写</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8-6-mysql核心知识之外键约束剖析"><a href="#8-6-mysql核心知识之外键约束剖析" class="headerlink" title="8.6 mysql核心知识之外键约束剖析"></a>8.6 mysql核心知识之外键约束剖析</h3><p>​    <strong>简介：解析什么是外键约束，以及有什么作用</strong></p>
<ul>
<li>什么是外键？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">外键就是作用于两个表数据之间的链接的一列或多列，用来保证表与表之间的数据的完整性和准确性。</span><br></pre></td></tr></table></figure>

<ul>
<li>添加外键约束：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法：foreign key (字段名) references 关联的表名(关联表的字段名)</span><br><span class="line"></span><br><span class="line">注意：主键跟外键的字段类型一定要相</span><br><span class="line"></span><br><span class="line">create table的方法：</span><br><span class="line"></span><br><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `empno` int(11) NOT NULL COMMENT &apos;雇员编号&apos;,</span><br><span class="line">  `ename` varchar(50) DEFAULT NULL COMMENT &apos;雇员姓名&apos;,</span><br><span class="line">  `job` varchar(30) DEFAULT NULL,</span><br><span class="line">  `mgr` int(11) DEFAULT NULL COMMENT &apos;雇员上级编号&apos;,</span><br><span class="line">  `hiredate` date DEFAULT NULL COMMENT &apos;雇佣日期&apos;,</span><br><span class="line">  `sal` decimal(7,2) DEFAULT NULL COMMENT &apos;薪资&apos;,</span><br><span class="line">  `deptnu` int(11) DEFAULT NULL COMMENT &apos;部门编号&apos;,</span><br><span class="line">  PRIMARY KEY (`empno`),</span><br><span class="line"> foreign key (deptnu) references dept(deptnu)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line"> alter table的方法：</span><br><span class="line"> alter table employee add foreign key (deptnu) references dept(deptnu);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除外键约束：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注意：在干掉外键索引之前必须先把外键约束删除，才能删除索引</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table employee drop index deptnu;</span><br><span class="line">ERROR 1553 (HY000): Cannot drop index &apos;deptnu&apos;: needed in a foreign key constraint</span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; alter table employee drop foreign key employee_ibfk_1;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; alter table employee drop index deptnu;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<ul>
<li>注意点总结：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）俩个表，主键跟外键的字段类型一定要相同</span><br><span class="line"></span><br><span class="line">（2）要使用外键约束表的引擎一定得是InnoDB引擎，MyISAM是不起作用的</span><br><span class="line"></span><br><span class="line">（3）在干掉外键索引之前必须先把外键约束删除，才能删除索引</span><br></pre></td></tr></table></figure>

<h3 id="8-7-mysql核心知识之联合索引"><a href="#8-7-mysql核心知识之联合索引" class="headerlink" title="8.7 mysql核心知识之联合索引"></a>8.7 mysql核心知识之联合索引</h3><p>​    <strong>简介：详细介绍联合索引</strong></p>
<ul>
<li>什么是联合索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">联合索引又称组合索引或者复合索引，是建立在俩列或者多列以上的索引。</span><br></pre></td></tr></table></figure>

<ul>
<li>怎么来创建联合索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table 表名 add index(字段1,字段2,字段3);</span><br><span class="line"></span><br><span class="line">alter table test add index(username,servnumber,password);</span><br></pre></td></tr></table></figure>

<ul>
<li>怎么删除联合索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table test drop index username;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要使用联合索引，而不使用多个单列索引？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">联合索引的效率远远高于单列索引</span><br></pre></td></tr></table></figure>

<ul>
<li><p>联合索引的最左原则</p>
</li>
<li><p>注意点总结：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 索引并非越多越好，过多的索引会增加数据的维护速度还有磁盘空间的浪费。</span><br><span class="line"></span><br><span class="line">​ 当表的数据量很大的时候，可以考虑建立索引。</span><br><span class="line"></span><br><span class="line">​ 表中经常查数据的字段，可以考虑建立索引。</span><br><span class="line"></span><br><span class="line">​ 想要保证表中数据的唯一性，可以考虑建立唯一索引。</span><br><span class="line"></span><br><span class="line">​ 想要保证俩张表中的数据的完整性跟准确性，可以考虑建立外键约束。</span><br><span class="line"></span><br><span class="line">​ 经常对多列数据进行查询时，可以考虑建立联合索引。</span><br></pre></td></tr></table></figure>

<h2 id="第9章：mysql不得不学的sql语句优化思路"><a href="#第9章：mysql不得不学的sql语句优化思路" class="headerlink" title="第9章：mysql不得不学的sql语句优化思路"></a>第9章：mysql不得不学的sql语句优化思路</h2><p>​    <strong>简介：介绍如何对sql查询语句进行优化</strong></p>
<h3 id="9-1-mysql的慢查询日志开启与问题定位"><a href="#9-1-mysql的慢查询日志开启与问题定位" class="headerlink" title="9.1 mysql的慢查询日志开启与问题定位"></a>9.1 mysql的慢查询日志开启与问题定位</h3><p>​    <strong>简介：介绍如何开启慢查询日志与问题定位</strong></p>
<ul>
<li>第一步：查看是否已经开启了慢查询日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;slow%&apos;;</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| Variable_name       | Value                                |</span><br><span class="line">+---------------------+--------------------------------------+</span><br><span class="line">| slow_launch_time    | 2                                    |</span><br><span class="line">| slow_query_log      | OFF                                  |</span><br><span class="line">| slow_query_log_file | /data/mydata/xdclass-public-slow.log |</span><br><span class="line">+---------------------+--------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：开启慢查询日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global slow_query_log = on ;</span><br><span class="line"></span><br><span class="line">日志路径也可以自定义：</span><br><span class="line"></span><br><span class="line">set global slow_query_log_file = &apos;路径&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：查看慢查询的时间临界值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &apos;%long%&apos;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第四步：设置慢查询的时间标准</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set long_query_time=0.4;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：重启mysql服务会让在交互界面设置的慢查询恢复到默认</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">永久生效的设置方法：修改配置文件 vi /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">slow_query_log = 1</span><br><span class="line">long_query_time = 0.1</span><br><span class="line">slow_query_log_file =/usr/local/mysql/mysql_slow.log</span><br><span class="line"></span><br><span class="line">最后必须重启服务才能生效！</span><br></pre></td></tr></table></figure>

<h3 id="9-2-mysql的sql语句执行过程解析"><a href="#9-2-mysql的sql语句执行过程解析" class="headerlink" title="9.2 mysql的sql语句执行过程解析"></a>9.2 mysql的sql语句执行过程解析</h3><p>​    <strong>简介：介绍如何开启性能详情</strong></p>
<ul>
<li>第一步：查看性能详情是否开启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%profiling%&apos;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| have_profiling         | YES   |</span><br><span class="line">| profiling              | OFF   |</span><br><span class="line">| profiling_history_size | 15    |</span><br><span class="line">+------------------------+-------+</span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：开启性能记录功能</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set profiling = on ;</span><br></pre></td></tr></table></figure>

<ul>
<li>第三步：查看性能的记录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                             |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br><span class="line">|        1 | 0.00177775 | show variables like &apos;%profiling%&apos;                 |</span><br><span class="line">|        2 | 0.00037900 | select * from test where id=&apos;087878&apos;              |</span><br><span class="line">|        3 | 0.34618025 | select * from test where servnumber=&apos;1367008787&apos;  |</span><br><span class="line">|        4 | 0.31986825 | select * from test where servnumber=&apos;13670087879&apos; |</span><br><span class="line">+----------+------------+---------------------------------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>第四步：查看语句的执行性能详情</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profile for query 4;</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| Status               | Duration |</span><br><span class="line">+----------------------+----------+</span><br><span class="line">| starting             | 0.000100 |</span><br><span class="line">| checking permissions | 0.000010 |</span><br><span class="line">| Opening tables       | 0.000023 |</span><br><span class="line">| init                 | 0.000045 |</span><br><span class="line">| System lock          | 0.000015 |</span><br><span class="line">| optimizing           | 0.000016 |</span><br><span class="line">| statistics           | 0.000028 |</span><br><span class="line">| preparing            | 0.000020 |</span><br><span class="line">| executing            | 0.000006 |</span><br><span class="line">| Sending data         | 0.319489 |</span><br><span class="line">| end                  | 0.000037 |</span><br><span class="line">| query end            | 0.000012 |</span><br><span class="line">| closing tables       | 0.000012 |</span><br><span class="line">| freeing items        | 0.000040 |</span><br><span class="line">| cleaning up          | 0.000017 |</span><br><span class="line">+----------------------+----------+</span><br></pre></td></tr></table></figure>

<ul>
<li>性能线程的详细解释官方文档链接：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html</span><br></pre></td></tr></table></figure>

<h3 id="9-3-mysql语句优化的几个小建议"><a href="#9-3-mysql语句优化的几个小建议" class="headerlink" title="9.3 mysql语句优化的几个小建议"></a>9.3 mysql语句优化的几个小建议</h3><p>​    <strong>简介：介绍日常工作应该尽量避免的sql语句</strong></p>
<ul>
<li>第一个注意点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尽量避免使用select *from ，尽量精确到想要的结果字段</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个注意点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">尽量避免条件使用or</span><br></pre></td></tr></table></figure>

<ul>
<li>第三个注意点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记得加上limit 限制行数，避免数据量过大消耗性能</span><br></pre></td></tr></table></figure>

<ul>
<li>第四个注意点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用模糊查询时，%放在前面是会使索引失效</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from test where servnumber like &apos;%1367000%&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: test</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 996303</span><br><span class="line">     filtered: 11.11</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure>

<ul>
<li>第五个注意点：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">要小心条件字段类型的转换</span><br></pre></td></tr></table></figure>

<h2 id="第10章：mysql数据安全核心知识之备份技能"><a href="#第10章：mysql数据安全核心知识之备份技能" class="headerlink" title="第10章：mysql数据安全核心知识之备份技能"></a>第10章：mysql数据安全核心知识之备份技能</h2><p>​    <strong>简介：介绍备份数据的重要性以及一些常见的数据备份技能</strong></p>
<h3 id="10-1-mysql数据安全之备份的背景意义"><a href="#10-1-mysql数据安全之备份的背景意义" class="headerlink" title="10.1 mysql数据安全之备份的背景意义"></a>10.1 mysql数据安全之备份的背景意义</h3><p>​    <strong>简介：数据库备份的意义</strong></p>
<ul>
<li><p>数据备份的意义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）保护数据的安全；</span><br><span class="line"></span><br><span class="line">（2）在出现意外的时候（硬盘的损坏，断电，黑客的攻击），以便数据的恢复；</span><br><span class="line"></span><br><span class="line">（3）导出生产的数据以便研发人员或者测试人员测试学习；</span><br><span class="line"></span><br><span class="line">（4）高权限的人员操作失误导致数据丢失，以便恢复；</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-2-mysql数据安全之备份的介绍"><a href="#10-2-mysql数据安全之备份的介绍" class="headerlink" title="10.2 mysql数据安全之备份的介绍"></a>10.2 mysql数据安全之备份的介绍</h3><p>​    <strong>简介：介绍数据备份</strong></p>
<ul>
<li><p>数据库的备份类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）完全备份：对整个数据库的数据进行备份</span><br><span class="line"></span><br><span class="line">（2）部分备份：对部分数据进行备份（可以是一张表也可以是多张表）</span><br><span class="line"></span><br><span class="line">	  增量备份：是以上一次备份为基础来备份变更数据的，节约空间</span><br><span class="line"></span><br><span class="line">	  差异备份：是以第一次完全备份的基础来备份变更备份的，浪费空间</span><br></pre></td></tr></table></figure>

<p><img src="/2019/10/19/mysql/mysql数据库入门基础实战/C:%5CUsers%5Cdabiao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1555089061504.png" alt="1555089061504"></p>
</li>
<li><p>数据库备份的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）逻辑备份：直接生成sql语句保存起来，在恢复数据的时候执行备份的sql语句来实现数据的恢复</span><br><span class="line"></span><br><span class="line">（2）物理备份：直接拷贝相关的物理数据</span><br><span class="line"></span><br><span class="line">区别：逻辑备份效率低，恢复数据效率低，但是逻辑备份节约空间；物理备份浪费空间，但是相对逻辑备份而言效率比较高</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库备份的场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）热备份：备份时，数据库的读写操作不会受到影响</span><br><span class="line"></span><br><span class="line">（2）温备份：备份时，数据库的读操作可以进行，但是写操作不能执行</span><br><span class="line"></span><br><span class="line">（3）冷备份：备份时，不能进行任何操作</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-3-mysql数据安全之mysqldump备份实例（跨机器）"><a href="#10-3-mysql数据安全之mysqldump备份实例（跨机器）" class="headerlink" title="10.3 mysql数据安全之mysqldump备份实例（跨机器）"></a>10.3 mysql数据安全之mysqldump备份实例（跨机器）</h3><p>​    <strong>简介：如何利用mysql自带命令mysqldump来备份单库或者多库</strong></p>
<ul>
<li><p>mysqldump使用语法：</p>
<p>mysqldump -u 用户 -h host -p 密码 dbname table &gt; 路径</p>
</li>
<li><p>远程备份单库例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pabc123456 -h120.25.93.69 zabbix | gzip  &gt; /mysql_data_back/zabbix_users.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程备份单库例子并保留创建库语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pabc123456 -h120.25.93.69 --databases zabbix | gzip  &gt; /mysql_data_back/zabbix_bak.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程备份单库单表的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pabc123456 -h120.25.93.69 zabbix  users | gzip  &gt; /mysql_data_back/zabbix_users.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程备份多库的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pabc123456 -h120.25.93.69 --databases zabbix XD | gzip  &gt; /mysql_data_back/zabbix_XD.sql.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程备份全库的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -pabc123456 -h120.25.93.69 --all-databases  | gzip  &gt; /mysql_data_back/all.sql.gz</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-4-mysql数据安全之mysql数据的恢复"><a href="#10-4-mysql数据安全之mysql数据的恢复" class="headerlink" title="10.4 mysql数据安全之mysql数据的恢复"></a>10.4 mysql数据安全之mysql数据的恢复</h3><p>​    <strong>简介：如何恢复数据</strong></p>
<ul>
<li><p>远程恢复数据（备份的数据文件里有创建库的语句）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pabc123456 -h120.25.93.69  &lt; zabbix_bak.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程恢复数据（备份的数据文件里没有创建库的语句）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -pabc123456 -h120.25.93.69  zabbix &lt; zabbix_bak.sql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-5-mysql数据安全之物理备份"><a href="#10-5-mysql数据安全之物理备份" class="headerlink" title="10.5 mysql数据安全之物理备份"></a>10.5 mysql数据安全之物理备份</h3><p>​    <strong>简介：详解数据库源文件以及如何物理备份</strong></p>
<ul>
<li><p>看找数据库源文件路径（一）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;datadir%&apos;;</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| Variable_name | Value         |</span><br><span class="line">+---------------+---------------+</span><br><span class="line">| datadir       | /data/mydata/ |</span><br><span class="line">+---------------+---------------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>看找数据库源文件路径（二）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat /etc/my.cnf</span><br></pre></td></tr></table></figure>
</li>
<li><p>MyISAM表源文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.opt：创建库的时候生成，主要存储着当前库的默认字符集和字符校验规则</span><br><span class="line"></span><br><span class="line">.frm ：记录着表结构信息的文件</span><br><span class="line"></span><br><span class="line">.MYI：记录着索引的文件</span><br><span class="line"></span><br><span class="line">.MYD :记录着表的数据</span><br></pre></td></tr></table></figure>
</li>
<li><p>InnoDB表源文件：InnoDB有着共享表空间跟独立表空间的概念。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.opt：创建库的时候生成，主要存储着当前库的默认字符集和字符校验规则</span><br><span class="line"></span><br><span class="line">.frm ：记录着表结构信息的文件</span><br><span class="line"></span><br><span class="line">.ibd ：独立表空间，里边记录这个表的数据和索引</span><br><span class="line"></span><br><span class="line">ibdata1：共享表空间，里边记录表的数据和索引</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求全局读锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure>
</li>
<li><p>解锁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-6-mysql数据安全之利用二进制日志mysqlbinlog备份数据"><a href="#10-6-mysql数据安全之利用二进制日志mysqlbinlog备份数据" class="headerlink" title="10.6 mysql数据安全之利用二进制日志mysqlbinlog备份数据"></a>10.6 mysql数据安全之利用二进制日志mysqlbinlog备份数据</h3><p>​    <strong>简介：讲解如何利用二进制日志来备份数据</strong></p>
<ul>
<li><p>什么是二进制日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二进制日志就是记录着mysql数据库中的一些写入性操作，比如一些增删改，但是，不包括查询！</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制日志有哪些功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一般情况下，二进制日志有着数据复制和数据恢复的功能</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启二进制日志会有1%的性能消耗！</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看二进制日志是否开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;log_bin%&apos;;</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| Variable_name                   | Value |</span><br><span class="line">+---------------------------------+-------+</span><br><span class="line">| log_bin                         | OFF   |</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启二进制日志 : vi /etc/my.cnf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=/data/mydata/log_bin/mysql-bin</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有的binlog日志列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |     23638 |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新二进制日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flush logs;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重置(清空）二进制日志文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |      1091 |</span><br><span class="line">+------------------+-----------+</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用mysqldump备份数据时，加上-F选项可以重新生成一个新的二进制日志文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p XD user -F  &gt; user_bak.sql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10-7-mysql数据安全之利用二进制日志mysqlbinlog恢复数据"><a href="#10-7-mysql数据安全之利用二进制日志mysqlbinlog恢复数据" class="headerlink" title="10.7 mysql数据安全之利用二进制日志mysqlbinlog恢复数据"></a>10.7 mysql数据安全之利用二进制日志mysqlbinlog恢复数据</h3><p>​    <strong>简介：讲解如何利用二进制日志来恢复数据</strong></p>
<ul>
<li><p>查看二进制日志文件的内容报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@xdclass-public log_bin]# mysqlbinlog mysql-bin.000002</span><br><span class="line">mysqlbinlog: [ERROR] unknown variable &apos;default-character-set=utf8&apos;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：在mysqlbinlog 后边加上 --no-defaults</span><br><span class="line"></span><br><span class="line">第二种：注释掉配置文件里边的default-character-set=utf8</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>把二进制日志文件导出成普通文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --base64-output=DECODE-ROWS -v mysql-bin.000002 &gt; mysqlbin.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出要恢复的位置：</p>
</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）找出关键字的行数：mysqlbinlog --no-defaults mysql-bin.000002 | cat -n  | grep -iw &apos;drop&apos;</span><br><span class="line"></span><br><span class="line">[root@xdclass-public log_bin]# mysqlbinlog --no-defaults mysql-bin.000002 | cat -n  | grep -iw &apos;drop&apos;</span><br><span class="line">  4180  DROP TABLE `user` /* generated by server */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">（2）打印出相关内容：mysqlbinlog --no-defaults mysql-bin.000002 | cat -n | sed -n &apos;4170,4180p&apos;</span><br><span class="line"></span><br><span class="line">[root@xdclass-public log_bin]# mysqlbinlog --no-defaults mysql-bin.000002 | cat -n | sed -n &apos;4170,4180p&apos;</span><br><span class="line">  4170  # at 59578</span><br><span class="line">  4171  #190419  0:41:48 server id 1  end_log_pos 59609 CRC32 0x36cda2b7        Xid = 6380</span><br><span class="line">  4172  COMMIT/*!*/;</span><br><span class="line">  4173  # at 59609</span><br><span class="line">  4174  #190419  0:41:48 server id 1  end_log_pos 59674 CRC32 0x8de2f06a        Anonymous_GTID  last_committed=145      sequence_number=146</span><br><span class="line">  4175  SET @@SESSION.GTID_NEXT= &apos;ANONYMOUS&apos;/*!*/;</span><br><span class="line">  4176  # at 59674</span><br><span class="line">  4177  #190419  0:41:48 server id 1  end_log_pos 59787 CRC32 0x6b2edd2b        Query   thread_id=14    exec_time=0     error_code=0</span><br><span class="line">  4178  use `XD`/*!*/;</span><br><span class="line">  4179  SET TIMESTAMP=1555605708/*!*/;</span><br><span class="line">  4180  DROP TABLE `user` /* generated by server */</span><br><span class="line">[root@xdclass-public log_bin]#</span><br></pre></td></tr></table></figure>

<ul>
<li><p>恢复数据：</p>
<ul>
<li><p>第一步：把备份的数据表user恢复到数据库中：mysql -uroot -p XD &lt; /mysql_data_back/user_bak.sql</p>
</li>
<li><p>第二步：利用上面找到的删除的位置进行恢复数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --set-charset=utf8  --stop-position=&quot;59674&quot; /data/mydata/log_bin/mysql-bin.000002 | mysql -uroot -p</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>登录数据库查看数据是否恢复回来</p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>awk</title>
    <url>/2019/10/11/linux/awk/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#简介">简介</a></li>
<li><a href="#使用">使用</a><ul>
<li><a href="#简单实践">简单实践</a><ul>
<li><a href="#例子">例子</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>Awk是一种小巧的编程语言及命令行工具。（其名称得自于它的创始人Alfred Aho、Peter Weinberger 和 Brian Kernighan姓氏的首个字母）。它非常适合服务器上的日志处理，主要是因为Awk可以对文件进行操作，通常以可读文本构建行</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="简单实践"><a href="#简单实践" class="headerlink" title="简单实践"></a>简单实践</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p>默认情况下，awk通过空格分隔输入，使用 -F 指定分割符。选择输入的第的字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk -F , &apos;&#123;print $1,$3&#125;&apos;</span><br><span class="line">Hello nice</span><br><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk -F &apos;,&apos; &apos;&#123;print $1,$3&#125;&apos;</span><br><span class="line">Hello awk</span><br></pre></td></tr></table></figure>
</li>
<li><p>awk中内置的$NF变量代表字段的数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo &apos;Hello awk, nice to see you&apos; | awk &apos;&#123;print $NF&#125;&apos;</span><br><span class="line">you</span><br></pre></td></tr></table></figure>
</li>
<li><p>维持跨行状态，END代表的是我们在执行完每行的处理之后只处理下面的代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@aliyun ~]# echo -e &apos;a 1\nb 2\nc 3&apos; | awk &apos;&#123;print $2&#125;&apos;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">[root@aliyun ~]# echo -e &apos;one 1\ntwo 2&apos; | awk &apos;&#123;sum+=$2&#125; END &#123;print sum&#125;&apos;&apos;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL数据库安装</title>
    <url>/2019/03/12/mysql/mysql_install/</url>
    <content><![CDATA[<!-- TOC START min:1 max:3 link:true asterisk:false update:true -->
<ul>
<li><a href="#mysql数据yum源安装">MySQL数据yum源安装</a><ul>
<li><a href="#安装">安装</a><!-- TOC END -->
<a id="more"></a>

</li>
</ul>
</li>
</ul>
<h1 id="MySQL数据yum源安装"><a href="#MySQL数据yum源安装" class="headerlink" title="MySQL数据yum源安装"></a>MySQL数据yum源安装</h1><ul>
<li>centos7下安装</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><h3 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h3></li>
</ul>
<ol>
<li><p>安装mysql的rpm包<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">rpm下载地址</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装rmp</span></span><br><span class="line">sudo yum localinstall mysql80-community-release-el7-&#123;version-number&#125;.noarch.rpm</span><br><span class="line"><span class="comment"># 查看enable的安装包</span></span><br><span class="line">yum repolist enabled | grep <span class="string">"mysql.*-community.*"</span></span><br><span class="line"><span class="comment"># 调整安装版本</span></span><br><span class="line">yum-config-manager --<span class="built_in">disable</span>/--<span class="built_in">enable</span> mysqlxx-community</span><br></pre></td></tr></table></figure>

<p><img src alt="mysql_install_rpm_list"></p>
</li>
<li><p>在线安装mysql</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum install mysql-community-server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3></li>
</ul>
<ol>
<li><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载安装包</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xvf mysql-8.0.20-linux-glibc2.12-x86_64.tar.xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建mysql用户和用户组</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grpadd -g 27 mysql</span><br><span class="line">useradd -u 27 -g 27 -s /sbin/nologin mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改mysql文件权限</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/<span class="built_in">local</span>/mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建配置文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">datadir=/usr/<span class="built_in">local</span>/mysql/data</span><br><span class="line">socket=/var/lib/mysql/mysql.sock</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"><span class="built_in">log</span>-error=/var/<span class="built_in">log</span>/mysqld.log</span><br><span class="line"><span class="built_in">bind</span>-address=0.0.0.0</span><br><span class="line">port=3306</span><br><span class="line"><span class="comment">#skip-grant-tables</span></span><br><span class="line">user=mysql</span><br><span class="line">tmpdir=/tmp</span><br><span class="line"><span class="built_in">log</span>-bin=master-bin</span><br><span class="line"><span class="built_in">log</span>-bin-index=master-bin.index</span><br><span class="line">server-id=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>MySQL初始化</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/mysql/bin/mysqld --initialize --user=mysql</span><br><span class="line"><span class="comment"># 网上教程坑了，不需提前创建data数据目录。初始化会自动创建</span></span><br><span class="line"><span class="comment"># 如果报错文件不存在，创建相应文件夹，修改权限，属主合所属组</span></span><br><span class="line"><span class="comment"># 报错查看错误日志</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加服务开机只启动</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server /etc/rc.d/init.d/mysqld</span><br><span class="line">systemctl <span class="built_in">enable</span> mysqld.server</span><br><span class="line"><span class="comment"># chkconfig --add mysqld</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.server</span><br></pre></td></tr></table></figure>

<ul>
<li>中间报错信息  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无法更新pid文件到时服务器启动失败。</span><br><span class="line">1.  权限不正确，需要讲mysql需要的文件全部改为 mysql:mysql 属性</span><br><span class="line">2.  无法创建pid文件上级目录。通过手工创建临时解决。永久解决修改/etc/rc.d/init.d/mysqld文件。</span><br><span class="line">    vim /etc/rc.d/init.d/mysqld</span><br><span class="line"></span><br><span class="line">    mkdir -p /path/to/pidfile</span><br><span class="line">    chown -R mysql:mysql /path/to/pidfile</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>添加mysql环境变量</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:/usr/local/mysql/bin"</span> &gt;&gt; /etc/bashrc</span><br><span class="line"><span class="built_in">source</span> /etc/bashrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>首次登陆密码位于mysql日志中，通过查看MySQL日志来获取</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">alter user <span class="string">'root'</span>@<span class="string">'localhost'</span> identified with <span class="string">'mysql_native_password'</span> by <span class="string">'password'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
</search>
